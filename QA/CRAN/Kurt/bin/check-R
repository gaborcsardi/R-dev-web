#! /bin/sh

## Fully Qualified Domain Name of the system we use for checking.
FQDN=`hostname -f`

## Default flavor to use.
R_flavor=r-devel
## Location of the CRAN mirror root on the local file system.
case ${FQDN} in
  aragorn.ci.tuwien.ac.at)
    CRAN_rsync=/usr/local/src/apps/stat/R ;;
  anduin.wu-wien.ac.at)
    CRAN_rsync=/home/data/pub/R ;;
  r-forge.wu-wien.ac.at|eragon.wu-wien.ac.at)
    CRAN_rsync=/srv/R/CRAN ;;
  *)
    CRAN_rsync=/data/Repositories/CRAN ;;
esac
## Location of CRAN's src/contrib on the local file system.
CRAN_dir=${CRAN_rsync}/src/contrib
## Where everything happens.
check_dir=~/tmp/R.check
## Check date in ISO 8601 format.  GNU specific ...
check_date=`date -Idate`
check_results_mail_recipients="Kurt.Hornik@wu-wien.ac.at"
case ${FQDN} in
  r-forge.wu-wien.ac.at)
    check_results_mail_recipients="R-core@R-project.org" ;;
esac    
check_results_files="SUMMARY check.csv summary.rds time_c.out time_i.out"
## Compilers to use.
## Use configure defaults (gcc/g++/gfortran).
compilers=
## Additional command line arguments to configure.
configure_args="--with-blas=no --enable-R-shlib"
## R scripts directory.
R_scripts_dir=~/lib/R/Scripts
## R profile for checking.
R_profile=${R_scripts_dir}/check_profile.R
## Shell scripts directory.
sh_scripts_dir=~/lib/bash

## Command line args.
while test -n "${1}"; do
  case "${1}" in
    -r)
      R_flavor=r-release ;;
    -p)
      R_flavor=r-patched ;;
    -v)
      case "${2}" in
        4.*)
	  compilers="CC=gcc-${2} CXX=g++-${2} F77=gfortran-${2}
	    FC=gfortran-${2} OBJC=gcc-${2} OBJCXX=gcc-${2}"
	  ;;
	3.*)
          compilers="CC=gcc-${2} CXX=g++-${2} F77=g77-${2}"
	  ;;
      esac
      shift ;;
  esac
  shift
done

## Start a virtual framebuffer X server and use this for DISPLAY so that
## we can run package tcltk and friends.  We use the PID of the check
## process as the server number so that the checks for different flavors
## get different servers.
PATH=${PATH}:/usr/bin/X11
Xvfb :${$} -screen 0 1280x1024x24 &
Xvfb_pid=`ps auxw | grep "Xvfb :${$}" | grep -v grep | awk '{ print $2 }'`
export DISPLAY=:${$}

if test -n "${BASH_VERSION}"; then
  ## No process is allowed more than 10 minutes
  ulimit -t 600
fi

## export _R_CHECK_WEAVE_VIGNETTES_=no
export _R_CHECK_SUBDIRS_STRICT_=yes
export _R_CHECK_FORCE_SUGGESTS_=no

## Try using a UTF-8 locale.
export LANG="en_US.UTF-8"

do_cleanup_and_exit () {
  kill -9 ${Xvfb_pid}
  exit ${1-0}
}

test -d ${check_dir} || mkdir ${check_dir} || do_cleanup_and_exit 1
cd ${check_dir}

## Structure inside $check_dir: subdirs for each flavor.  Within these,
## most of the work happens in 'Work', inside which R sources are in
## 'src', R is built in 'build', and packages are in 'PKGS'.  When done,
## 'PKGS' is moved up for mirroring, and results are saved in 'Results'.
test -d ${R_flavor} || mkdir ${R_flavor} || do_cleanup_and_exit 1
cd ${R_flavor}
test -d Work || mkdir Work || do_cleanup_and_exit 1
cd Work

## Update ${R_flavor} sources.
## Actually, we should check whether flavor of source and target agree.
test -d src || mkdir src || do_cleanup_and_exit 1
if test "`hostname`" = mithrandir; then
  (cd ~/src/apps/R/${R_flavor}/R; tar cf - . ) | ( cd src; tar xf -)
else
  ## Argh, rsync is gone (at least for the time being ...).
  ## We could of course use svn checkout on https://svn.R-project.org/R,
  ## but how can one get "r-patched" and "r-release" without knowing the
  ## corresponding branch?  Hence, we get things from CRAN (release) or
  ## ETHZ, but need to figure out the top-level source dir for the
  ## unpackaged version somehow (of course, we could also read this from
  ## the archive).
  ## (cd src; rsync -rC -t --delete rsync.r-project.org::${R_flavor} .)
  ## <FIXME>
  ## Shouldn't we use svn checkout for r-devel?
  ## </FIXME>
  case "${R_flavor}" in
    r-devel)
      url=ftp://ftp.stat.math.ethz.ch/Software/R/R-devel.tar.gz ;;
    r-patched)
      ## <NOTE>
      ## Adjust as needed ...
      ## url=ftp://ftp.stat.math.ethz.ch/Software/R/R-patched.tar.gz
      url=http://cran.at.r-project.org/src/base-prerelease/R-latest.tar.gz
      ## </NOTE>
      ;;
    r-release)
      url=http://cran.r-project.org/src/base/R-latest.tar.gz ;;
  esac
  mv src src.save
  (mkdir tmp &&
    cd tmp &&
    touch stamp &&
    wget -O - --retr-symlinks ${url} | tar zxmf - &&
    entry=`find . -newer stamp -type d -mindepth 1 -maxdepth 1` &&
    mv ${entry} ../src &&
    cd .. &&
    rm -rf src.save tmp) || (rm -rf tmp; mv src.save src)
fi
R_VERSION=`cut -f1 -d' ' src/VERSION`
if test "`cut -f2 -d' ' src/VERSION`" = "Patched"; then
  R_VERSION=`echo ${R_VERSION} | sed 's/\.[0-9]*$//'`
  R_VERSION="${R_VERSION}-patched"
fi

## Update package sources.  Could make this much smarter but we need to
## make sure that there are no left-overs in case of updates.
case ${FQDN} in
  *.wu-wien.ac.at)
    if test -d /data/Repositories/CRAN; then
      (cd /data/Repositories/CRAN/src/contrib; 
        rsync -t -v --delete -r -l --safe-links \
          cran.wu-wien.ac.at::CRAN/src/contrib/ .)
    fi
    ;;
esac    

## Link recommended packages.
(cd src; \
  CRAN_RSYNC="${CRAN_rsync}" ./tools/rsync-recommended)

## Rebuild R.
rm -rf build
mkdir build
(cd build && ../src/configure ${configure_args} ${compilers} \
  && make && make check) || do_cleanup_and_exit 1
mkdir build/Packages
R_HOME=`./build/bin/R RHOME`
R_exe="${R_HOME}/bin/R"

## <FIXME>
## Is this still needed?
## Add check profile settings.
## Currently, adehabitat on aragorn.ci.tuwien.ac.at cannot allocate
## enough colors for X11/png with X11colortype "true", argh.
if test -r "${R_profile}"; then
  (echo; cat "${R_profile}") > Rprofile
fi
## </FIXME>

R_base_pkgs=
if test -f src/share/make/vars.mk; then
  R_base_pkgs=`grep '^R_PKGS_BASE *=' src/share/make/vars.mk | \
    sed 's/.*=//'`
fi

## Packages.
rm -rf PKGS			# In case there are some leftovers ...
mkdir PKGS
cd PKGS

all_pkgs=
dir=${CRAN_dir}/${R_VERSION}/Recommended
if test -d ${dir}; then
  for f in ${dir}/*.tar.gz; do tar zxf ${f}; done
  CRAN_vspec_recommended_pkgs=`cd ${dir}; ls *.tar.gz | sed 's/_.*//'`
  all_pkgs="${all_pkgs} ${CRAN_vspec_recommended_pkgs}"
fi
dir=${CRAN_dir}/${R_VERSION}/Other
if test -d ${dir}; then
  for f in ${dir}/*.tar.gz; do tar zxf ${f}; done
  CRAN_vspec_other_pkgs=`cd ${dir}; ls *.tar.gz | sed 's/_.*//'`
  all_pkgs="${all_pkgs} ${CRAN_vspec_other_pkgs}"
fi

CRAN_main_pkgs=`cd ${CRAN_dir}; ls *.tar.gz`
for p in ${R_base_pkgs} \
         ${CRAN_vspec_recommended_pkgs} \
	 ${CRAN_vspec_other_pkgs}; do
  CRAN_main_pkgs=`echo "${CRAN_main_pkgs}" | sed "s/^${p}_.*//"`
done
for p in ${CRAN_main_pkgs}; do tar zxf ${CRAN_dir}/${p}; done
CRAN_main_pkgs=`echo "${CRAN_main_pkgs}" | sed 's/_.*//'`
all_pkgs="${all_pkgs} ${CRAN_main_pkgs}"
all_pkgs=`echo "${all_pkgs}" | tr ' ' '\n' | sort | uniq`

source ${sh_scripts_dir}/check_R_stoplists.sh

## For R 2.0.0 or better, we can compute an install order, but only for
## the CRAN packages in the main area.  This is a *BUG*, and hopefully
## will be fixed soon.  For the time being, the best we can do is to try
## installing the version specific packages first ...
CRAN_vspec_other_pkgs_install_yes=`echo "${CRAN_vspec_other_pkgs}" \
  | egrep -v "${pkgs_install_fake_regexp}" \
  | egrep -v "${pkgs_install_no_regexp}"`
CRAN_main_pkgs_install_yes=`echo "${CRAN_main_pkgs}" \
  | egrep -v "${pkgs_install_fake_regexp}" \
  | egrep -v "${pkgs_install_no_regexp}"`
pkgs_install_yes="${CRAN_vspec_recommended_pkgs} ${CRAN_vspec_other_pkgs_install_yes} ${CRAN_main_pkgs_install_yes}"
pkgs_install_fake=`echo "${all_pkgs}" | egrep "${pkgs_install_fake_regexp}"`
pkgs_install_no=`echo "${all_pkgs}" | egrep "${pkgs_install_no_regexp}"`
## Installation first ...
## Note that installing to the default library tree updates the HTML
## indices, which is very time consuming (as we install one package at a
## time to safeguard against limits on the size of the command line).
## Hence, we install the packages to a different library tree
## (${R_HOME}/Packages).
echo ${pkgs_install_yes} > CRAN_pkgs_ul.dat
${R_exe} --vanilla --slave <<-EOF
	source("${R_scripts_dir}/packages.R")
	dir <- file_path_as_absolute(getwd())
	write_PACKAGES_from_source_dirs(dir)
	avail <- available.packages(contriburl = sprintf("file:///%s", dir))
	pkgs <- scan("CRAN_pkgs_ul.dat", character(), quiet = TRUE)
	pkgs <- pkgs[pkgs %in% rownames(avail)]
	DL <- utils:::.make_dependency_list(pkgs, avail)
	writeLines(utils:::.find_install_order(pkgs, DL), "CRAN_pkgs_ol.dat")
	EOF
pkgs_install_yes=`cat CRAN_pkgs_ol.dat`
for p in ${pkgs_install_yes}; do
  echo -n "${p}: " >> ../time_i.out
  /usr/bin/time -o ../time_i.out -a \
    env R_LIBS="${R_HOME}/Packages" \
      ${R_exe} CMD INSTALL ${p} >${p}-install.out 2>&1
done
## <NOTE>
## Need to actually provide fake installs (otherwise, dependencies
## cannot be honored).  Checking with --install=fake fake-installs
## again, which could perhaps be eliminated.
for p in ${pkgs_install_fake}; do
  echo -n "${p}: " >> ../time_i.out
  /usr/bin/time -o ../time_i.out -a \
    env R_LIBS="${R_HOME}/Packages" \
      ${R_exe} CMD INSTALL --fake ${p} >${p}-install.out 2>&1
done
## </NOTE>

## And now the testing ...
for p in ${pkgs_install_yes}; do
  args=`get_check_args ${p}`
  echo -n "${p}: " >> ../time_c.out
  /usr/bin/time -o ../time_c.out -a \
    env R_LIBS="${R_HOME}/Packages" ${R_exe} CMD check \
    --install="check:${p}-install.out" \
    --library="${R_HOME}/Packages" ${args} ${p}
  if test -n "${args}"; then
    echo "* using check arguments '${args}'" \
      >> ${p}.Rcheck/00check.log
  fi
  rm -f ${p}-install.out
done
for p in ${pkgs_install_fake}; do
  echo -n "${p}: " >> ../time_c.out
  /usr/bin/time -o ../time_c.out -a \
    env R_LIBS="${R_HOME}/Packages" \
      ${R_exe} CMD check --install=fake ${p}
  echo "* using check arguments '--install=fake'" \
    >> ${p}.Rcheck/00check.log
done
for p in ${pkgs_install_no}; do
  echo -n "${p}: " >> ../time_c.out
  /usr/bin/time -o ../time_c.out -a \
    env R_LIBS="${R_HOME}/Packages" \
      ${R_exe} CMD check --install=no ${p}
  echo "* using check arguments '--install=no'" \
    >> ${p}.Rcheck/00check.log
done
## ... and copy the package/bundle DESCRIPTION metadata over to the
## directories with the check results.
for d in *.Rcheck; do
  /usr/bin/install -m 644 `basename ${d} .Rcheck`/DESCRIPTION \
    ${d}/00package.dcf
done

## Summary and check db
get_dcf_field () {
  ## Get one field including all continuation lines from a DCF file.
  ## Usage:
  ##   get_dcf_field FIELD FILE
  ws="[ 	]"		# space and tab
  (sed -n "/^${1}:/,/^[^ ]/{p;}" ${2} | \
    sed -n "/^${1}:/{s/^${1}:${ws}*//;p;}
            /^${ws}/{s/^${ws}*//;p;}") |
    sed "s/[ 	]*$//"
}

## Summaries.

cd ${check_dir}/${R_flavor}

## Save old check results.
for f in ${check_results_files}; do
  test -f "${f}.prev" && rm -f "${f}.prev"
  test -f "${f}"      && mv "${f}" "${f}.prev"
done

for d in Results Results/${check_date}; do
  test -d ${d} || mkdir ${d} || do_cleanup_and_exit 1
done

test -d PKGS.prev && rm -rf PKGS.prev
test -d PKGS      && mv PKGS PKGS.prev
mv Work/PKGS PKGS

## Move timings up.
mv Work/time_c.out time_c.out
mv Work/time_i.out time_i.out

cd ${check_dir}/${R_flavor}/PKGS

## Create check.csv.
(echo "Package,Version,Priority,Maintainer,Status,Comment"
for d in *.Rcheck; do
  package=`basename ${d} .Rcheck`
  version=`get_dcf_field Version ${package}/DESCRIPTION | head -1`
  priority=`get_dcf_field Priority ${package}/DESCRIPTION | head -1`
  maintainer=`get_dcf_field Maintainer ${package}/DESCRIPTION | head -1`  
  warnings=`grep 'WARNING$' ${d}/00check.log`
  errors=`grep 'ERROR' ${d}/00check.log`
  if test -n "${errors}"; then
    status=ERROR
  elif test -n "${warnings}"; then
    status=WARN
  else
    status=OK
  fi
  if echo ${package} | egrep "${pkgs_install_fake_regexp}" >/dev/null; then
    comment="[--install=fake]"
  elif echo ${package} | egrep "${pkgs_install_no_regexp}" >/dev/null; then
    comment="[--install=no]"
  else
    comment=
  fi
  echo "${package},${version},${priority},\"${maintainer}\",${status},${comment}"
done) | sed 's// /' > ../check.csv

## Create SUMMARY.
(for d in *.Rcheck; do
  package=`basename ${d} .Rcheck`
  if test "${R_flavor}" = r-release; then
    problems=`egrep -e 'ERROR$' ${d}/00check.log`
  else
    problems=`egrep -e \
      '(^\*   Rd files|^\*   non-standard|(WARNING|ERROR)$)' \
      ${d}/00check.log`
  fi
  if test -n "${problems}"; then
    echo "${package}"
    egrep -e '^Maintainer:' "${package}/DESCRIPTION"
    echo "${problems}"
  fi
done) > ../SUMMARY

cd ${check_dir}/${R_flavor}

## Create summary.rds.
${R_exe} --vanilla --slave <<-EOF
	source("${R_scripts_dir}/check.R")
	summary <- check_summarize_flavor("${check_dir}", "${R_flavor}")
	.saveRDS(summary, file.path("${check_dir}", "${R_flavor}", "summary.rds"))
	EOF

## Save result summaries. 
for f in ${check_results_files}; do
  cp "${f}" "Results/${check_date}"
done

## And notify of differences ...
for f in check.csv; do
  if test -f "${f}.prev"; then
    diff "${f}.prev" "${f}" > "${f}.diff"
    test -s "${f}.diff" || rm -f "${f}.diff"
  fi
  if test -f "${f}.diff"; then
    ${R_exe} --vanilla --slave <<-EOF
	source("${R_scripts_dir}/check.R")
	db <- check_results_diffs(file.path("${check_dir}", "${R_flavor}"))
	sink("${f}.diff")
	writeLines("Changes in check status (S) and/or version (V):\n")
	print(db)
	sink()
	EOF
    mail -s "[CRAN-check] ${R_flavor}/`hostname` ${f} changes on `date -Iseconds`" \
      ${check_results_mail_recipients} < "${f}.diff"
    rm -f "${f}.diff"
  fi
done

do_cleanup_and_exit
