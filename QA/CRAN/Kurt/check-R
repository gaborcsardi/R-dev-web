#! /bin/sh

## Default flavor to use.
R_flavor=r-devel
## Location of the CRAN packages on the local file system.
CRAN_dir=/usr/local/src/apps/stat/R/src/contrib/
## Where everything happens.
check_dir=~/tmp/R.check
## Check date in ISO 8601 format.  GNU specific ...
check_date=`date -Idate`
check_results_mail_recipients="R-core@R-project.org"
## check_results_mail_recipients="Kurt.Hornik@wu-wien.ac.at"
check_results_files="SUMMARY check.csv summary.rds time.out"
## Compilers to use.
## Note that several packages need g++ 3.0 or better.
## Note also that GCC 3.4 changed the C++ ABI ...
## compilers="CC=gcc-3.4 CXX=g++-3.4 F77=g77-3.4"
## compilers="CC=gcc-4.0 CXX=g++-4.0 F77=gfortran-4.0"
## compilers="CC=gcc CXX=g++ F77=gfortran"
## Use configure defaults (gcc/g++/gfortran).
compilers=
## Additional command line arguments to configure.
configure_args="--with-gnome"
## R scripts directory.
R_scripts_dir=~/lib/R/Scripts
## R profile for checking.
R_profile=~/lib/R/Scripts/check_profile.R

## Command line args.
while test -n "${1}"; do
  case "${1}" in
    -r)
      R_flavor=r-release ;;
    -p)
      R_flavor=r-patched ;;
    -v)
      case "${2}" in
        4.*)
	  compilers="CC=gcc-${2} CXX=g++-${2} F77=gfortran-${2}"
	  ## Temporary workaround for gfortran bug:
	  ## compilers="${compilers} FLIBS=/usr/lib/libgfortran.a"
	  ;;
	3.*)
          compilers="CC=gcc-${2} CXX=g++-${2} F77=g77-${2}"
	  ;;
      esac
      shift ;;
  esac
  shift
done

## Start a virtual framebuffer X server and use this for DISPLAY so that
## we can run package tcltk and friends.  We use the PID of the check
## process as the server number so that the checks for different flavors
## get different servers.
PATH=${PATH}:/usr/bin/X11
Xvfb :${$} &
Xvfb_pid=`ps auxw | grep "Xvfb :${$}" | grep -v grep | awk '{ print $2 }'`
export DISPLAY=:${$}

if test -n "${BASH_VERSION}"; then
  ## No process is allowed more than 10 minutes
  ulimit -t 600
fi

export _R_CHECK_WEAVE_VIGNETTES_=no
export _R_CHECK_SUBDIRS_STRICT_=yes

do_cleanup_and_exit () {
  kill -9 ${Xvfb_pid}
  exit ${1-0}
}

test -d ${check_dir} || mkdir ${check_dir} || do_cleanup_and_exit 1
cd ${check_dir}

## Structure inside $check_dir: subdirs for each flavor.  Within these,
## R sources are in 'src', R is built in 'build', packages are in
## 'PKGS', and results are saved in 'Results'.
test -d ${R_flavor} || mkdir ${R_flavor} || do_cleanup_and_exit 1
cd ${R_flavor}

## Save old check results.
for f in ${check_results_files}; do
  test -f "${f}.prev" && rm -f "${f}.prev"
  test -f "${f}"      && mv "${f}" "${f}.prev"
done

for d in Results Results/${check_date}; do
  test -d ${d} || mkdir ${d} || do_cleanup_and_exit 1
done

## Update ${R_flavor} sources.
## Actually, we should check whether flavor of source and target agree.
test -d src || mkdir src || do_cleanup_and_exit 1
if test "`hostname`" = mithrandir; then
  (cd ~/src/apps/R/${R_flavor}/R; tar cf - . ) | ( cd src; tar xf -)
else
  ## Argh, rsync is gone (at least for the time being ...).
  ## We could of course use svn checkout on https://svn.R-project.org/R,
  ## but how can one get "r-patched" and "r-release" without knowing the
  ## corresponding branch?  Hence, we get things from CRAN (release) or
  ## ETHZ, but need to figure out the top-level source dir for the
  ## unpackaged version somehow (of course, we could also read this from
  ## the archive).
  ## (cd src; rsync -rC -t --delete rsync.r-project.org::${R_flavor} .)
  ## <FIXME>
  ## Shouldn't we use svn checkout for r-devel?
  ## </FIXME>
  case "${R_flavor}" in
    r-devel)
      url=ftp://ftp.stat.math.ethz.ch/Software/R/R-devel.tar.gz ;;
    r-patched)
      url=ftp://ftp.stat.math.ethz.ch/Software/R/R-patched.tar.gz ;;
    r-release)
      url=http://cran.r-project.org/src/base/R-latest.tar.gz ;;
  esac
  mv src src.save
  (mkdir tmp &&
    cd tmp &&
    touch stamp &&
    wget -O - --retr-symlinks ${url} | tar zxmf - &&
    entry=`find . -newer stamp -type d -mindepth 1 -maxdepth 1` &&
    mv ${entry} ../src &&
    cd .. &&
    rm -rf src.save tmp) || (rm -rf tmp; mv src.save src)
fi
R_VERSION=`cut -f1 -d' ' src/VERSION`
if test "`cut -f2 -d' ' src/VERSION`" = "Patched"; then
  R_VERSION=`echo ${R_VERSION} | sed 's/\.[0-9]*$//'`
  R_VERSION="${R_VERSION}-patched"
fi

## Update package sources.  Could make this much smarter but we need to
## make sure that there are no left-overs in case of updates.
if hostname -d | grep -q wu-wien.ac.at; then
  (cd /usr/local/src/apps/stat/R/contrib; \
    rsync -t -v --delete -r -l --safe-links \
      cran.wu-wien.ac.at::CRAN/src/contrib/ .)
fi

## Link recommended packages.
(cd src; \
  CRAN_RSYNC="/usr/local/src/apps/stat/R" ./tools/rsync-recommended)

## Rebuild R.
rm -rf build
mkdir build
(cd build && ../src/configure ${configure_args} ${compilers} \
  && make && make check) || do_cleanup_and_exit 1
mkdir build/Packages
R_HOME=`./build/bin/R RHOME`

## Add check profile settings.
## Currently, adehabitat on aragorn.ci.tuwien.ac.at cannot allocate
## enough colors for X11/png with X11colortype "true", argh.
if test -r "${R_profile}"; then
  (echo; cat "${R_profile}") > Rprofile
fi

R_base_pkgs=
if test -f src/share/make/vars.mk; then
  R_base_pkgs=`grep '^R_PKGS_BASE *=' src/share/make/vars.mk | \
    sed 's/.*=//'`
fi

## Packages.
test -d PKGS.bak  && rm -rf PKGS.bak
test -d PKGS      && mv PKGS     PKGS.bak
mkdir PKGS
cd PKGS

all_pkgs=
dir=${CRAN_dir}/${R_VERSION}/Recommended
if test -d ${dir}; then
  for f in ${dir}/*.tar.gz; do tar zxf ${f}; done
  CRAN_vspec_recommended_pkgs=`cd ${dir}; ls *.tar.gz | sed 's/_.*//'`
  all_pkgs="${all_pkgs} ${CRAN_vspec_recommended_pkgs}"
fi
dir=${CRAN_dir}/${R_VERSION}/Other
if test -d ${dir}; then
  for f in ${dir}/*.tar.gz; do tar zxf ${f}; done
  CRAN_vspec_other_pkgs=`cd ${dir}; ls *.tar.gz | sed 's/_.*//'`
  all_pkgs="${all_pkgs} ${CRAN_vspec_other_pkgs}"
fi

CRAN_main_pkgs=`cd ${CRAN_dir}; ls *.tar.gz`
for p in ${R_base_pkgs} \
         ${CRAN_vspec_recommended_pkgs} \
	 ${CRAN_vspec_other_pkgs}; do
  CRAN_main_pkgs=`echo "${CRAN_main_pkgs}" | sed "s/^${p}_.*//"`
done
for p in ${CRAN_main_pkgs}; do tar zxf ${CRAN_dir}/${p}; done
CRAN_main_pkgs=`echo "${CRAN_main_pkgs}" | sed 's/_.*//'`
all_pkgs="${all_pkgs} ${CRAN_main_pkgs}"
all_pkgs=`echo "${all_pkgs}" | tr ' ' '\n' | sort | uniq`

## We know that we cannot "really" install some of the packages ...
## In addition, we try not to run code in packages which call lamboot
## (Rmpi, RScaLAPACK) to something similar (rpvm?).
## We currently use '--install=fake' for these.
## Finally, checking some of the packages (CoCo, dse, ...) takes too
## long.
pkgs_install_fake_cannot_run="BRugs|ROracle|RmSQL|Rmpi|RScaLAPACK|RWinEdt|Rlsf|gamlss.nl|gamlss.tr|httpRequest|mimR|rcdd|rcom|rpvm|snowFT|spectrino|svmpath|taskPR"
## Reasons:
## * gamlss.nl depends on gamlss.
## * gamlss.tr depends on gamlss.
## * mimR depends on rcom.
## * spectrino depends on rcom.
## * svmpath takes too long.
pkgs_install_fake_too_long="MarkedPointProcess|aod|arules|dprep|gamlss|hoa|mlmRev|tgp|twang"
## Used to have 
##   pkgs_install_fake_too_long="dse|spatstat|mclust|sn|prabclus|multinomRob"
## (when we ran daily checks on all three flavors of R).
pkgs_install_fake_regexp="^(${pkgs_install_fake_cannot_run}|${pkgs_install_fake_too_long})\$"
## (Note that this needs adjustment in case one of the individual
## regexps becomes empty.)
## Also, packages may depend on packages not in CRAN (e.g., in BioC or
## CRAN/Devel).  For such packages, we really have to use
## '--install=no'.  (A fake install still assumes that top-level
## require() calls can be honored.)
pkgs_install_no_regexp='^(CVThresh|CoCo|DDHFm|DescribeDisplay|GeneNT|GeneTS|LMGene|RBloomberg|RGrace|SciViews|VDCutil|Zelig|accuracy|boolean|caMassClass|caTools|ggplot|limma|lsa|tcltk2)$'
## Reasons:
## (Note that packages with non-CRAN Suggests could "fully" be tested
## with _R_CHECK_FORCE_SUGGESTS_=FALSE.)
## * CVTresh depends on wavethresh4 (@Nason's home page).
## * CoCo takes "too long", but fails with --install=fake (at least on
##   when R CMD check is run from cron, as for the daily checking).
## * DDHFm suggests vsn (@BioC).
## * DescribeDisplay depends on ggplot.
## * GeneNT depends on GeneTS.
## * GeneTS suggests graph (@BioC).
## * LMGene depends on Biobase (@BioC).
## * RBloomberg depends on RDCOMClient (@Omegahat).
## * RGrace depends on RGtk (@Omegahat).
## * SciViews/svWidgets suggests tcltk2.
## * VDCutil depends on Zelig.
## * Zelig suggests VGAM ("nowhere").
## * accuracy suggests Zelig.
## * boolean suggests Zelig.
## * caMassClass depends on PROcess (@BioC).
## * caTools suggests ROC (@BioC).
## * ggplot suggests hexbin (@BioC)
## * limma suggests vsn (@BioC).
## * lsa depends on Rstem (@Omegahat).
## * tcltk2 only works on Windows.

## Also note that there are packages with examples/tests/vignettes
## taking so long that it makes the whole process take more than a day.
## Should really have separate lists for these ...

## For R 2.0.0 or better, we can compute an install order, but only for
## the CRAN packages in the main area.  This is a *BUG*, and hopefully
## will be fixed soon.  For the time being, the best we can do is to try
## installing the version specific packages first ...
CRAN_vspec_other_pkgs_install_yes=`echo "${CRAN_vspec_other_pkgs}" \
  | egrep -v "${pkgs_install_fake_regexp}" \
  | egrep -v "${pkgs_install_no_regexp}"`
CRAN_main_pkgs_install_yes=`echo "${CRAN_main_pkgs}" \
  | egrep -v "${pkgs_install_fake_regexp}" \
  | egrep -v "${pkgs_install_no_regexp}"`
pkgs_install_yes="${CRAN_vspec_recommended_pkgs} ${CRAN_vspec_other_pkgs_install_yes} ${CRAN_main_pkgs_install_yes}"
pkgs_install_fake=`echo "${all_pkgs}" | egrep "${pkgs_install_fake_regexp}"`
pkgs_install_no=`echo "${all_pkgs}" | egrep "${pkgs_install_no_regexp}"`
## Installation first ...
## Note that installing to the default library tree updates the HTML
## indices, which is very time consuming (as we install one package at a
## time to safeguard against limits on the size of the command line).
## Hence, we install the packages to a different library tree
## (${R_HOME}/Packages).
## <FIXME>
## Add timing installation along the lines of timing checking.
## </FIXME>
for p in ${CRAN_vspec_recommended_pkgs}; do
  R_LIBS="${R_HOME}/Packages" \
    ../build/bin/R CMD INSTALL ${p} >${p}-install.out 2>&1
done
## Use '--no-lazy' for R 2.0.0 or later, as otherwise we force
## dependencies at install time (and cannot [easily] compute them, see
## above).
for p in ${CRAN_vspec_other_pkgs_install_yes}; do
  R_LIBS="${R_HOME}/Packages" \
    ../build/bin/R CMD INSTALL --no-lazy ${p} >${p}-install.out 2>&1
done
echo ${CRAN_main_pkgs_install_yes} > CRAN_pkgs.dat
../build/bin/R --vanilla --slave <<-EOF
	avail <- available.packages(contriburl = "file:///${CRAN_dir}")
	pkgs <- scan("CRAN_pkgs.dat", character(), quiet = TRUE)
	DL <- utils:::.make_dependency_list(pkgs, avail)
	writeLines(utils:::.find_install_order(pkgs, DL), "CRAN_pkgs.dat")
	EOF
CRAN_main_pkgs_install_yes=`cat CRAN_pkgs.dat`
for p in ${CRAN_main_pkgs_install_yes}; do
  R_LIBS="${R_HOME}/Packages" \
     ../build/bin/R CMD INSTALL ${p} >${p}-install.out 2>&1
done
## <NOTE>
## Need to actually provide fake installs (otherwise, dependencies
## cannot be honored).  Checking with --install=fake fake-installs
## again, which could perhaps be eliminated.
for p in ${pkgs_install_fake}; do
  R_LIBS="${R_HOME}/Packages" \
    ../build/bin/R CMD INSTALL --fake ${p} >${p}-install.out 2>&1
done
## </NOTE>

## And now the testing ...
for p in ${pkgs_install_yes}; do
  echo -n "${p}: " >> ../time.out
  /usr/bin/time -o ../time.out -a \
    env R_LIBS="${R_HOME}/Packages" ../build/bin/R CMD check \
    --install="check:${p}-install.out" \
    --library="${R_HOME}/Packages" ${p}
  rm -f ${p}-install.out
done
for p in ${pkgs_install_fake}; do
  echo -n "${p}: " >> ../time.out
  /usr/bin/time -o ../time.out -a \
    env R_LIBS="${R_HOME}/Packages" \
      ../build/bin/R CMD check --install=fake ${p}
done
for p in ${pkgs_install_no}; do
  echo -n "${p}: " >> ../time.out
  /usr/bin/time -o ../time.out -a \
    env R_LIBS="${R_HOME}/Packages" \
      ../build/bin/R CMD check --install=no ${p}
done

## Summary and check db
get_dcf_field () {
  ## Get one field including all continuation lines from a DCF file.
  ## Usage:
  ##   get_dcf_field FIELD FILE
  ws="[ 	]"		# space and tab
  (sed -n "/^${1}:/,/^[^ ]/{p;}" ${2} | \
    sed -n "/^${1}:/{s/^${1}:${ws}*//;p;}
            /^${ws}/{s/^${ws}*//;p;}") |
    sed "s/[ 	]*$//"
}

(echo "Package,Version,Priority,Maintainer,Status,Comment"
for d in *.Rcheck; do
  package=`basename ${d} .Rcheck`
  version=`get_dcf_field Version ${package}/DESCRIPTION | head -1`
  priority=`get_dcf_field Priority ${package}/DESCRIPTION | head -1`
  maintainer=`get_dcf_field Maintainer ${package}/DESCRIPTION | head -1`
  warnings=`grep 'WARNING$' ${d}/00check.log`
  errors=`grep 'ERROR' ${d}/00check.log`
  if test -n "${errors}"; then
    status=ERROR
  elif test -n "${warnings}"; then
    status=WARN
  else
    status=OK
  fi
  if echo ${package} | egrep "${pkgs_install_fake_regexp}" >/dev/null; then
    comment="[--install=fake]"
  elif echo ${package} | egrep "${pkgs_install_no_regexp}" >/dev/null; then
    comment="[--install=no]"
  else
    comment=
  fi
  echo "${package},${version},${priority},\"${maintainer}\",${status},${comment}"
done) | sed 's// /' > ../check.csv
    
(for d in *.Rcheck; do
  package=`basename ${d} .Rcheck`
  if test "${R_flavor}" = r-release; then
    problems=`egrep -e 'ERROR$' ${d}/00check.log`
  else
    problems=`egrep -e \
      '(^\*   Rd files|^\*   non-standard|(WARNING|ERROR)$)' \
      ${d}/00check.log`
  fi
  if test -n "${problems}"; then
    echo "${package}"
    egrep -e '^Maintainer:' "${package}/DESCRIPTION"
    echo "${problems}"
  fi
done) > ../SUMMARY

cd ..				# Back in ${check_dir}/${R_flavor} now.

./build/bin/R --vanilla --slave <<EOF
  source("${R_scripts_dir}/check.R")
  check_summarize_flavor("${check_dir}", "${R_flavor}")
EOF
 
for f in ${check_results_files}; do
  cp "${f}" "Results/${check_date}"
done

for f in ${check_results_files}; do
  case "${f}" in
    summary.rds|time.out) continue ;;
  esac
  if test -f "${f}.prev"; then
    diff "${f}.prev" "${f}" > "${f}.diff"
    test -s "${f}.diff" || rm -f "${f}.diff"
  fi
  if test -f "${f}.diff"; then
    mail -s "${R_flavor} ${f} changes for `hostname` on `date`" \
      ${check_results_mail_recipients} < "${f}.diff"
    rm -f "${f}.diff"
  else
    mail -s "${R_flavor} ${f} status for `hostname` on `date`" \
      ${check_results_mail_recipients} < "${f}"
  fi
done

do_cleanup_and_exit
