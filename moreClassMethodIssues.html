<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<link REL=stylesheet HREF=Rtech.css>
<title>More Issues about Formal Classes and Methods</title>
</head>

<body>
<h1>More Issues about Formal Classes and Methods</h1>

These are some miscellaneous points on which we (the community
interested in extending programming in the S language) may want to
reach some consensus.  Some apply only to the R implementation; others
more generally.

<h2>Documenting Methods and Classes</h2>
<p>
The chapter in the ``green book'' (<i>Programming with Data</i>;
Springer, 1998) on documentation assumes S documentation objects and
SGML-based documentation; until some further work is done, this
is not directly usable.
<p>
The current implementation of special documentation in R is based on a
mapping from type-topic pairs into a single string, the value of
<code><pre>
   topicName(type, topic)
</pre></code>
This corresponds to the binary version of the <code>?</code> operator
(<i>Programming with Data</i>, page 358):
<code><pre>
   class ? track
</pre></code>
looks for topic <code>topicName(class, track)</code>.  At the moment
the actual topic would be <code>"track-class"</code>.  The string
convention is used in two places:
<ol>
  <li> as the name to go into a <code>\alias</code> entry; and
  <li> in the (default) name of the file where the documentation is written;
      e.g., <code>"track-class.Rd"</code>
</ol>
The choice of <code>"_"</code> as the separator is based on the notion
that it's unlikely to be part of a class or method name and is valid
as part of a file name, on Unix/Linux and Windows at least.
<p>
The planned sequence for generating class and method documentation,
using the current Rd format, is similar to that for functions.
The programmer implements a class or some methods for a function, and
then creates a shell of the documentation by the corresponding prompt
function:
<code><pre>
    promptClass("track")
    promptMethods("plot")
</pre></code>
The output of these would currently go to files
<code>"track-class.Rd"</code> and <code>"plot-methods.Rd"</code>
respectively.
<p>
The current documentation for both classes and methods conforms to the
existing Rd format.  In particular, the special sections, such as that
for documenting slots of a class, are handled by the standard
<code>\section</code> command.  Eventually, it would be better to have
documentation files specialized to classes and methods, allowing
easier checks of the documentation against the currently defined
objects.
Having specialized documentation would improve the prompt functions as
well, since they currently have much too specific an idea of how the
documentation is to be rendered.
But good specialized documentation really requires the much-desired change in the
overall documentation strategy to XML or other.
<p>
Another issue for consideration is the <i>organization</i> of class
and method documentation in relation to an overall project.
The general notion behind current software (e.g.,
<code>promptMethods</code>) is that the programmer may want either to
document a function and its methods together, or to document
separately some additional methods.
<p>
If I own a package that contains the definition of a function, say
<code>plotData</code>, along with some methods for that function, I
may want to document function and methods together.  If you then
define another package that requires mine and in that package add some
more methods for <code>plotData</code>, the likely scenario is that
you will document your methods separately, with a link to my
documentation of the function itself.
None of this is enforced, but the <code>addTo</code> argument to
<code>promptMethods</code> is designed to set up either version.
<p>
On the other hand, <code>promptClass</code> also generates a list of
the locally-defined methods involving the class.  If I followed the
design style above, I would likely put a link to the
documentation of the corresponding function into the entries in the
class documentation.  Again, nothing is enforced, and it should be
possible to have the other philosophy:  put the method documentation
into the relevant class documentation file.  Philosophically, this is
more an OOP approach than a function-based approach.


<h2>Representation of Objects and Slots for Formal Classes</h2><a name="#Envir"></a>
<p>
This is essentially a request for a new type of object in R (unless
there is a solution within the current implementation not so far uncovered).
<p>
An important subset of formal classes either extend one of
the basic vector types, such as <code>"character"</code>, or
extend the notion of a <code>structure</code> in S (as would, for
example, a formal definition of matrix or time-series as a class).
For these classes, one would like to inherit much of the behavior of
S3 for vectors and structures.
The present implementation satisfies this fairly well, as far as
current experience has tested.
The prototype of objects in these classes is an object of one of the
``basic classes''.
Most existing non-class-based code for such objects should continue to
work for classes that extend basic classes.
<p>
Other formal classes are defined only in terms of their slots, and they
should not behave like vectors, unless the designer of the class
defines appropriate methods.
Nothing in the class definition says that objects from such classes
should inherit primitive functions for subsetting, arithmetic, etc.
<p>
The API concepts corresponding to this are fairly simple:
<p>
<ol>
  <li> If the class extends one of the basic vector classes, it
      inherits methods for arithmetic, subsetting, and other relevant
      functions from that basic class.
<p>
  <li> If the class extends class
      <code>vector</code> or class <code>structure</code>, it likewise
      should have methods pre-defined for the vector-like operations.
      <p>
      (There are a couple of issues here about what happens with
      S3-like class/attribute structures.  The behavior is mostly, but
      perhaps not entirely, what we would want.  It may be that the
      case of a formally defined class will need to be detected in the
      current base implementation and dealt with specially.  But this
      seems likely to be fairly easy.)
<p>
  <li> If the class does not extend <code>vector</code> directly or
      indirectly, it should <i>not</i> permit vector-like operations
      unless these are given explicit definitions.
</ol>
<p>
The current implementation of the methods package does not implement
the last item.  Vector operations return results (generally meaningless) if applied
to non-vector classes.
The reason is that the prototype object from the class is a vector
(specifically, an empty list).
<p>
What one would like is an object for which all vector-like operations
are <i>generally</i> undefined.
For example, if <code>t1</code> is an
object from some non-vector class, for which no subsetting methods are
defined, an error should result in situations like:
<code><pre>
    t1[[1]]
    Error in t1[[1]] : object is not subsettable
</pre></code>
In the current implementation, the operation falls through to an
operation on an empty list, which may or may not fail.
<p>
There are non-vector data types in R, but it appears that none of them
are suitable as a prototype.
The two candidates that might be plausible are
<code>environment</code> and <code>closure</code>.  But environments
are references and do not get duplicated.  So ordinary assignment,
<code><pre>
  y <- x
</pre></code>
will not work according to S semantics.  Changes to <code>y</code>
will be reflected in <code>x</code>.
Closures are partially duplicated, but attempts to use them as
prototypes so far seem to fail (in less obvious ways).  In addition,
they are only partially non-vectors:  subsetting fails but
<code>length</code> does not.
<p>


<h2>Tightening up the Object/Class Model</h2>

In the initial implementation, the objects representing classes (with
class <code>"classRepEnvironment"</code> did not themselves come from
a formally defined class; instead, properties in these objects were
dealt with in a special way.
<p>
It is fairly obvious that the model for a language should apply as
uniformly as possible.  Exceptions tend to be made for efficiency of
basic computations, for better or worse, but otherwise we would like
as few special cases as possible.
Such uniformity applies particularly for an implementation of the S
language, in which much of the computation on the language can be done
in the language itself.
<p>
The revision in the <a href="#Envir">previous section</a> makes it
possible to implement class objects as a true class.  Aside from the
philosophical desirability, having a true class opens up the
possibility of extending that class later on.  The bootstrap process
for generating the methods package also simplifies substantially:  we
basically just need to create the initial definition of the ``class
class'' and other computations are largely within the model.

<h2>Methods and Conforming Argument Lists</h2>

As discussed  recently on the r-devel list, there are cases where it
would be useful to allow methods defined on a subset of the arguments
of the generic (chiefly for subsetting operators).
<p>
The first step in implementing this is simple, given the general
model.  A method is allowed if its argument list <i>conforms</i> to
the arguments of the generic in the following sense:
<blockquote>
A method conforms to its generic function if the formal arguments of
the method are a subset of those in the generic, appearing in the same
order, and if the omitted arguments in the method do not appear in the
signature associated with the method.  In this case, the signature
method is treated as if it were augmented by class
<code>"missing"</code> for each of the omitted arguments.
</blockquote>
Note that with this definition, the extension to conforming arguments only affects method
specification, not method dispatch.
<p>
The plan is to modify the rule for setting methods so that conforming,
but not identical argument lists are allowed (there will probably
continue to be a message noting the extended interpretation of the
signature).  Non-conforming method definitions will likely become
errors, rather than the current warning (but this should get some
discussion).


<hr>
<address><a href="http://cm.bell-labs.com/cm/ms/departments/sia/jmc/">John Chambers</a><a href=mailto:jmc@research.bell-labs.com>&lt;jmc@research.bell-labs.com&gt;</a></address>
<!-- hhmts start -->
Last modified: Sun Dec 16 17:19:39 EST 2001
<!-- hhmts end -->
</body> </html>
