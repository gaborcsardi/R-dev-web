<h1 id="howto-utf-8-as-native-encoding-in-r-on-windows">Howto: UTF-8 as native encoding in R on Windows</h1>
<p>For UTF-8 as native encoding on Windows, we need a new compiler toolchain using UCRT as C runtime and we have to rebuild all native code with it: R, packages with native code and libraries used by those. Some of that code needs patching (for UCRT, for newer toolchain, newer libraries, etc).</p>
<p>We also need to adapt our code to work with multi-byte encodings where it may previously have expected single-byte or double-byte encodings. Sooner we find about these problems and fix them, sooner we can enjoy UTF-8 in R on Windows.</p>
<p>Regular CRAN checks (“additional checks” of kind “gcc10-UCRT”) are being run using the experimental toolchain described here.</p>
<p>This document describes how to obtain an experimental build of R for Windows with UTF-8 as the current native encoding, how to install packages, how to update packages to work with the toolchain, and additional advanced issues.</p>
<h2 id="binary-installer-of-r-binary-packages">Binary installer of R, binary packages</h2>
<p>One needs recent Windows 10 (May 2019 Update or newer). The binary installer of R is available <a href="https://www.r-project.org/nosvn/winutf8/ucrt3/">here</a> in a file named such as <code>R-devel-win-79604-4354-4361.exe</code>. Make sure that this version of R-devel gets its own library of R packages because it is not possible to share the library with a usual build of R-devel. Only 64-bit version is available.</p>
<p>To check UTF-8 is used as native encoding, run</p>
<pre><code>&gt; l10n_info()
$MBCS
[1] TRUE

$`UTF-8`
[1] TRUE

$`Latin-1`
[1] FALSE

$codepage
[1] 65001

$system.codepage
[1] 65001</code></pre>
<p>Both “codepage” and “system.codepage” must be 65001. When running RTerm (so also R.exe) from the command line, make sure to set up this code page and select a font with a wide set of glyphs. In cmd.exe, use <code>chcp 65001</code> and select e.g. <code>NSimFun</code> before running R.</p>
<p>R is patched to install binary packages built with UCRT. Most of CRAN and several of their BIOC dependencies are available at this point and some of them are patched. For example, try on <code>PKI</code>, which is patched.</p>
<h2 id="installation-of-external-software-for-building-from-source">Installation of external software for building from source</h2>
<p>To build R from source, one needs Msys2 (with packages <code>unzip diffutils make winpty rsync texinfo tar texinfo-tex zip subversion bison moreutils xz patch</code>), MikTeX (with basic packages and <code>inconsolata</code>), and Inno Setup. Inno Setup is only needed for building R installer, not R packages.</p>
<p>For automated installation (ideal for fresh Windows installs e.g. in a virtual machine or a container):</p>
<pre><code>cd \
Invoke-WebRequest -Uri https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/r/setup.ps1 -OutFile setup.ps1 -UseBasicParsing
PowerShell -ExecutionPolicy Bypass -File setup.ps1</code></pre>
<p>On a machine used for anything else, better use the script only as a guide and apply the individual steps manually to avoid damage to your installation. One may also want to clean up after the script (<code>temp</code> can be deleted).</p>
<h2 id="binary-installer-of-r-building-packages-from-source">Binary installer of R, building packages from source</h2>
<p>Install R from the binary installer and the external software as described above.</p>
<p>Download and unpack the gcc10 toolchain and pre-built libraries, set environment variables, and then run R. The toolchain and libraries are available in a single tarball <a href="https://www.r-project.org/nosvn/winutf8/ucrt3/">here</a>, a file named such as <code>gcc10_ucrt3_4354.txz</code>.</p>
<p>Run an msys2 shell <code>C:\msys64\msys2.exe</code> and these commands, updating the current name of the toolchain archive file:</p>
<pre><code>mkdir ucrt3
cd ucrt3
wget https://www.r-project.org/nosvn/winutf8/ucrt3/gcc10_ucrt3_4354.txz
tar xf gcc10_ucrt3_4354.txz

export PATH=`pwd`/x86_64-w64-mingw32.static.posix/bin:$PATH
export PATH=`pwd`/x86_64-w64-mingw32.static.posix/libexec/gcc/x86_64-w64-mingw32.static.posix/10.2.0:$PATH
export PATH=/c/Program\ Files/MiKTeX/miktex/bin/x64:$PATH
export TAR=&quot;/usr/bin/tar --force-local&quot;</code></pre>
<p>Better check the paths are set properly by running</p>
<pre><code>which cc1 gcc pdflatex</code></pre>
<p>which should find the tools, e.g.</p>
<pre><code>/home/tomas/ucrt3/x86_64-w64-mingw32.static.posix/libexec/gcc/x86_64-w64-mingw32.static.posix/10.2.0/cc1
/home/tomas/ucrt3/x86_64-w64-mingw32.static.posix/bin/gcc
/c/Program Files/MiKTeX/miktex/bin/x64/pdflatex</code></pre>
<p>Now run R from the same terminal by <code>/c/Program\ Files/R/R-devel/bin/R</code>. Try installing “PKI”: <code>install.packages("PKI", type="source")</code>.</p>
<p>This will build from source <code>PKI</code> and its dependency <code>base64enc</code>. A patch for <code>PKI</code> to build with UCRT will be downloaded and applied automatically.</p>
<p>Examples in this documents use Msys2 with mintty and bash, which is the default with Msys2 and is perhaps easier to use with building/testing for those familiar with Unix. One can, however, also use cmd.exe, with the benefit of nicer fonts and more reliable line editing (mintty uses a different interface to communicate with RTerm).</p>
<h2 id="building-r-from-source">Building R from source</h2>
<p>Do all the steps as above except installing R from the installer.</p>
<p>Download and unpack Tcl/Tk bundle from <a href="https://www.r-project.org/nosvn/winutf8/ucrt3/">here</a>, a file currently named <code>Tcl.zip</code>. Download R sources. Download and apply patches for R. Do this in the msys2 shell with the settings from above</p>
<pre><code>wget https://www.r-project.org/nosvn/winutf8/ucrt3/Tcl.zip

svn checkout https://svn.r-project.org/R/trunk

wget https://www.r-project.org/nosvn/winutf8/ucrt3/R-devel-79604-4354.diff

cd trunk
patch -p0 &lt; ../R-devel-79604-4354.diff

unzip ../Tcl.zip</code></pre>
<p>Prepare <code>MkRules.local</code>, download recommended packages, and build R:</p>
<pre><code>cd src/gnuwin32

cat &lt;&lt;EOF &gt;MkRules.local
LOCAL_SOFT = `pwd`/../../../x86_64-w64-mingw32.static.posix
WIN = 64
BINPREF64 =
BINPREF =
USE_ICU = YES
ICU_LIBS = -lsicuin -lsicuuc \$(LOCAL_SOFT)/lib/sicudt.a -lstdc++
USE_LIBCURL = YES
CURL_LIBS = -lcurl -lzstd -lrtmp -lssl -lssh2 -lgcrypt -lcrypto -lgdi32 -lz -lws2_32 -lgdi32 -lcrypt32 -lidn2 -lunistring -liconv -lgpg-error -lwldap32 -lwinmm
USE_CAIRO = YES
CAIRO_LIBS = &quot;-lcairo -lfontconfig -lfreetype -lpng -lpixman-1 -lexpat -lharfbuzz -lbz2 -lintl -lz -liconv -lgdi32 -lmsimg32&quot;
CAIRO_CPPFLAGS = &quot;-I\$(LOCAL_SOFT)/include/cairo&quot;
TEXI2ANY = texi2any
MAKEINFO = texi2any
ISDIR = C:/Program Files (x86)/InnoSetup
EOF

make rsync-recommended
make all recommended</code></pre>
<p>When the build succeeds, one can run R via <code>../../bin/R</code>.</p>
<p>To build the installer, run <code>make distribution</code>, it will appear in <code>installer/R-devel-win.exe</code>. To build R with debug symbols, set <code>export DEBUG=T</code> in the terminal before the build (and possibly add `EOPTS = -O0" to MkRules.local to disable compiler optimizations, hence obtaining reliable debug information).</p>
<h2 id="updating-r-packages">Updating R packages</h2>
<p>R packages with only R code should work without any modification. R packages with native code (C, Fortran, C++) but without any dependencies on external libraries may work right away as well. Other packages will typically need some work.</p>
<h3 id="linking-to-pre-built-static-libraries">Linking to pre-built static libraries</h3>
<p>Some R packages tend to download external static libraries during their installation from “winlibs” or other sources. Such libraries are, however, as of this writing built against MSVCRT and hence cannot work with UCRT.</p>
<p>A common symptom is that one gets error messages about undefined references also to <code>__imp___iob_func</code>, <code>__ms_vsnprintf</code> or <code>_setjmp</code>, but downloading of external code is usually obvious from <code>src/Makevars.win</code> (e.g. presence of “winlibs” or from <code>configure.win</code>).</p>
<p>To fix this, one needs to instead build against libraries built for UCRT. A number of these libraries are available with the toolchain. For example, package <code>tiff</code> as of this writing has in <code>src/Makevars.win</code>:</p>
<pre><code>RWINLIB = ../windows/libtiff-4.1.0/mingw$(WIN)
PKG_CPPFLAGS = -I$(RWINLIB)/include
PKG_LIBS = -L$(RWINLIB)/lib -ltiff -ljpeg -lz

all: clean winlibs

winlibs:
        &quot;${R_HOME}/bin${R_ARCH_BIN}/Rscript.exe&quot; &quot;../tools/winlibs.R&quot;</code></pre>
<p>To make the package build with UCRT and the experimental toolchain, one can replace these lines by:</p>
<pre><code>PKG_LIBS = -ltiff -ljpeg -lz -lzstd -lwebp -llzma 
all: clean 
</code></pre>
<p>Note that even Rtools4 has these libraries, so one could make a similar change also for building the package with Rtools4. That may be preferred for transparency, etc, but typically Rtools4 will need a different set of libraries from this UCRT toolchain, and there are additional differences in preprocessor flags, etc.</p>
<h3 id="creating-a-package-patch">Creating a package patch</h3>
<p>This experimental build of R automatically downloads and applies patches to packages from <a href="https://www.r-project.org/nosvn/winutf8/ucrt3/patches">here</a>, so <a href="https://www.r-project.org/nosvn/winutf8/ucrt3/patches/CRAN/tiff.diff">tiff.diff</a> is a patch for the tiff package discussed above.</p>
<p>To create such a patch, get and unpack the sources</p>
<pre><code>wget https://cran.r-project.org/src/contrib/tiff_0.1-6.tar.gz
mkdir original patched
cd original
tar xfz ../tiff_0.1-6.tar.gz
cd ../patched
tar xfz ../tiff_0.1-6.tar.gz</code></pre>
<p>If updating an existing patch, apply it first:</p>
<pre><code>cd patched
wget https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/r_packages/patches/CRAN/tiff.diff
patch -p1 &lt;tiff.diff</code></pre>
<p>now you may edit any source file in the package, e.g.  <code>patched/tiff/src/Makevars.win</code> as shown above. However, specifically for the case of <code>Makevars</code> (and <code>Makefile</code>) files, it is preferred to created a copy with <code>.ucrt</code> extensions instead of <code>.win</code>. <code>Makevars.ucrt</code> (<code>Makefile.ucrt</code>) will take precedence over <code>Makevars.win</code> (<code>Makefile.win</code>) in this experimental build of R.</p>
<p>Test the package:</p>
<pre><code>env _R_INSTALL_TIME_PATCHES_=no R CMD build patched/tiff # possibly with --no-build-vignettes
env _R_INSTALL_TIME_PATCHES_=no R CMD INSTALL tiff_0.1-6.tar.gz
env _R_INSTALL_TIME_PATCHES_=no R CMD check tiff_0.1-6.tar.gz</code></pre>
<p>The setting of <code>_R_INSTALL_TIME_PATCHES_=no</code> above ensures that R will not attempt to patch automatically the package using a possibly present earlier patch, but will build/install/check exactly the tarball given.</p>
<p>And when done with testing, create the patch using</p>
<pre><code>diff -Nru original/tiff patched/tiff &gt; tiff.diff</code></pre>
<p>Note the ‘N’ which ensures new files (e.g. <code>Makevars.ucrt</code>) are added to the patch.</p>
<p>One may instruct R to download patches, instead, from a local directory. To do so, download first the current patches from <a href="https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/r_packages/patches/">here</a>, update them as needed, then run script <a href="https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/r_packages/build_patches_idx.r">build_patches_idx.r</a> to build patch index <code>patches_idx.rds</code>, and then tell R via environment variable <code>_R_INSTALL_TIME_PATCHES_</code> about the directory where this index is.</p>
<p>This automated installation-time patching is only intended as convenience for testing with this experimental toolchain and is likely to be removed in the future; it is not intended for an R release. Therefore, if you are a package maintainer and want your package to work with UCRT, please update your source code accordingly, e.g. via adding <code>Makevars.ucrt</code> files. Feel free to re-use/copy from the patches provided for your packages, and feel free then to ask for the patches to be removed from the central repository.</p>
<h3 id="multiple-definitions-of-symbols">Multiple definitions of symbols</h3>
<p>Another common issue observed with the new toolchain are linker errors about multiply defined symbols. This may be because GCC 10 is stricter about the use of tentative definitions (global variables defined without an initializer) than earlier versions, which allowed merging of tentative definitions by the linker by putting them into a single “common” block.</p>
<p>With GCC 10, and earlier version with <code>-fno-common</code>, this merging does not happen and one instead gets the linker error. A quick hack is to build with <code>-fcommon</code> to still use the common block, and this is also a reliable way of detecting the cause of the problem. See <a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Common-symbols">Writing R Extension</a> for more details.</p>
<p>The patches provided for affected packages for now mostly use <code>-fcommon</code> in such cases, but this is a hack. Package maintainers who want their packages to work with UCRT (and GCC 10 and newer in principle) should instead fix the source code of their packages and then ask for the patch to be removed from the central repository.</p>
<h3 id="other-issues">Other issues</h3>
<p>Other problems faced already included missing external libraries (MXE configurations need to be added, as described below), external libraries built in a way unexpected by the package or in an unexpected version (e.g.  HDF5), headers stored in different directories (note <code>LOCAL_SOFT</code> variable is set to the root of the toolchain, so <code>$(LOCAL_SOFT)/include</code> is added automatically and subdirectories may be added explicitly), explicit setting of Windows target version (<code>_WIN32_WINNT</code>). Posix thread-safe functions are only available when <code>_POSIX_THREAD_SAFE_FUNCTIONS</code> macro is defined.</p>
<h2 id="building-the-toolchain-and-libraries-from-source">Building the toolchain and libraries from source</h2>
<p>The toolchain and libraries are built using a modified version of <a href="https://mxe.cc/">MXE</a>, which is available <a href="https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/toolchain_libs/mxe">here</a>. The build is run on a Linux machine, so it involves building a GCC10/MinGW-W64/UCRT cross-compilation toolchain, cross-compiling a large number of libraries needed by R and R packages, and then building also a native compiler toolchain so that R and R packages can be built natively on Windows.</p>
<p>Scripts for setting up the build in docker running Ubuntu 20.04 are available <a href="https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/toolchain_libs/">here</a>. However, this is easy enough and convenient to run natively. On Ubuntu 20.04, following <a href="https://mxe.cc/#requirements-debian">MXE documentation</a>, install these packages:</p>
<pre><code>apt-get install -y \
    autoconf \
    automake \
    autopoint \
    bash \
    bison \
    bzip2 \
    flex \
    g++ \
    g++-multilib \
    gettext \
    git \
    gperf \
    intltool \
    libc6-dev-i386 \
    libgdk-pixbuf2.0-dev \
    libltdl-dev \
    libssl-dev \
    libtool-bin \
    libxml-parser-perl \
    lzip \
    make \
    openssl \
    p7zip-full \
    patch \
    perl \
    python \
    ruby \
    sed \
    unzip \
    wget \
    xz-utils</code></pre>
<p>And then also install these:</p>
<pre><code>apt-get install -y texinfo sqlite3</code></pre>
<p>Run <code>make</code> (or <code>make -j</code>) in <code>mxe</code>. The build takes about 2 hours on a recent server machine, so don’t expect that to be fast, but then building individual MXE packages (new, modified) is fast as the build is incremental using <code>make</code>.</p>
<p>The result will appear in <code>mxe/usr</code>, the native toolchain and libraries specifically in <code>mxe/usr/x86_64-w64-mingw32.static.posix</code>. The content of that directory is currently just packed into a tarball available as e.g. <code>gcc10_ucrt3_4354.txz</code> <a href="https://www.r-project.org/nosvn/winutf8/ucrt3/">here</a>.</p>
<h2 id="addingupdating-mxe-package">Adding/updating MXE package</h2>
<p>Some R packages cannot be built or don’t work, because they depend on an external library not available in the experimental toolchain. To add such software, one needs to create an appropriate MXE package or update one. <a href="https://mxe.cc/">MXE</a> documentation has more details, but for example the package for the tiff library is named “tiff” and available <a href="https://github.com/mxe/mxe/blob/master/src/tiff.mk">here</a> and did not have to be customized for R:</p>
<pre><code># This file is part of MXE. See LICENSE.md for licensing information.

PKG             := tiff
$(PKG)_WEBSITE  := http://simplesystems.org/libtiff/
$(PKG)_DESCR    := LibTIFF
$(PKG)_IGNORE   :=
$(PKG)_VERSION  := 4.2.0
$(PKG)_CHECKSUM := eb0484e568ead8fa23b513e9b0041df7e327f4ee2d22db5a533929dfc19633cb
$(PKG)_SUBDIR   := tiff-$($(PKG)_VERSION)
$(PKG)_FILE     := tiff-$($(PKG)_VERSION).tar.gz
$(PKG)_URL      := https://download.osgeo.org/libtiff/$($(PKG)_FILE)
$(PKG)_DEPS     := cc jpeg libwebp xz zlib

define $(PKG)_UPDATE
    $(WGET) -q -O- &#39;http://simplesystems.org/libtiff/&#39; | \
    $(SED) -n &#39;s,.*&gt;v\([0-9][^&lt;]*\)&lt;.*,\1,p&#39; | \
    head -1
endef

define $(PKG)_BUILD
    cd &#39;$(1)&#39; &amp;&amp; ./configure \
        $(MXE_CONFIGURE_OPTS) \
        --without-x
    $(MAKE) -C &#39;$(1)&#39; -j &#39;$(JOBS)&#39; install $(MXE_DISABLE_CRUFT)
endef</code></pre>
<p>One may add a new package to <code>src</code>, then build it using <code>make pkgname</code>, and when ready, add that to <code>settings.mk</code> to the <code>LOCAL_PKG_LIST</code> so that it is built automatically. One the needs to copy the updated <code>usr/86_64-w64-mingw32.static.posix</code> to the Windows machine and perform R package builds there.</p>
<p>When maintaining open-source software distributions, often one may take inspiration from somewhere else. First, many packages are already available in MXE; if they just work, they only need to be added to <code>settings.mk</code>. Still, a number of packages had to be adapted or upgraded to build with UCRT. Then, some packages may be available in a similar customized version of MXE used by Octave, <a href="https://wiki.octave.org/MXE">MXE-Octave</a>. Then some packages popular in the R community but not present in MXE may be available in <a href="https://github.com/msys2/MINGW-packages">Msys2</a> or <a href="https://github.com/r-windows/rtools-packages">Rtools4</a>, yet those package configurations are in a different format and not written for cross-compilation nor static linking. Linux distributions, e.g. Debian, then have much bigger selection of build configurations of packages, again in a different format.</p>
<p>If your package needs a library not currently supported by the modified version of MXE used to build in this toolchain, you are welcome to provide a build configuration for such library. In the ideal case, such package configurations would be contributed directly to upstream MXE, which may be a forcing function to test such package with more configurations (e.g. also dynamic linking, also MSVCRT, etc), but a much wider group of users will be able to benefit from that.</p>
<h2 id="establishing-the-linking-order-from-existing-patches">Establishing the linking order from existing patches</h2>
<p>As noted above, most CRAN packages that needed it at the time of this writing have been patched (the patch adding <code>Makevars.ucrt</code>), so package maintainer may find linking orders there and test them, update and add to their source code (possibly also checking against <code>pkg-config</code>, see below). It may be that some of them are incorrect, even though there are no linking errors - package authors may know better knowing their code, and issues should be discovered by testing.</p>
<h2 id="establishing-the-linking-order-in-r-packages-via-pkg-config">Establishing the linking order in R packages via pkg-config</h2>
<p>The linking order can be obtained via <code>pkg-config</code>, which is only available on the cross-compilation host (Linux). One may run</p>
<pre><code>env PKG_CONFIG_PATH=usr/x86_64-w64-mingw32.static.posix/lib/pkgconfig ./usr/x86_64-pc-linux-gnu/bin/pkgconf --static libtiff-4 --libs-only-l</code></pre>
<p>to get <code>-ltiff -lwebp -lzstd -llzma -ljpeg -lz</code>, a correct linking order which may be added to the package <code>src/Makevars.ucrt</code> (<code>src/Makevars.win</code>) for package tiff. One still has to figure out that the pkg-config package name is <code>libtiff-4</code> (the MXE package is <code>tiff</code>, the Rtool4 package is <code>libtiff</code>).</p>
<p>Unfortunately, <code>pkg-config</code> does not always provide a working linking order. For example, for <code>opencv</code>, at the time of this writing,</p>
<pre><code>env PKG_CONFIG_PATH=usr/x86_64-w64-mingw32.static.posix/lib/pkgconfig ./usr/x86_64-pc-linux-gnu/bin/pkgconf --static opencv4 --libs-only-l</code></pre>
<p>gives</p>
<pre><code>-lopencv_highgui451 -lopencv_ml451 -lopencv_objdetect451 -lopencv_photo451 -lopencv_stitching451 -lopencv_video451 -lopencv_calib3d451 -lopencv_features2d451 -lopencv_dnn451 -lopencv_flann451 -lopencv_videoio451 -lopencv_imgcodecs451 -lopencv_imgproc451 -lopencv_core451 -llibopenjp2 -lquirc -lprotobuf -lcomctl32 -lgdi32 -lole32 -lsetupapi -lws2_32 -ljpeg -lwebp -lpng -lz -ltiff -lzstd -llzma -lopengl32 -lglu32</code></pre>
<p>which does not work. One has to add <code>-L$(LOCAL_SOFT)/lib/opencv4/3rdparty</code> so that <code>-llibopenjp2 -lquirc</code> are found (<code>LOCAL_SOFT</code> is set to the root of the compiled native toolchain). Still, this list of libraries is not complete, a number of dependencies are missing (<code>webp</code> is one of them). In principle, this is a common problem that <code>pkg-config</code> configurations are not thoroughly tested with static linking.</p>
<p><code>pkg-config</code> is not available in the native toolchain, so packages cannot use it directly in their make files, and for the reasons shown here probably should not, anyway. But it may be useful as a hint/starting point when establisthing the linking order.</p>
<h2 id="establishing-the-linking-order-via-topological-sort">Establishing the linking order via topological sort</h2>
<p>As of this writing, the more successful way of establishing linking orders was via computation over the compiled static libraries. For this, a little background follows, substantially simplified.</p>
<p>R on Windows uses static linking. Static libraries are just archives of object files, without any references to other static libraries they may need as dependencies. The linker keeps track of the currently undefined symbols and goes through the list of libraries (so archives of object files) from left to right. If an object file from a library defines a symbol that the linker knows is undefined, the linker will add that object file to the binary. It will then add any additional object files from the same library which define any undefined symbols arising from the same library, but it will not add other object files from that library. This may result in that new symbols would become undefined after processing that library. These symbols have to be defined by some of the additional libraries in the list.</p>
<p>For this to work, one needs to make sure that any time one library uses a symbol from another library, it is processed earlier by the linker. This is a problem when there is a loop of dependent libraries, however, one can usually resolve that by adding some libraries multiple times to the list or moving some library in the list, taking advantage of the mechanism described above: only the object files with some currently needed symbols are added from the library.</p>
<p>The GNU linker also allows to specify linking groups, within which linking is repeated in the given order re-starting until all symbols are resolved (see <code>--start-group</code> and <code>--end-group</code>), with a price in performance. This feature has not been needed yet in the experimental toolchain.</p>
<p>Symbols exported from object files and actually missing at linking time are mostly unique in the experimental toolchain. Exceptions include inlined C++ functions (but then they are not missing at linking time), alternative implementations (e.g. parallel OpenBLAS, serial OpenBLAS, reference BLAS), runtime library wrappers (but they are not missing at linking time). Still, it should be possible to come up with a tool that could well advice on the list and order of libraries to link. Possibly with heuristics to resolve some edge cases.</p>
<p>Traditionally, this is done in Unix using <code>lorder</code> script and <code>tsort</code>. <code>lorder</code> generates a list of dependencies between static libraries, defensively assuming that all object files from those libraries are needed. <code>tsort</code> establishes a topological ordering on the result of <code>lorder</code>. One can just try to build an R package without linking any libraries, parse the output from the linker looking for undefined symbols, find static libraries providing such symbols, and establish the topological ordering. The resulting linking order can be then added to the <code>src/Makevars.ucrt</code> (<code>src/Makevars.win</code>), the build of the R package tried again, generating another list of undefined symbols. Then one can merge the list of libraries established previously with the list established now, do the topological sort again, and iterate this way until linking succeeds.</p>
<p>This is how linking orders for most patched CRAN packages were obtained, but thorough testing is needed to figure out whether they produce a working package. In principle, a better tool could definitely make this process faster and more automated, and not requiring manual iterative linking attempts.</p>
<p>Some manual adaptations to the linking orders created that way were needed, anyway, and probably always will. These included resolving loops (<code>tsort</code> gives warning when it sees them, which is a hint) by shifting libraries in the ordering and adding some twice. Also, some symbols are not completely unique in the toolchain and the semi-automated process did not choose the best library (e.g. <code>libmincore</code> and <code>libwindowsapp</code> should not be linked, because they depend on console Windows DLLs which are not present on Windows Server). <code>-lsbml-static</code> should be used instead of <code>-lsbml.dll</code> (the latter is an import library for a DLL, not a static library with the code per se).</p>
<p>None of this should be needed if the <code>pkg-config</code> databases were fixed to work reliably with static linking. That could be done via improving MXE package configurations, but the effort required may be bigger than improving a hint tool described above, but if fixed, the results could be more reliable. One still would need to know the right names of the pkg-config packages, which are distribution specific.</p>
<p>Note that similar problems with other toolchains may be hidden when pre-built (bigger) static libraries are being downloaded during package installation.</p>
<h2 id="troubleshooting-library-loading-failures">Troubleshooting library loading failures</h2>
<p>Sometimes a package DLL is linked succesfully, but the DLL cannot be loaded. Sometimes it can be loaded on the machine where it was built, but not on another machine. One example is the linking of console API present on Windows 10, but not on Windows Server. A common problem why a DLL cannot be loaded is that a dependent DLL is not found (unlike static libraries, DLLs know their dependencies). This is a common problem which can happen on Windows with any toolchain.</p>
<p>When this happens to a DLL linked to an application, such as <code>Rblas</code> linked to <code>R</code>, an error message will appear helpfully saying that <code>Rblas</code> could not be found. However, when such DLL is being loaded explicitly via a Windows API call (to `LoadLibrary), which is the case when loading DLLs of R packages, Windows is unable to say which DLL is missing:</p>
<pre><code>Error: package or namespace load failed for &#39;magick&#39; in inDL(x, as.logical(local
), as.logical(now), ...):
 unable to load shared object &#39;C:/msys64/home/tomas/ucrt3/svn/ucrt3/r_packages/r
inst/library/00LOCK-magick/00new/magick/libs/x64/magick.dll&#39;:
  LoadLibrary failure:  The specified module could not be found.</code></pre>
<p>Note: in the above, <code>magick.dll</code> is present on the path listed. It is some of its dependencies that is not found, but Windows would tell which one. The confusing error message comes directly from Windows and R cannot possibly fix that.</p>
<p>There is still a way to debug this. One can install <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/">WinDbg</a> from Microsoft (for free), which also includes <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/gflags">gflags</a>.</p>
<p>Using <code>gflags /i Rterm.exe +sls</code> (note <code>gflags</code> gets installed to <code>C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\</code>) set “loaded snaps” for the R executable. Then run R, get its process ID using <code>Sys.getpid()</code>, start <code>WinDbg</code>, attach to the R process via that process ID, type ‘g’ (to continue running). In the R process, try to load the problematic package, e.g. <code>library(magick)</code>. This will produce a number of messages, but in this case, one of them was</p>
<pre><code>3e94:29f8 @ 674068078 - LdrpProcessWork - ERROR: Unable to load DLL: &quot;api-ms-win-core-console-l1-2-0.dll&quot;, Parent Module: &quot;C:\msys64\home\tomas\ucrt3\svn\ucrt3\r\build_opt\trunk\library\magick\libs\x64\magick.dll&quot;, Status: 0xc0000135</code></pre>
<p>Which made it clear that <code>api-ms-win-core-console-l1-2-0.dll</code> was the missing DLL.</p>
<p>The flag can be removed using <code>-sls</code>. Note that the Msys2 console (mintty with bash, by default) is very different from cmd.exe in Windows: the latter uses a different API and e.g. sometimes shows more debugging messages, etc. It is better to use cmd.exe when debugging (with <code>WinDbg</code> but also gdb). One may use <code>gdb</code> from Msys2 with this toolchain the same way as with Rtools4.</p>
<h2 id="building-other-applications-e.g.-jags-for-ucrt">Building other applications (e.g. JAGS) for UCRT</h2>
<p>R packages are sometimes linked against dynamic libraries installed by external applications. It may become necessary to rebuild such libraries as well to be built for UCRT. It is advisable for encodings to be handled properly (yet that depends on how that library handles encodings), but it may be the least inconvenient solution also to avoid other clashes between runtimes, such as in memory allocation.</p>
<p><a href="http://mcmc-jags.sourceforge.net/">JAGS</a> (Just Another Gibbs Sampler) is used by R package rjags and some other packages. JAGS is installed as a standalone application via its interactive installer and includes shared libraries (JAGS library and a number of modules) and C headers. R packages at build time use those C headers and link against that JAGS shared library.</p>
<p>When R package rjags is built with the UCRT toolchain, so linked against the JAGS library from the official JAGS 4 distribution, it does not work. The linking of the R package library is successful, but building of the package indices fail, unfortunately without any detailed error message. The problem is that building of package indices already involves loading the rjags package and running it, and that crashes because of C runtime mismatch, the JAGS library built for MSVCRT ends up calling UCRT free function on an object allocated using MSVCRT.</p>
<p>To resolve this, JAGS has been rebuilt for UCRT using this experimental toolchain. The installer is available <a href="https://www.r-project.org/nosvn/winutf8/ucrt3/extra/jags">here</a> and the script used to build it is available <a href="https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/extra/jags">here</a>.</p>
<p>The tricks needed to build JAGS follow and some may be needed when natively building other applications as well.</p>
<p>First, JAGS uses libtool for linking. Some libraries in MXE, and luckily most of those used by JAGS have libtool control files (<code>.la</code> extension), but by libtool design these files include hard-coded directories that are filled when the toolchain is built, so a PATH on some Linux machine. The <code>.la</code> files had to be fixed manually to include the hard-coded directory on the Windows machine where they are installed (using <code>sed -i -e</code>).</p>
<p>Then, JAGS uses <code>configure</code>, but when running in Msys2, the host system identification is different from what the MXE-built toolchain has, so some utilities (but not all) are not detected correctly. <code>configure</code> has to be run with <code>--host=x86_64-w64-mingw32.static.posix</code>).</p>
<p>Futhermore, as documented in JAGS installation manual, libtool will not link a static library to a shared library created as “module. This causes trouble for some JAGS modules, such as”bugs", which link against LAPACK and BLAS. The UCRT toolchain includes static libraries for reference LAPACK and BLAS, but libtool refuses to link them (also, they don’t have <code>.la</code> files).</p>
<p>This can be solved by building wrapper dynamic libraries for these static LAPACK and BLAS libraries, following instructions from the JAGS manual, with the toolchain on PATH (as when building R and packages):</p>
<pre><code>export TLIB=~/svn/ucrt3/r/x86_64-w64-mingw32.static.posix/lib
dlltool -z libblas.def --export-all-symbols $TLIB/libblas.a
gfortran -shared -o libblas.dll -Wl,--out-implib=libblas.dll.a libblas.def $TLIB/libblas.a
dlltool -z liblapack.def --export-all-symbols $TLIB/liblapack.a
gfortran -shared -o liblapack.dll -Wl,--out-implib=liblapack.dll.a liblapack.def $TLIB/liblapack.a  -L. -lblas</code></pre>
<p>One can then provide these libraries to JAGS configure via <code>-with-blas="-L$TLHOME -lblas" --with-lapack="-L$TLHOME -llapack"</code>, where <code>XXX</code> is the directory with <code>liblapack.dll</code> and <code>libblas.dll</code>. These two DLLs have to be then copied into the JAGS build tree before running the installer:</p>
<pre><code>./configure --host=x86_64-w64-mingw32.static.posix --with-blas=&quot;-L$TLHOME -lblas&quot; --with-lapack=&quot;-L $TLHOME -llapack&quot;
make win64-install
cp $TLHOME/libblas.dll $TLHOME/liblapack.dll win/inst64/bin
make installer</code></pre>
<p>But, before running <code>make installer</code>, one needs to fix the installer script for 64-bit-only build. The original installer supported both 32-bit and 64-bit architecture, but the experimental toolchain only supports 64-bit. The patch is available with the build script, <a href="https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/extra/jags">here</a>.</p>
