From GCC 10 (backporting to GCC 10.3)

https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100402
https://gcc.gnu.org/git/gitweb.cgi?p=gcc.git;h=e3abcc56d2604b9d2652b615ff9e68981cb7f79e

diff -Nru gcc-10.3.0-orig/gcc/config/i386/i386.c gcc-10.3.0-patched/gcc/config/i386/i386.c
--- gcc-10.3.0-orig/gcc/config/i386/i386.c	2021-04-08 07:56:28.109741163 -0400
+++ gcc-10.3.0-patched/gcc/config/i386/i386.c	2021-08-09 10:18:29.819054960 -0400
@@ -6356,12 +6356,29 @@
 	 area, see the SEH code in config/i386/winnt.c for the rationale.  */
       frame->hard_frame_pointer_offset = frame->sse_reg_save_offset;
 
-      /* If we can leave the frame pointer where it is, do so.  Also, return
-	 the establisher frame for __builtin_frame_address (0) or else if the
-	 frame overflows the SEH maximum frame size.  */
+      /* If we can leave the frame pointer where it is, do so; however return
+         the establisher frame for __builtin_frame_address (0) or else if the
++        frame overflows the SEH maximum frame size.
++
++        Note that the value returned by __builtin_frame_address (0) is quite
++        constrained, because setjmp is piggybacked on the SEH machinery with
++        recent versions of MinGW:
++
++         #    elif defined(__SEH__)
++         #     if defined(__aarch64__) || defined(_ARM64_)
++         #      define setjmp(BUF) _setjmp((BUF), __builtin_sponentry())
++         #     elif (__MINGW_GCC_VERSION < 40702)
++         #      define setjmp(BUF) _setjmp((BUF), mingw_getsp())
++         #     else
++         #      define setjmp(BUF) _setjmp((BUF), __builtin_frame_address (0))
++         #     endif
++
++        and the second argument passed to _setjmp, if not null, is forwarded
++        to the TargetFrame parameter of RtlUnwindEx by longjmp (after it has
++        built an ExceptionRecord on the fly describing the setjmp buffer).  */	 
       const HOST_WIDE_INT diff
 	= frame->stack_pointer_offset - frame->hard_frame_pointer_offset;
-      if (diff <= 255)
+      if (diff <= 255 && !crtl->accesses_prior_frames)
 	{
 	  /* The resulting diff will be a multiple of 16 lower than 255,
 	     i.e. at most 240 as required by the unwind data structure.  */
diff -Nru gcc-10.3.0-orig/gcc/testsuite/gcc.c-torture/execute/20210505-1.c gcc-10.3.0-patched/gcc/testsuite/gcc.c-torture/execute/20210505-1.c
--- gcc-10.3.0-orig/gcc/testsuite/gcc.c-torture/execute/20210505-1.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-10.3.0-patched/gcc/testsuite/gcc.c-torture/execute/20210505-1.c	2021-08-09 10:15:47.559103332 -0400
@@ -0,0 +1,31 @@
+/* PR target/100402 */
+/* Testcase by Hannes Domani <ssbssa@yahoo.de> */
+
+/* { dg-require-effective-target indirect_jumps } */
+
+#include <setjmp.h>
+#include <stdbool.h>
+
+static jmp_buf buf;
+static _Bool stop = false;
+
+void call_func (void(*func)(void))
+{
+  func ();
+}
+
+void func (void)
+{
+  stop = true;
+  longjmp (buf, 1);
+}
+
+int main (void)
+{
+  setjmp (buf);
+
+  while (!stop)
+    call_func (func);
+
+  return 0;
+}
