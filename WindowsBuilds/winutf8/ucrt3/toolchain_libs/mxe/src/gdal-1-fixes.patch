diff -Nru gdal-3.6.1-orig/apps/commonutils.h gdal-3.6.1-patched/apps/commonutils.h
--- gdal-3.6.1-orig/apps/commonutils.h	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/apps/commonutils.h	2023-01-03 06:32:17.397842283 -0500
@@ -75,7 +75,44 @@
 #define MAIN_END
 
 #endif // defined(WIN32)
-#endif // defined(__cplusplus)
+#else // defined(__cplusplus) ----------------------------------
+
+#if defined(WIN32) && (defined(_MSC_VER) || defined(SUPPORTS_WMAIN))
+
+#include <wchar.h>
+#include <stdlib.h>
+#include "cpl_conv.h"
+#include "cpl_string.h"
+
+int wmain( int argc, wchar_t ** argv_w, wchar_t ** envp );
+
+#define MAIN_START(argc, argv) \
+  int wmain( int argc, wchar_t ** argv_w, wchar_t **envp ) \
+  { \
+    char **argv = (char**)(CPLCalloc(argc + 1, sizeof(char*))); \
+    { \
+      int i; \
+      for( i = 0; i < argc; i++ ) \
+      { \
+        argv[i] = CPLRecodeFromWChar( argv_w[i], CPL_ENC_UCS2, CPL_ENC_UTF8 ); \
+      } \
+    }
+
+// NOTE: memory will not be explicitly freed on exit/return from wmain()
+
+#define MAIN_END CSLDestroy(argv); \
+    return 0; \
+  }
+
+#else // defined(WIN32)
+
+#define MAIN_START(argc, argv) \
+    int main( int argc, char ** argv )
+
+#define MAIN_END
+
+#endif // defined(WIN32)
+#endif // (!__cplusplus__)
 
 
 CPL_C_START
diff -Nru gdal-3.6.1-orig/apps/dumpoverviews.cpp gdal-3.6.1-patched/apps/dumpoverviews.cpp
--- gdal-3.6.1-orig/apps/dumpoverviews.cpp	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/apps/dumpoverviews.cpp	2023-01-03 06:32:17.397842283 -0500
@@ -31,6 +31,7 @@
 #include "cpl_string.h"
 #include "gdal_priv.h"
 #include "ogr_spatialref.h"
+#include "commonutils.h"
 
 
 static void DumpBand( GDALDatasetH hBaseDS, GDALRasterBandH hBand,
@@ -50,7 +51,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main( int argc, char ** argv )
+MAIN_START(argc, argv)
 
 {
     GDALAllRegister();
@@ -179,6 +180,7 @@
 
     return 0;
 }
+MAIN_END
 
 /************************************************************************/
 /*                              DumpBand()                              */
diff -Nru gdal-3.6.1-orig/apps/dumpoverviews.cpp.orig gdal-3.6.1-patched/apps/dumpoverviews.cpp.orig
--- gdal-3.6.1-orig/apps/dumpoverviews.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.6.1-patched/apps/dumpoverviews.cpp.orig	2022-12-13 18:02:35.000000000 -0500
@@ -0,0 +1,261 @@
+/* ****************************************************************************
+ *
+ * Project:  GDAL Utilities
+ * Purpose:  Dump overviews to external files.
+ * Author:   Frank Warmerdam, warmerdam@pobox.com
+ *
+ * ****************************************************************************
+ * Copyright (c) 2005, Frank Warmerdam
+ * Copyright (c) 2009-2010, Even Rouault <even dot rouault at spatialys.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ ****************************************************************************/
+
+#include "cpl_conv.h"
+#include "cpl_string.h"
+#include "gdal_priv.h"
+#include "ogr_spatialref.h"
+
+
+static void DumpBand( GDALDatasetH hBaseDS, GDALRasterBandH hBand,
+                      const char *pszName );
+
+/************************************************************************/
+/*                               Usage()                                */
+/************************************************************************/
+static void Usage()
+
+{
+    printf( "Usage: dumpoverviews [-masks] <filename> [overview]*\n" );
+    exit( 1 );
+}
+
+/************************************************************************/
+/*                                main()                                */
+/************************************************************************/
+
+int main( int argc, char ** argv )
+
+{
+    GDALAllRegister();
+
+    argc = GDALGeneralCmdLineProcessor( argc, &argv, 0 );
+    if( argc < 1 )
+        exit( -argc );
+
+/* -------------------------------------------------------------------- */
+/*      Process arguments.                                              */
+/* -------------------------------------------------------------------- */
+    const char *pszSrcFilename = nullptr;
+    int anReqOverviews[1000] = {};
+    int nReqOverviewCount = 0;
+    bool bMasks = false;
+
+    for( int iArg = 1; iArg < argc; iArg++ )
+    {
+        if( EQUAL(argv[iArg],"-masks") )
+        {
+            bMasks = true;
+        }
+        else if( pszSrcFilename == nullptr )
+        {
+            pszSrcFilename = argv[iArg];
+        }
+        else if( atoi(argv[iArg]) > 0 || EQUAL(argv[iArg],"0") )
+        {
+            anReqOverviews[nReqOverviewCount++] = atoi(argv[iArg]);
+        }
+        else
+        {
+            Usage();
+        }
+    }
+
+    if( pszSrcFilename == nullptr )
+        Usage();
+
+/* -------------------------------------------------------------------- */
+/*      Open the input file.                                            */
+/* -------------------------------------------------------------------- */
+    GDALDatasetH hSrcDS = GDALOpen( pszSrcFilename, GA_ReadOnly );
+
+    if( hSrcDS == nullptr )
+        exit( 1 );
+
+/* ==================================================================== */
+/*      Process all bands.                                              */
+/* ==================================================================== */
+    const int nBandCount = GDALGetRasterCount( hSrcDS );
+
+    for( int iBand = 0; iBand < nBandCount; iBand++ )
+    {
+        GDALRasterBandH hBaseBand = GDALGetRasterBand( hSrcDS, iBand+1 );
+
+/* -------------------------------------------------------------------- */
+/*      Process all overviews.                                          */
+/* -------------------------------------------------------------------- */
+        const int nOverviewCount = GDALGetOverviewCount( hBaseBand );
+
+        for( int iOverview = 0; iOverview < nOverviewCount; iOverview++ )
+        {
+            GDALRasterBandH hSrcOver = GDALGetOverview( hBaseBand, iOverview );
+
+            if( hSrcOver == nullptr )
+            {
+                fprintf(stderr, "skipping overview %d as being null\n",
+                        iOverview);
+                continue;
+            }
+
+/* -------------------------------------------------------------------- */
+/*      Is this a requested overview?                                   */
+/* -------------------------------------------------------------------- */
+            if( nReqOverviewCount > 0 )
+            {
+              int i = 0;  // Used after for.
+
+                for( ; i < nReqOverviewCount; i++ )
+                {
+                    if( anReqOverviews[i] == iOverview )
+                        break;
+                }
+
+                if( i == nReqOverviewCount )
+                    continue;
+            }
+
+/* -------------------------------------------------------------------- */
+/*      Create matching output file.                                    */
+/* -------------------------------------------------------------------- */
+            CPLString osFilename;
+            osFilename.Printf( "%s_%d_%d.tif",
+                               CPLGetBasename(pszSrcFilename),
+                               iBand+1, iOverview );
+            DumpBand( hSrcDS, hSrcOver, osFilename );
+
+            if( bMasks )
+            {
+                CPLString osMaskFilename;
+                osMaskFilename.Printf( "%s_%d_%d_mask.tif",
+                                       CPLGetBasename(pszSrcFilename),
+                                       iBand+1, iOverview );
+                DumpBand( hSrcDS, GDALGetMaskBand(hSrcOver), osMaskFilename );
+            }
+        }
+
+/* -------------------------------------------------------------------- */
+/*      Do we dump the mask?                                            */
+/* -------------------------------------------------------------------- */
+        if( bMasks )
+        {
+            CPLString osFilename;
+            osFilename.Printf( "%s_%d_mask.tif",
+                               CPLGetBasename(pszSrcFilename),
+                               iBand+1 );
+            DumpBand( hSrcDS, GDALGetMaskBand(hBaseBand), osFilename );
+        }
+    }
+
+    GDALClose( hSrcDS );
+
+    CSLDestroy( argv );
+    GDALDestroyDriverManager();
+
+    return 0;
+}
+
+/************************************************************************/
+/*                              DumpBand()                              */
+/************************************************************************/
+
+static void DumpBand( GDALDatasetH hBaseDS, GDALRasterBandH hSrcOver,
+                      const char *pszName )
+
+{
+/* -------------------------------------------------------------------- */
+/*      Get base ds info.                                               */
+/* -------------------------------------------------------------------- */
+    double adfGeoTransform[6] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
+    bool bHaveGT = GDALGetGeoTransform( hBaseDS, adfGeoTransform ) == CE_None;
+
+    const int nOrigXSize = GDALGetRasterXSize( hBaseDS );
+    const int nOrigYSize = GDALGetRasterYSize( hBaseDS );
+
+/* -------------------------------------------------------------------- */
+/*      Create matching output file.                                    */
+/* -------------------------------------------------------------------- */
+    const int nXSize = GDALGetRasterBandXSize( hSrcOver );
+    const int nYSize = GDALGetRasterBandYSize( hSrcOver );
+    const GDALDataType eDT = GDALGetRasterDataType( hSrcOver );
+    GDALDriverH hDriver = GDALGetDriverByName( "GTiff" );
+
+    GDALDatasetH hDstDS = GDALCreate( hDriver, pszName, nXSize, nYSize,
+                                      1, eDT, nullptr );
+
+    if( hDstDS == nullptr )
+        exit( 1 );
+
+/* -------------------------------------------------------------------- */
+/*      Apply corresponding georeferencing, scaled to size.             */
+/* -------------------------------------------------------------------- */
+    if( bHaveGT )
+    {
+        double adfOvGeoTransform[6] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
+
+        memcpy( adfOvGeoTransform, adfGeoTransform,
+                sizeof(double) * 6 );
+
+        adfOvGeoTransform[1] *= nOrigXSize / static_cast<double>(nXSize);
+        adfOvGeoTransform[2] *= nOrigXSize / static_cast<double>(nXSize);
+        adfOvGeoTransform[4] *= nOrigYSize / static_cast<double>(nYSize);
+        adfOvGeoTransform[5] *= nOrigYSize / static_cast<double>(nYSize);
+
+        GDALSetGeoTransform( hDstDS, adfOvGeoTransform );
+
+        GDALSetProjection( hDstDS, GDALGetProjectionRef( hBaseDS ) );
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Copy over all the image data.                                   */
+/* -------------------------------------------------------------------- */
+    void *pData = CPLMalloc(64 * nXSize);
+
+    for( int iLine = 0; iLine < nYSize; iLine++ )
+    {
+        {
+            const CPLErr err =
+                GDALRasterIO( hSrcOver, GF_Read, 0, iLine, nXSize, 1,
+                              pData, nXSize, 1, eDT, 0, 0 );
+            if( err != CE_None )
+                CPLError( CE_Failure, CPLE_FileIO,
+                          "GDALRasterIO read failed at %d.", iLine );
+        }
+
+        const CPLErr err =
+            GDALRasterIO( GDALGetRasterBand( hDstDS, 1 ), GF_Write,
+                          0, iLine, nXSize, 1,
+                          pData, nXSize, 1, eDT, 0, 0 );
+        if( err != CE_None )
+            CPLError( CE_Failure, CPLE_FileIO,
+                      "GDALRasterIO write failed at %d.", iLine );
+    }
+    CPLFree( pData );
+
+    GDALClose( hDstDS );
+}
diff -Nru gdal-3.6.1-orig/apps/gdal2ogr.c gdal-3.6.1-patched/apps/gdal2ogr.c
--- gdal-3.6.1-orig/apps/gdal2ogr.c	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/apps/gdal2ogr.c	2023-01-03 06:32:17.401842279 -0500
@@ -31,6 +31,7 @@
 #include "ogr_api.h"
 #include "ogr_srs_api.h"
 #include "cpl_string.h"
+#include "commonutils.h"
 
 
 /************************************************************************/
@@ -72,7 +73,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main(int argc, char* argv[])
+MAIN_START(argc, argv)
 {
     const char     *pszFormat = "ESRI Shapefile";
     char           *pszLayerName = NULL;
@@ -336,3 +337,4 @@
 
     return 0;
 }
+MAIN_END
\ No newline at end of file
diff -Nru gdal-3.6.1-orig/apps/gdal2ogr.c.orig gdal-3.6.1-patched/apps/gdal2ogr.c.orig
--- gdal-3.6.1-orig/apps/gdal2ogr.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.6.1-patched/apps/gdal2ogr.c.orig	2022-12-13 18:02:35.000000000 -0500
@@ -0,0 +1,338 @@
+/******************************************************************************
+ *
+ * Project:  GDAL Utilities
+ * Purpose:  Create an OGR datasource from the values of a GDAL dataset
+ *           May be useful to test gdal_grid and generate its input OGR file
+ * Author:   Even Rouault, <even dot rouault at spatialys.com>
+ *
+ ******************************************************************************
+ * Copyright (c) 2008, Even Rouault <even dot rouault at spatialys.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ ****************************************************************************/
+
+#include "gdal.h"
+#include "ogr_api.h"
+#include "ogr_srs_api.h"
+#include "cpl_string.h"
+
+
+/************************************************************************/
+/*                               Usage()                                */
+/************************************************************************/
+
+void Usage()
+{
+    int iDriver;
+    int nDriverCount;
+
+    printf( "Usage: gdal2ogr [--help-general] [-f format_name]\n"
+            "                [-b band_number] [-l dest_layer_name]\n"
+            "                [-t type]\n"
+            "                gdal_datasource_src_name ogr_datasource_dst_name\n"
+            "\n"
+            " -f format_name: output file format name, possible values are:\n");
+
+    nDriverCount = OGRGetDriverCount();
+    for( iDriver = 0; iDriver <nDriverCount; iDriver++ )
+    {
+        OGRSFDriverH hDriver = OGRGetDriver(iDriver);
+
+        if( OGR_Dr_TestCapability(hDriver, ODrCCreateDataSource ) )
+            printf( "     -f \"%s\"\n", OGR_Dr_GetName(hDriver) );
+    }
+
+    printf( " -b band_number: band number of the GDAL datasource (1 by default)\n"
+            " -l dest_layer_name : name of the layer created in the OGR datasource\n"
+            "                      (basename of the OGR datasource by default)\n"
+            " -t type: one of POINT, POINT25D (default), POLYGON\n"
+            "\n"
+            "Create an OGR datasource from the values of a GDAL dataset.\n\n");
+
+    exit(1);
+}
+
+/************************************************************************/
+/*                                main()                                */
+/************************************************************************/
+
+int main(int argc, char* argv[])
+{
+    const char     *pszFormat = "ESRI Shapefile";
+    char           *pszLayerName = NULL;
+    const char     *pszSrcFilename = NULL, *pszDstFilename = NULL;
+    int             iBand = 1;
+    GDALDatasetH    hDS;
+    GDALRasterBandH hBand;
+    int             nXSize, nYSize;
+    int             i, j;
+    FILE           *fOut = NULL;
+    double         *padfBuffer;
+    double          adfGeotransform[6];
+    OGRSFDriverH    hOGRDriver;
+    OGRDataSourceH  hOGRDS;
+    OGRLayerH       hOGRLayer;
+    OGRwkbGeometryType eType = wkbPoint25D;
+    int             xStep = 1, yStep = 1;
+
+    OGRRegisterAll();
+    GDALAllRegister();
+
+    argc = GDALGeneralCmdLineProcessor( argc, &argv, 0 );
+    if( argc < 1 )
+        exit( -argc );
+
+/* -------------------------------------------------------------------- */
+/*      Parse arguments.                                                */
+/* -------------------------------------------------------------------- */
+    for( i = 1; i < argc; i++ )
+    {
+        if ( EQUAL(argv[i], "-b") && i < argc - 1)
+            iBand = atoi(argv[++i]);
+        else if ( EQUAL(argv[i], "-f") && i < argc - 1)
+            pszFormat = argv[++i];
+        else if ( EQUAL(argv[i], "-l") && i < argc - 1)
+            pszLayerName = CPLStrdup(argv[++i]);
+        else if ( EQUAL(argv[i], "-t") && i < argc - 1)
+        {
+            i++;
+            if (EQUAL(argv[i], "POLYGON"))
+                eType = wkbPolygon;
+            else if (EQUAL(argv[i], "POINT"))
+                eType = wkbPoint;
+            else if (EQUAL(argv[i], "POINT25D"))
+                eType = wkbPoint25D;
+            else
+            {
+                fprintf(stderr, "unhandled geometry type : %s\n", argv[i]);
+            }
+        }
+        else if ( EQUAL(argv[i], "-step") && i < argc - 1)
+            xStep = yStep = atoi(argv[++i]);
+        else if ( argv[i][0] == '-')
+            Usage();
+        else if( pszSrcFilename == NULL )
+            pszSrcFilename = argv[i];
+        else if(  pszDstFilename == NULL )
+            pszDstFilename = argv[i];
+        else
+            Usage();
+    }
+
+    if( pszSrcFilename == NULL || pszDstFilename == NULL)
+        Usage();
+
+/* -------------------------------------------------------------------- */
+/*      Open GDAL source dataset                                        */
+/* -------------------------------------------------------------------- */
+    hDS = GDALOpen(pszSrcFilename, GA_ReadOnly);
+    if (hDS == NULL)
+    {
+        fprintf(stderr, "Can't open %s\n", pszSrcFilename);
+        exit(1);
+    }
+
+    hBand = GDALGetRasterBand(hDS, iBand);
+    if (hBand == NULL)
+    {
+        fprintf(stderr, "Can't get band %d\n", iBand);
+        exit(1);
+    }
+
+    if (GDALGetGeoTransform(hDS, adfGeotransform) != CE_None)
+    {
+        fprintf(stderr, "Can't get geotransform\n");
+        exit(1);
+    }
+
+    nXSize = GDALGetRasterXSize(hDS);
+    nYSize = GDALGetRasterYSize(hDS);
+
+/* -------------------------------------------------------------------- */
+/*     Create OGR destination dataset                                   */
+/* -------------------------------------------------------------------- */
+    /* Special case for CSV : we generate the appropriate VRT file in the same time */
+    if (EQUAL(pszFormat, "CSV") && EQUAL(CPLGetExtension(pszDstFilename), "CSV"))
+    {
+        FILE* fOutCSVT;
+        FILE* fOutVRT;
+        char* pszDstFilenameCSVT;
+        char* pszDstFilenameVRT;
+
+        fOut = fopen(pszDstFilename, "wt");
+        if (fOut == NULL)
+        {
+            fprintf(stderr, "Can't open %s for writing\n", pszDstFilename);
+            exit(1);
+        }
+        fprintf(fOut, "x,y,z\n");
+
+        pszDstFilenameCSVT = CPLMalloc(strlen(pszDstFilename) + 2);
+        strcpy(pszDstFilenameCSVT, pszDstFilename);
+        strcat(pszDstFilenameCSVT, "t");
+        fOutCSVT = fopen(pszDstFilenameCSVT, "wt");
+        if (fOutCSVT == NULL)
+        {
+            fprintf(stderr, "Can't open %s for writing\n", pszDstFilenameCSVT);
+            exit(1);
+        }
+        CPLFree(pszDstFilenameCSVT);
+        fprintf(fOutCSVT, "Real,Real,Real\n");
+        fclose(fOutCSVT);
+        fOutCSVT = NULL;
+
+        pszDstFilenameVRT = CPLStrdup(pszDstFilename);
+        strcpy(pszDstFilenameVRT + strlen(pszDstFilename) - 3, "vrt");
+        fOutVRT = fopen(pszDstFilenameVRT, "wt");
+        if (fOutVRT == NULL)
+        {
+            fprintf(stderr, "Can't open %s for writing\n", pszDstFilenameVRT);
+            exit(1);
+        }
+        CPLFree(pszDstFilenameVRT);
+        fprintf(fOutVRT, "<OGRVRTDataSource>\n");
+        fprintf(fOutVRT, "  <OGRVRTLayer name=\"%s\">\n", CPLGetBasename(pszDstFilename));
+        fprintf(fOutVRT, "    <SrcDataSource>%s</SrcDataSource> \n", pszDstFilename);
+        fprintf(fOutVRT, "    <GeometryType>wkbPoint</GeometryType>\n");
+        fprintf(fOutVRT, "    <GeometryField encoding=\"PointFromColumns\" x=\"x\" y=\"y\" z=\"z\"/>\n");
+        fprintf(fOutVRT, "  </OGRVRTLayer>\n");
+        fprintf(fOutVRT, "</OGRVRTDataSource>\n");
+        fclose(fOutVRT);
+        fOutVRT = NULL;
+    }
+    else
+    {
+        OGRSpatialReferenceH hSRS = NULL;
+        const char* pszWkt;
+
+        hOGRDriver = OGRGetDriverByName(pszFormat);
+        if (hOGRDriver == NULL)
+        {
+            fprintf(stderr, "Can't find OGR driver %s\n", pszFormat);
+            exit(1);
+        }
+
+        hOGRDS = OGR_Dr_CreateDataSource(hOGRDriver, pszDstFilename, NULL);
+        if (hOGRDS == NULL)
+        {
+            fprintf(stderr, "Can't create OGR datasource %s\n", pszDstFilename);
+            exit(1);
+        }
+
+        pszWkt = GDALGetProjectionRef(hDS);
+        if (pszWkt && pszWkt[0])
+        {
+            hSRS = OSRNewSpatialReference(pszWkt);
+        }
+
+        if (pszLayerName == NULL)
+            pszLayerName = CPLStrdup(CPLGetBasename(pszDstFilename));
+
+        hOGRLayer = OGR_DS_CreateLayer( hOGRDS, pszLayerName,
+                                        hSRS, eType, NULL);
+
+        if (hSRS)
+            OSRDestroySpatialReference(hSRS);
+
+        if (hOGRLayer == NULL)
+        {
+            fprintf(stderr, "Can't create layer %s\n", pszLayerName);
+            exit(1);
+        }
+
+        if (eType != wkbPoint25D)
+        {
+            OGRFieldDefnH hFieldDefn =  OGR_Fld_Create( "z", OFTReal );
+            OGR_L_CreateField(hOGRLayer, hFieldDefn, 0);
+            OGR_Fld_Destroy( hFieldDefn );
+        }
+    }
+
+
+    padfBuffer = (double*)CPLMalloc(nXSize * sizeof(double));
+
+#define GET_X(j, i) adfGeotransform[0] + (j) * adfGeotransform[1] + (i) * adfGeotransform[2]
+#define GET_Y(j, i) adfGeotransform[3] + (j) * adfGeotransform[4] + (i) * adfGeotransform[5]
+#define GET_XY(j, i) GET_X(j, i), GET_Y(j, i)
+
+/* -------------------------------------------------------------------- */
+/*     "Translate" the source dataset                                   */
+/* -------------------------------------------------------------------- */
+    for(i=0;i<nYSize;i+=yStep)
+    {
+        GDALRasterIO( hBand, GF_Read, 0, i, nXSize, 1,
+                      padfBuffer, nXSize, 1, GDT_Float64, 0, 0);
+        for(j=0;j<nXSize;j+=xStep)
+        {
+            if (fOut)
+            {
+                fprintf(fOut, "%f,%f,%f\n",
+                        GET_XY(j + .5, i + .5), padfBuffer[j]);
+            }
+            else
+            {
+                OGRFeatureH hFeature = OGR_F_Create(OGR_L_GetLayerDefn(hOGRLayer));
+                OGRGeometryH hGeometry = OGR_G_CreateGeometry(eType);
+                if (eType == wkbPoint25D)
+                {
+                    OGR_G_SetPoint(hGeometry, 0, GET_XY(j + .5, i + .5),
+                                   padfBuffer[j]);
+                }
+                else if (eType == wkbPoint)
+                {
+                    OGR_G_SetPoint_2D(hGeometry, 0, GET_XY(j + .5, i + .5));
+                    OGR_F_SetFieldDouble(hFeature, 0, padfBuffer[j]);
+                }
+                else
+                {
+                    OGRGeometryH hLinearRing = OGR_G_CreateGeometry(wkbLinearRing);
+                    OGR_G_SetPoint_2D(hLinearRing, 0, GET_XY(j + 0, i + 0));
+                    OGR_G_SetPoint_2D(hLinearRing, 1, GET_XY(j + 1, i + 0));
+                    OGR_G_SetPoint_2D(hLinearRing, 2, GET_XY(j + 1, i + 1));
+                    OGR_G_SetPoint_2D(hLinearRing, 3, GET_XY(j + 0, i + 1));
+                    OGR_G_SetPoint_2D(hLinearRing, 4, GET_XY(j + 0, i + 0));
+                    OGR_G_AddGeometryDirectly(hGeometry, hLinearRing);
+                    OGR_F_SetFieldDouble(hFeature, 0, padfBuffer[j]);
+                }
+                OGR_F_SetGeometryDirectly(hFeature, hGeometry);
+                OGR_L_CreateFeature(hOGRLayer, hFeature);
+                OGR_F_Destroy(hFeature);
+            }
+        }
+    }
+
+/* -------------------------------------------------------------------- */
+/*     Cleanup                                                          */
+/* -------------------------------------------------------------------- */
+    if (fOut)
+        fclose(fOut);
+    else
+        OGR_DS_Destroy(hOGRDS);
+    GDALClose(hDS);
+
+    CPLFree(padfBuffer);
+    CPLFree(pszLayerName);
+
+    GDALDumpOpenDatasets( stderr );
+    GDALDestroyDriverManager();
+    OGRCleanupAll();
+    CSLDestroy( argv );
+
+    return 0;
+}
diff -Nru gdal-3.6.1-orig/apps/gdalasyncread.cpp gdal-3.6.1-patched/apps/gdalasyncread.cpp
--- gdal-3.6.1-orig/apps/gdalasyncread.cpp	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/apps/gdalasyncread.cpp	2023-01-03 06:32:17.401842279 -0500
@@ -32,6 +32,7 @@
 #include "gdal_version.h"
 #include "gdal_priv.h"
 #include "ogr_spatialref.h"
+#include "commonutils.h"
 
 
 /* ******************************************************************** */
@@ -72,7 +73,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main( int argc, char ** argv )
+MAIN_START(argc, argv)
 
 {
     GDALDatasetH        hSrcDS, hDstDS;
@@ -557,3 +558,4 @@
     GDALDumpOpenDatasets( stderr );
     GDALDestroyDriverManager();
 }
+MAIN_END
diff -Nru gdal-3.6.1-orig/apps/gdalasyncread.cpp.orig gdal-3.6.1-patched/apps/gdalasyncread.cpp.orig
--- gdal-3.6.1-orig/apps/gdalasyncread.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.6.1-patched/apps/gdalasyncread.cpp.orig	2022-12-13 18:02:35.000000000 -0500
@@ -0,0 +1,559 @@
+/******************************************************************************
+ *
+ * Project:  GDAL Utilities
+ * Purpose:  GDAL Async Image Reader, primarily for testing async api.
+ * Author:   Frank Warmerdam, warmerdam@pobox.com
+ *
+ ******************************************************************************
+ * Copyright (c) 2010, Frank Warmerdam
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ ****************************************************************************/
+
+#include "cpl_vsi.h"
+#include "cpl_conv.h"
+#include "cpl_string.h"
+#include "gdal_version.h"
+#include "gdal_priv.h"
+#include "ogr_spatialref.h"
+
+
+/* ******************************************************************** */
+/*                               Usage()                                */
+/* ******************************************************************** */
+
+static void Usage()
+
+{
+    printf( "Usage: gdalasyncread [--help-general]\n"
+            "       [-ot {Byte/Int16/UInt16/UInt32/Int32/Float32/Float64/\n"
+            "             CInt16/CInt32/CFloat32/CFloat64}]\n"
+            "       [-of format] [-b band]\n"
+            "       [-outsize xsize[%%] ysize[%%]]\n"
+            "       [-srcwin xoff yoff xsize ysize]\n"
+            "       [-co \"NAME=VALUE\"]* [-ao \"NAME=VALUE\"]\n"
+            "       [-to timeout] [-multi]\n"
+            "       src_dataset dst_dataset\n\n" );
+
+    printf( "%s\n\n", GDALVersionInfo( "--version" ) );
+    printf( "The following format drivers are configured and support output:\n" );
+    for( int iDr = 0; iDr < GDALGetDriverCount(); iDr++ )
+    {
+        GDALDriverH hDriver = GDALGetDriver(iDr);
+
+        if( GDALGetMetadataItem( hDriver, GDAL_DCAP_CREATE, nullptr ) != nullptr
+            || GDALGetMetadataItem( hDriver, GDAL_DCAP_CREATECOPY,
+                                    nullptr ) != nullptr )
+        {
+            printf( "  %s: %s\n",
+                    GDALGetDriverShortName( hDriver ),
+                    GDALGetDriverLongName( hDriver ) );
+        }
+    }
+}
+
+/************************************************************************/
+/*                                main()                                */
+/************************************************************************/
+
+int main( int argc, char ** argv )
+
+{
+    GDALDatasetH        hSrcDS, hDstDS;
+    GDALDataset *       poSrcDS, *poDstDS = nullptr;
+    int                 i;
+    int                 nRasterXSize, nRasterYSize;
+    const char          *pszSource=nullptr, *pszDest=nullptr, *pszFormat = "GTiff";
+    GDALDriverH         hDriver;
+    int                 *panBandList = nullptr, nBandCount = 0, bDefBands = TRUE;
+    GDALDataType        eOutputType = GDT_Unknown;
+    int                 nOXSize = 0, nOYSize = 0;
+    char                **papszCreateOptions = nullptr;
+    char                **papszAsyncOptions = nullptr;
+    int                 anSrcWin[4];
+    int                 bQuiet = FALSE;
+    GDALProgressFunc    pfnProgress = GDALTermProgress;
+    int                 iSrcFileArg = -1, iDstFileArg = -1;
+    int                 bMulti = FALSE;
+    double              dfTimeout = -1.0;
+    const char          *pszOXSize = nullptr, *pszOYSize = nullptr;
+
+    anSrcWin[0] = 0;
+    anSrcWin[1] = 0;
+    anSrcWin[2] = 0;
+    anSrcWin[3] = 0;
+
+    /* Check strict compilation and runtime library version as we use C++ API */
+    if (! GDAL_CHECK_VERSION(argv[0]))
+        exit(1);
+
+/* -------------------------------------------------------------------- */
+/*      Register standard GDAL drivers, and process generic GDAL        */
+/*      command options.                                                */
+/* -------------------------------------------------------------------- */
+    GDALAllRegister();
+    argc = GDALGeneralCmdLineProcessor( argc, &argv, 0 );
+    if( argc < 1 )
+        exit( -argc );
+
+/* -------------------------------------------------------------------- */
+/*      Handle command line arguments.                                  */
+/* -------------------------------------------------------------------- */
+    for( i = 1; i < argc; i++ )
+    {
+        if( EQUAL(argv[i], "--utility_version") )
+        {
+            printf("%s was compiled against GDAL %s and is running against GDAL %s\n",
+                   argv[0], GDAL_RELEASE_NAME, GDALVersionInfo("RELEASE_NAME"));
+            return 0;
+        }
+        else if( (EQUAL(argv[i],"-of") || EQUAL(argv[i],"-f")) && i < argc-1 )
+            pszFormat = argv[++i];
+
+        else if( EQUAL(argv[i],"-quiet") )
+        {
+            bQuiet = TRUE;
+            pfnProgress = GDALDummyProgress;
+        }
+
+        else if( EQUAL(argv[i],"-ot") && i < argc-1 )
+        {
+            for( int iType = 1; iType < GDT_TypeCount; iType++ )
+            {
+                if( GDALGetDataTypeName((GDALDataType)iType) != nullptr
+                    && EQUAL(GDALGetDataTypeName((GDALDataType)iType),
+                             argv[i+1]) )
+                {
+                    eOutputType = (GDALDataType) iType;
+                }
+            }
+
+            if( eOutputType == GDT_Unknown )
+            {
+                printf( "Unknown output pixel type: %s\n", argv[i+1] );
+                Usage();
+                GDALDestroyDriverManager();
+                exit( 2 );
+            }
+            i++;
+        }
+
+        else if( EQUAL(argv[i],"-b") && i < argc-1 )
+        {
+            if( atoi(argv[i+1]) < 1 )
+            {
+                printf( "Unrecognizable band number (%s).\n", argv[i+1] );
+                Usage();
+                GDALDestroyDriverManager();
+                exit( 2 );
+            }
+
+            nBandCount++;
+            panBandList = static_cast<int *>(
+                CPLRealloc(panBandList, sizeof(int) * nBandCount));
+            panBandList[nBandCount-1] = atoi(argv[++i]);
+
+            if( panBandList[nBandCount-1] != nBandCount )
+                bDefBands = FALSE;
+        }
+        else if( EQUAL(argv[i],"-co") && i < argc-1 )
+        {
+            papszCreateOptions = CSLAddString( papszCreateOptions, argv[++i] );
+        }
+
+        else if( EQUAL(argv[i],"-ao") && i < argc-1 )
+        {
+            papszAsyncOptions = CSLAddString( papszAsyncOptions, argv[++i] );
+        }
+
+        else if( EQUAL(argv[i],"-to") && i < argc-1 )
+        {
+            dfTimeout = CPLAtof(argv[++i] );
+        }
+
+        else if( EQUAL(argv[i],"-outsize") && i < argc-2 )
+        {
+            pszOXSize = argv[++i];
+            pszOYSize = argv[++i];
+        }
+
+        else if( EQUAL(argv[i],"-srcwin") && i < argc-4 )
+        {
+            anSrcWin[0] = atoi(argv[++i]);
+            anSrcWin[1] = atoi(argv[++i]);
+            anSrcWin[2] = atoi(argv[++i]);
+            anSrcWin[3] = atoi(argv[++i]);
+        }
+
+        else if( EQUAL(argv[i],"-multi") )
+        {
+            bMulti = TRUE;
+        }
+        else if( argv[i][0] == '-' )
+        {
+            printf( "Option %s incomplete, or not recognised.\n\n",
+                    argv[i] );
+            Usage();
+            GDALDestroyDriverManager();
+            exit( 2 );
+        }
+        else if( pszSource == nullptr )
+        {
+            iSrcFileArg = i;
+            pszSource = argv[i];
+        }
+        else if( pszDest == nullptr )
+        {
+            pszDest = argv[i];
+            iDstFileArg = i;
+        }
+
+        else
+        {
+            printf( "Too many command options.\n\n" );
+            Usage();
+            GDALDestroyDriverManager();
+            exit( 2 );
+        }
+    }
+
+    if( pszDest == nullptr )
+    {
+        Usage();
+        GDALDestroyDriverManager();
+        exit( 10 );
+    }
+
+    if ( strcmp(pszSource, pszDest) == 0)
+    {
+        fprintf(stderr, "Source and destination datasets must be different.\n");
+        GDALDestroyDriverManager();
+        exit( 1 );
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Attempt to open source file.                                    */
+/* -------------------------------------------------------------------- */
+
+    hSrcDS = GDALOpenShared( pszSource, GA_ReadOnly );
+    poSrcDS = (GDALDataset *) hSrcDS;
+
+    if( hSrcDS == nullptr )
+    {
+        fprintf( stderr,
+                 "GDALOpen failed - %d\n%s\n",
+                 CPLGetLastErrorNo(), CPLGetLastErrorMsg() );
+        GDALDestroyDriverManager();
+        exit( 1 );
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Collect some information from the source file.                  */
+/* -------------------------------------------------------------------- */
+    nRasterXSize = GDALGetRasterXSize( hSrcDS );
+    nRasterYSize = GDALGetRasterYSize( hSrcDS );
+
+    if( !bQuiet )
+        printf( "Input file size is %d, %d\n", nRasterXSize, nRasterYSize );
+
+    if( anSrcWin[2] == 0 && anSrcWin[3] == 0 )
+    {
+        anSrcWin[2] = nRasterXSize;
+        anSrcWin[3] = nRasterYSize;
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Establish output size.                                          */
+/* -------------------------------------------------------------------- */
+    if( pszOXSize == nullptr )
+    {
+        nOXSize = anSrcWin[2];
+        nOYSize = anSrcWin[3];
+    }
+    else
+    {
+        nOXSize = static_cast<int>((pszOXSize[strlen(pszOXSize)-1]=='%'
+                          ? CPLAtof(pszOXSize)/100*anSrcWin[2] : atoi(pszOXSize)));
+        nOYSize = static_cast<int>((pszOYSize[strlen(pszOYSize)-1]=='%'
+                          ? CPLAtof(pszOYSize)/100*anSrcWin[3] : atoi(pszOYSize)));
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Build band list to translate                                    */
+/* -------------------------------------------------------------------- */
+    if( nBandCount == 0 )
+    {
+        nBandCount = GDALGetRasterCount( hSrcDS );
+        if( nBandCount == 0 )
+        {
+            fprintf( stderr, "Input file has no bands, and so cannot be translated.\n" );
+            GDALDestroyDriverManager();
+            exit(1 );
+        }
+
+        panBandList = static_cast<int *>(CPLMalloc(sizeof(int) * nBandCount));
+        for( i = 0; i < nBandCount; i++ )
+            panBandList[i] = i+1;
+    }
+    else
+    {
+        for( i = 0; i < nBandCount; i++ )
+        {
+            if( panBandList[i] < 1 || panBandList[i] > GDALGetRasterCount(hSrcDS) )
+            {
+                fprintf( stderr,
+                         "Band %d requested, but only bands 1 to %d available.\n",
+                         panBandList[i], GDALGetRasterCount(hSrcDS) );
+                GDALDestroyDriverManager();
+                exit( 2 );
+            }
+        }
+
+        if( nBandCount != GDALGetRasterCount( hSrcDS ) )
+            bDefBands = FALSE;
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Verify source window.                                           */
+/* -------------------------------------------------------------------- */
+    if( anSrcWin[0] < 0 || anSrcWin[1] < 0
+        || anSrcWin[2] <= 0 || anSrcWin[3] <= 0
+        || anSrcWin[0] + anSrcWin[2] > GDALGetRasterXSize(hSrcDS)
+        || anSrcWin[1] + anSrcWin[3] > GDALGetRasterYSize(hSrcDS) )
+    {
+        fprintf( stderr,
+                 "-srcwin %d %d %d %d falls outside raster size of %dx%d\n"
+                 "or is otherwise illegal.\n",
+                 anSrcWin[0],
+                 anSrcWin[1],
+                 anSrcWin[2],
+                 anSrcWin[3],
+                 GDALGetRasterXSize(hSrcDS),
+                 GDALGetRasterYSize(hSrcDS) );
+        exit( 1 );
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Find the output driver.                                         */
+/* -------------------------------------------------------------------- */
+    hDriver = GDALGetDriverByName( pszFormat );
+
+    if( hDriver == nullptr )
+    {
+        printf( "Output driver `%s' not recognised.\n", pszFormat );
+    }
+    else if( GDALGetMetadataItem( hDriver, GDAL_DCAP_CREATE, nullptr ) == nullptr )
+    {
+        printf( "Output driver '%s' does not support direct creation.\n",
+                pszFormat );
+        hDriver = nullptr;
+    }
+
+    if( hDriver == nullptr )
+    {
+        printf( "The following format drivers are configured and support output:\n" );
+        for( int iDr = 0; iDr < GDALGetDriverCount(); iDr++ )
+        {
+            GDALDriverH hDriver = GDALGetDriver(iDr);
+
+            if( GDALGetMetadataItem( hDriver, GDAL_DCAP_CREATE, nullptr ) != nullptr )
+            {
+                printf( "  %s: %s\n",
+                        GDALGetDriverShortName( hDriver  ),
+                        GDALGetDriverLongName( hDriver ) );
+            }
+        }
+        printf( "\n" );
+        Usage();
+
+        GDALClose( hSrcDS );
+        CPLFree( panBandList );
+        GDALDestroyDriverManager();
+        CSLDestroy( argv );
+        CSLDestroy( papszCreateOptions );
+        exit( 1 );
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Establish the pixel data type to use.                           */
+/* -------------------------------------------------------------------- */
+    if( eOutputType == GDT_Unknown )
+        eOutputType = poSrcDS->GetRasterBand(1)->GetRasterDataType();
+
+/* -------------------------------------------------------------------- */
+/*      Allocate one big buffer for the whole imagery area to           */
+/*      transfer.                                                       */
+/* -------------------------------------------------------------------- */
+    const int nBytesPerPixel =
+        nBandCount * GDALGetDataTypeSizeBytes(eOutputType);
+    void *pImage = VSIMalloc3(nOXSize, nOYSize, nBytesPerPixel);
+
+    if( pImage == nullptr )
+    {
+        printf( "Unable to allocate %dx%dx%d byte window buffer.\n",
+                nOXSize, nOYSize, nBytesPerPixel );
+        exit( 1 );
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Establish view window                                           */
+/* -------------------------------------------------------------------- */
+    int nPixelSpace = nBytesPerPixel;
+    int nLineSpace = nBytesPerPixel * nOXSize;
+    int nBandSpace = nBytesPerPixel / nBandCount;
+
+    GDALAsyncReader *poAsyncReq
+        = poSrcDS->BeginAsyncReader(
+        anSrcWin[0], anSrcWin[1], anSrcWin[2], anSrcWin[3],
+        pImage, nOXSize, nOYSize, eOutputType,
+        nBandCount, panBandList,
+        nPixelSpace, nLineSpace, nBandSpace, papszAsyncOptions );
+
+    if( poAsyncReq == nullptr )
+        exit( 1 );
+
+/* -------------------------------------------------------------------- */
+/*      Process until done or an error.                                 */
+/* -------------------------------------------------------------------- */
+    GDALAsyncStatusType eAStatus;
+    CPLErr eErr = CE_None;
+    int iMultiCounter = 0;
+
+    hDstDS = nullptr;
+
+    do
+    {
+/* ==================================================================== */
+/*      Create the output file, and initialize if needed.               */
+/* ==================================================================== */
+        if( hDstDS == nullptr )
+        {
+            CPLString osOutFilename = pszDest;
+
+            if( bMulti )
+                osOutFilename.Printf( "%s_%d", pszDest, iMultiCounter++ );
+
+            hDstDS = GDALCreate( hDriver, osOutFilename, nOXSize, nOYSize,
+                                 nBandCount, eOutputType,
+                                 papszCreateOptions );
+            if (hDstDS == nullptr)
+            {
+                exit(1);
+            }
+
+            poDstDS = (GDALDataset *) hDstDS;
+
+/* -------------------------------------------------------------------- */
+/*      Copy georeferencing.                                            */
+/* -------------------------------------------------------------------- */
+            double adfGeoTransform[6];
+
+            if( poSrcDS->GetGeoTransform( adfGeoTransform ) == CE_None )
+            {
+                adfGeoTransform[0] += anSrcWin[0] * adfGeoTransform[1]
+                    + anSrcWin[1] * adfGeoTransform[2];
+                adfGeoTransform[3] += anSrcWin[0] * adfGeoTransform[4]
+                    + anSrcWin[1] * adfGeoTransform[5];
+
+                adfGeoTransform[1] *= anSrcWin[2] / (double) nOXSize;
+                adfGeoTransform[2] *= anSrcWin[3] / (double) nOYSize;
+                adfGeoTransform[4] *= anSrcWin[2] / (double) nOXSize;
+                adfGeoTransform[5] *= anSrcWin[3] / (double) nOYSize;
+
+                poDstDS->SetGeoTransform( adfGeoTransform );
+            }
+
+            poDstDS->SetProjection( poSrcDS->GetProjectionRef() );
+
+/* -------------------------------------------------------------------- */
+/*      Transfer generally applicable metadata.                         */
+/* -------------------------------------------------------------------- */
+            poDstDS->SetMetadata( poSrcDS->GetMetadata() );
+        }
+
+/* ==================================================================== */
+/*      Fetch an update and write it to the output file.                */
+/* ==================================================================== */
+
+        int nUpXOff;
+        int nUpYOff;
+        int nUpXSize;
+        int nUpYSize;
+
+        eAStatus = poAsyncReq->GetNextUpdatedRegion( dfTimeout,
+                                                     &nUpXOff, &nUpYOff,
+                                                     &nUpXSize, &nUpYSize );
+
+        if( eAStatus != GARIO_UPDATE && eAStatus != GARIO_COMPLETE )
+            continue;
+
+        if( !bQuiet )
+        {
+            printf( "Got %dx%d @ (%d,%d)\n",
+                    nUpXSize, nUpYSize, nUpXOff, nUpYOff );
+        }
+
+        poAsyncReq->LockBuffer();
+        eErr =
+            poDstDS->RasterIO( GF_Write, nUpXOff, nUpYOff, nUpXSize, nUpYSize,
+                               ((GByte *) pImage)
+                               + nUpXOff * nPixelSpace
+                               + nUpYOff * nLineSpace,
+                               nUpXSize, nUpYSize, eOutputType,
+                               nBandCount, nullptr,
+                               nPixelSpace, nLineSpace, nBandSpace, nullptr );
+        poAsyncReq->UnlockBuffer();
+
+/* -------------------------------------------------------------------- */
+/*      In multi mode we will close this file and reopen another for    */
+/*      the next request.                                               */
+/* -------------------------------------------------------------------- */
+        if( bMulti )
+        {
+            GDALClose( hDstDS );
+            hDstDS = nullptr;
+        }
+        else
+        {
+            GDALFlushCache( hDstDS );
+        }
+    } while( eAStatus != GARIO_ERROR && eAStatus != GARIO_COMPLETE
+             && eErr == CE_None );
+
+    poSrcDS->EndAsyncReader( poAsyncReq );
+
+/* -------------------------------------------------------------------- */
+/*      Cleanup.                                                        */
+/* -------------------------------------------------------------------- */
+    VSIFree( pImage );
+
+    if( hDstDS )
+        GDALClose( hDstDS );
+
+    GDALClose( hSrcDS );
+
+    CPLFree( panBandList );
+
+    CSLDestroy( argv );
+    CSLDestroy( papszCreateOptions );
+    CSLDestroy( papszAsyncOptions );
+
+    GDALDumpOpenDatasets( stderr );
+    GDALDestroyDriverManager();
+}
diff -Nru gdal-3.6.1-orig/apps/gdalflattenmask.c gdal-3.6.1-patched/apps/gdalflattenmask.c
--- gdal-3.6.1-orig/apps/gdalflattenmask.c	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/apps/gdalflattenmask.c	2023-01-03 06:32:17.401842279 -0500
@@ -29,6 +29,7 @@
 #include "gdal.h"
 #include "cpl_conv.h"
 #include "cpl_string.h"
+#include "commonutils.h"
 
 
 /************************************************************************/
@@ -54,7 +55,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main(int argc, char* argv[])
+MAIN_START(argc, argv)
 {
     const char* pszFormat = "GTiff";
     const char* pszSrcFilename = NULL;
@@ -337,3 +338,4 @@
 
     return 0;
 }
+MAIN_END
diff -Nru gdal-3.6.1-orig/apps/gdalflattenmask.c.orig gdal-3.6.1-patched/apps/gdalflattenmask.c.orig
--- gdal-3.6.1-orig/apps/gdalflattenmask.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.6.1-patched/apps/gdalflattenmask.c.orig	2022-12-13 18:02:35.000000000 -0500
@@ -0,0 +1,339 @@
+/******************************************************************************
+ *
+ * Project:  GDAL Utilities
+ * Purpose:  GDAL mask flattening utility
+ * Author:   Even Rouault, <even dot rouault at spatialys.com>
+ *
+ ******************************************************************************
+ * Copyright (c) 2008-2010, Even Rouault <even dot rouault at spatialys.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ ****************************************************************************/
+
+#include "gdal.h"
+#include "cpl_conv.h"
+#include "cpl_string.h"
+
+
+/************************************************************************/
+/*                               Usage()                                */
+/************************************************************************/
+
+static void Usage()
+{
+    printf( "Usage: gdalflattenmask [--help-general] [-of output_format] \n"
+            "                       [-co \"NAME=VALUE\"]* [-set_alpha] [-a_nodata val] \n"
+            "                       srcdatasetname dstdatasetname\n"
+            "\n"
+            "This utility is intended to produce a new file that merges regular data\n"
+            "bands with the mask bands, for applications not being able to use the mask band concept.\n"
+            "* If -set_alpha is not specified, this utility will use the mask band(s)\n"
+            "  to create a new dataset with empty values where the mask has null values.\n"
+            "* If -set_alpha is specified, a new alpha band is added to the destination\n"
+            "  dataset with the content of the global dataset mask band.\n");
+    exit( 1 );
+}
+
+/************************************************************************/
+/*                                main()                                */
+/************************************************************************/
+
+int main(int argc, char* argv[])
+{
+    const char* pszFormat = "GTiff";
+    const char* pszSrcFilename = NULL;
+    const char* pszDstFilename = NULL;
+    int i;
+    int nBands, nXSize, nYSize;
+    GDALDriverH hDriver;
+    GDALDatasetH hSrcDS;
+    GDALDatasetH hDstDS;
+    char** papszCreateOptions = NULL;
+    int bSetNoData = FALSE;
+    double dfDstNoData = 0;
+    int bSetAlpha = FALSE;
+    double adfGeoTransform[6];
+    const char* pszProjectionRef;
+    GByte* pabyMaskBuffer;
+    char** papszMetadata;
+
+    GDALAllRegister();
+
+    argc = GDALGeneralCmdLineProcessor( argc, &argv, 0 );
+    if( argc < 1 )
+        exit( -argc );
+
+/* -------------------------------------------------------------------- */
+/*      Parse arguments.                                                */
+/* -------------------------------------------------------------------- */
+    for( i = 1; i < argc; i++ )
+    {
+        if( EQUAL(argv[i], "-of") && i + 1 < argc)
+        {
+            pszFormat = argv[++i];
+        }
+        else if( EQUAL(argv[i],"-co") && i < argc-1 )
+        {
+            papszCreateOptions = CSLAddString( papszCreateOptions, argv[++i] );
+        }
+        else if( EQUAL(argv[i],"-a_nodata") && i < argc - 1 )
+        {
+            bSetNoData = TRUE;
+            dfDstNoData = CPLAtof(argv[++i]);
+        }
+        else if( EQUAL(argv[i], "-set_alpha"))
+        {
+            bSetAlpha = TRUE;
+        }
+        else if ( argv[i][0] == '-')
+            Usage();
+        else if( pszSrcFilename == NULL )
+            pszSrcFilename = argv[i];
+        else if(  pszDstFilename == NULL )
+            pszDstFilename = argv[i];
+        else
+            Usage();
+    }
+
+    if( pszSrcFilename == NULL || pszDstFilename == NULL)
+        Usage();
+
+/* -------------------------------------------------------------------- */
+/*      Open source dataset                                             */
+/* -------------------------------------------------------------------- */
+    hSrcDS = GDALOpen(pszSrcFilename, GA_ReadOnly);
+    if (hSrcDS == NULL)
+    {
+        fprintf(stderr, "Can't open %s\n", pszSrcFilename);
+        exit(1);
+    }
+
+    nBands = GDALGetRasterCount(hSrcDS);
+    nXSize = GDALGetRasterXSize(hSrcDS);
+    nYSize = GDALGetRasterYSize(hSrcDS);
+
+    for(i = 0; i < nBands; i++)
+    {
+        GDALRasterBandH hSrcBand = GDALGetRasterBand(hSrcDS, i+1);
+        GDALDataType  eDataType = GDALGetRasterDataType(hSrcBand);
+
+        if (bSetAlpha)
+        {
+            if (nBands > 1 && (GDALGetMaskFlags(hSrcBand) & GMF_PER_DATASET) == 0)
+            {
+                fprintf(stderr, "When -set_alpha is specified, all source bands must "
+                                "share the same mask band (PER_DATASET mask)\n");
+                exit(1);
+            }
+            if (GDALGetRasterColorInterpretation(hSrcBand) == GCI_AlphaBand)
+            {
+                fprintf(stderr, "The source dataset has already an alpha band\n");
+                exit(1);
+            }
+        }
+
+        if (eDataType != GDT_Byte)
+        {
+            fprintf(stderr, "Only GDT_Byte type supported for source dataset\n");
+            exit(1);
+        }
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Create destination dataset                                      */
+/* -------------------------------------------------------------------- */
+    hDriver = GDALGetDriverByName(pszFormat);
+    if (hDriver == NULL)
+    {
+        fprintf(stderr, "Can't find driver %s\n", pszFormat);
+        exit(1);
+    }
+
+    hDstDS = GDALCreate(hDriver,
+                        pszDstFilename,
+                        nXSize,
+                        nYSize,
+                        nBands + ((bSetAlpha) ? 1 : 0),
+                        GDT_Byte,
+                        papszCreateOptions);
+    if (hDstDS == NULL)
+    {
+        fprintf(stderr, "Can't create %s\n", pszDstFilename);
+        exit(1);
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Write geotransform, projection, color interpretations, no data  */
+/*      values, color tables, metadata, etc. before the file is         */
+/*      crystallized.                                                   */
+/* -------------------------------------------------------------------- */
+    if( GDALGetGeoTransform( hSrcDS, adfGeoTransform ) == CE_None )
+    {
+        GDALSetGeoTransform( hDstDS, adfGeoTransform );
+    }
+
+    pszProjectionRef = GDALGetProjectionRef( hSrcDS );
+    if (pszProjectionRef && pszProjectionRef[0])
+    {
+        GDALSetProjection( hDstDS, pszProjectionRef );
+    }
+
+    if (bSetAlpha)
+    {
+        GDALRasterBandH hDstAlphaBand = GDALGetRasterBand(hDstDS, nBands+1);
+        GDALSetRasterColorInterpretation( hDstAlphaBand, GCI_AlphaBand);
+    }
+
+    papszMetadata = GDALGetMetadata(hSrcDS, NULL);
+    GDALSetMetadata(hDstDS, papszMetadata, NULL);
+
+    for(i = 0; i < nBands; i++)
+    {
+        GDALRasterBandH hSrcBand, hDstBand;
+        GDALColorTableH hColorTable;
+        GDALColorInterp eColorInterpretation;
+        int bHasNoData;
+        double dfNoDataValue;
+
+        hSrcBand = GDALGetRasterBand(hSrcDS, i+1);
+        hDstBand = GDALGetRasterBand(hDstDS, i+1);
+
+        dfNoDataValue = GDALGetRasterNoDataValue(hSrcBand, &bHasNoData);
+        if (!bHasNoData)
+            dfNoDataValue = dfDstNoData;
+        if (!bSetAlpha && (bHasNoData || bSetNoData))
+            GDALSetRasterNoDataValue(hDstBand, dfNoDataValue);
+
+        hColorTable = GDALGetRasterColorTable( hSrcBand );
+        if (hColorTable)
+        {
+            GDALSetRasterColorTable(hDstBand, hColorTable);
+        }
+
+        papszMetadata = GDALGetMetadata(hSrcBand, NULL);
+        GDALSetMetadata(hDstBand, papszMetadata, NULL);
+
+        eColorInterpretation = GDALGetRasterColorInterpretation( hSrcBand );
+        GDALSetRasterColorInterpretation( hDstBand, eColorInterpretation );
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Write the data values now                                       */
+/* -------------------------------------------------------------------- */
+    pabyMaskBuffer = (GByte*)CPLMalloc(nXSize);
+
+    for(i = 0; i < nBands; i++)
+    {
+        GDALRasterBandH hSrcBand, hDstBand, hMaskBand;
+        GDALDataType  eDataType;
+        GByte* pabyBuffer;
+        int iCol, iLine;
+        int bHasNoData;
+        double dfNoDataValue;
+        int nMaskFlag;
+
+        hSrcBand = GDALGetRasterBand(hSrcDS, i+1);
+        hDstBand = GDALGetRasterBand(hDstDS, i+1);
+        hMaskBand = GDALGetMaskBand(hSrcBand);
+        nMaskFlag = GDALGetMaskFlags(hSrcBand);
+
+        eDataType = GDALGetRasterDataType(hSrcBand);
+        pabyBuffer = (GByte*)CPLMalloc(nXSize * GDALGetDataTypeSize(eDataType));
+        dfNoDataValue = GDALGetRasterNoDataValue(hSrcBand, &bHasNoData);
+        if (!bHasNoData)
+            dfNoDataValue = dfDstNoData;
+
+        for(iLine = 0; iLine < nYSize; iLine++)
+        {
+            GDALRasterIO( hSrcBand, GF_Read, 0, iLine, nXSize, 1,
+                          pabyBuffer, nXSize, 1, eDataType, 0, 0);
+            if (!bSetAlpha)
+            {
+                GDALRasterIO( hMaskBand, GF_Read, 0, iLine, nXSize, 1,
+                              pabyMaskBuffer, nXSize, 1, GDT_Byte, 0, 0);
+                switch (eDataType)
+                {
+                    case GDT_Byte:
+                    {
+                        for(iCol = 0; iCol < nXSize; iCol++)
+                        {
+                            /* If the mask is 1-bit and the value is 0,
+                               or if the mask is 8-bit and the value < 128,
+                               then replace the value of the pixel by the transparent value */
+                            if (pabyMaskBuffer[iCol] == 0 ||
+                                ((nMaskFlag & GMF_ALPHA) != 0 && pabyMaskBuffer[iCol] < 128))
+                                pabyBuffer[iCol] = (GByte)dfNoDataValue;
+                        }
+                        break;
+                    }
+
+                    default:
+                        CPLAssert(false);
+                        break;
+                }
+            }
+
+            GDALRasterIO( hDstBand, GF_Write, 0, iLine, nXSize, 1,
+                          pabyBuffer, nXSize, 1, eDataType, 0, 0);
+        }
+
+        CPLFree(pabyBuffer);
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Create the alpha band if -set_alpha is specified                */
+/* -------------------------------------------------------------------- */
+    if (bSetAlpha)
+    {
+        GDALRasterBandH hSrcBand = GDALGetRasterBand(hSrcDS, 1);
+        GDALRasterBandH hDstAlphaBand = GDALGetRasterBand(hDstDS, nBands+1);
+        GDALRasterBandH hMaskBand = GDALGetMaskBand(hSrcBand);
+        int nMaskFlag = GDALGetMaskFlags(hSrcBand);
+
+        int iCol;
+        int iLine;
+        for(iLine = 0; iLine < nYSize; iLine++)
+        {
+            GDALRasterIO( hMaskBand, GF_Read, 0, iLine, nXSize, 1,
+                          pabyMaskBuffer, nXSize, 1, GDT_Byte, 0, 0);
+            for(iCol = 0; iCol < nXSize; iCol++)
+            {
+                /* If the mask is 1-bit, expand 1 to 255 */
+                if (pabyMaskBuffer[iCol] == 1 && (nMaskFlag & GMF_ALPHA) == 0)
+                    pabyMaskBuffer[iCol] = 255;
+            }
+            GDALRasterIO( hDstAlphaBand, GF_Write, 0, iLine, nXSize, 1,
+                          pabyMaskBuffer, nXSize, 1, GDT_Byte, 0, 0);
+        }
+    }
+
+/************************************************************************/
+/*      Cleanup                                                         */
+/* -------------------------------------------------------------------- */
+    CPLFree(pabyMaskBuffer);
+
+    GDALClose(hSrcDS);
+    GDALClose(hDstDS);
+    GDALDumpOpenDatasets( stderr );
+    GDALDestroyDriverManager();
+    CSLDestroy( argv );
+    CSLDestroy( papszCreateOptions );
+
+    return 0;
+}
diff -Nru gdal-3.6.1-orig/apps/gdaltorture.cpp gdal-3.6.1-patched/apps/gdaltorture.cpp
--- gdal-3.6.1-orig/apps/gdaltorture.cpp	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/apps/gdaltorture.cpp	2023-01-03 06:32:17.401842279 -0500
@@ -29,6 +29,7 @@
 #include "gdal.h"
 #include "cpl_string.h"
 #include "cpl_conv.h"
+#include "commonutils.h"
 
 #include <cassert>
 
@@ -236,7 +237,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main( int argc, char **argv )
+MAIN_START(argc, argv)
 {
     GDALAllRegister();
 
@@ -291,3 +292,4 @@
 
     return 0;
 }
+MAIN_END
\ No newline at end of file
diff -Nru gdal-3.6.1-orig/apps/gdaltorture.cpp.orig gdal-3.6.1-patched/apps/gdaltorture.cpp.orig
--- gdal-3.6.1-orig/apps/gdaltorture.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.6.1-patched/apps/gdaltorture.cpp.orig	2022-12-13 18:02:35.000000000 -0500
@@ -0,0 +1,293 @@
+/******************************************************************************
+ *
+ * Project:  GDAL Utilities
+ * Purpose:  Command line utility to torture GDAL API on datasets
+ * Author:   Even Rouault, <even dot rouault at spatialys.com>
+ *
+ ******************************************************************************
+ * Copyright (c) 2008-2011, Even Rouault <even dot rouault at spatialys.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ ****************************************************************************/
+
+#include "gdal.h"
+#include "cpl_string.h"
+#include "cpl_conv.h"
+
+#include <cassert>
+
+
+/************************************************************************/
+/*                               Usage()                                */
+/************************************************************************/
+
+static void Usage()
+
+{
+    printf("Usage: gdaltorture [-r] [-u] [-rw] files*\n");
+    exit(1);
+}
+
+/************************************************************************/
+/*                              TortureDS()                             */
+/************************************************************************/
+
+static void TortureBand( GDALRasterBandH hBand, int /* bReadWriteOperations */,
+                         int nRecurse )
+{
+    if( nRecurse > 5 )
+        return;
+
+    GDALGetRasterDataType(hBand);
+    int nBlockXSize;
+    int nBlockYSize;
+    GDALGetBlockSize(hBand, &nBlockXSize, &nBlockYSize);
+    // GDALRasterAdviseRead
+    // GDALRasterIO
+    // GDALReadBlock
+    // GDALWriteBlock
+    const int nRasterXSize = GDALGetRasterBandXSize(hBand);
+    assert(nRasterXSize >= 0);
+    const int nRasterYSize = GDALGetRasterBandYSize(hBand);
+    assert(nRasterYSize >= 0);
+    GDALGetRasterAccess(hBand);
+    GDALGetBandNumber(hBand);
+    GDALGetBandDataset(hBand);
+    GDALGetRasterColorInterpretation(hBand);
+    // GDALSetRasterColorInterpretation
+    GDALGetRasterColorTable(hBand);
+    // GDALSetRasterColorTable
+    GDALHasArbitraryOverviews (hBand);
+
+    const int nOverviewCount = GDALGetOverviewCount(hBand);
+    for(int iOverview=0;iOverview<nOverviewCount;iOverview++)
+    {
+        GDALRasterBandH hOverviewBand = GDALGetOverview(hBand, iOverview);
+        if( hOverviewBand )
+            TortureBand(hOverviewBand, false, nRecurse + 1);
+    }
+
+    int bHasNoData;
+    GDALGetRasterNoDataValue(hBand, &bHasNoData);
+    // GDALSetRasterNoDataValue
+    GDALGetRasterCategoryNames(hBand);
+    // GDALSetRasterCategoryNames
+    int bSuccess;
+    GDALGetRasterMinimum(hBand, &bSuccess);
+    GDALGetRasterMaximum(hBand, &bSuccess);
+    double dfMin, dfMax, dfMean, dfStdDev;
+    GDALGetRasterStatistics(hBand, TRUE, FALSE, &dfMin, &dfMax,
+                            &dfMean, &dfStdDev);
+    // GDALComputeRasterStatistics
+    // GDALSetRasterStatistics
+    GDALGetRasterUnitType(hBand);
+    GDALGetRasterOffset(hBand, &bSuccess);
+    // GDALSetRasterOffset
+    GDALGetRasterScale(hBand, &bSuccess);
+    // GDALSetRasterScale
+    // double adfMinMax[2];
+    // GDALComputeRasterMinMax(hBand, TRUE, adfMinMax);
+    // GDALFlushRasterCache(hBand)
+    // GDALGetDefaultHistogram(
+    //     GDALRasterBandH hBand, double *pdfMin, double *pdfMax,
+    //     int *pnBuckets, int **ppanHistogram, int bForce,
+    //     GDALProgressFunc pfnProgress, void *pProgressData);
+    // GDALSetDefaultHistogram(
+    //     GDALRasterBandH hBand, double dfMin, double dfMax,
+    //     int nBuckets, int *panHistogram);
+    float afSampleBuf;
+    GDALGetRandomRasterSample(hBand, 1, &afSampleBuf);
+    GDALGetRasterSampleOverview(hBand, 0); // returns a hBand
+    // GDALFillRaster
+    // GDALComputeBandStats
+    // GDALOverviewMagnitudeCorrection
+    GDALGetDefaultRAT(hBand);
+    // GDALSetDefaultRAT
+    // GDALAddDerivedBandPixelFunc
+    GDALRasterBandH hMaskBand = GDALGetMaskBand(hBand);
+    if( hMaskBand != hBand )
+        TortureBand(hMaskBand, false, nRecurse + 1);
+    GDALGetMaskFlags(hBand);
+    // GDALCreateMaskBand
+}
+
+/************************************************************************/
+/*                              TortureDS()                             */
+/************************************************************************/
+
+static void TortureDS( const char *pszTarget, bool bReadWriteOperations )
+{
+    // hDS = GDALOpen(pszTarget, GA_Update);
+    // GDALClose(hDS);
+
+    GDALDatasetH hDS = GDALOpen(pszTarget, GA_ReadOnly);
+    if( hDS == nullptr )
+        return;
+
+    // GDALGetMetadata(GDALMajorObjectH, const char *);
+    // GDALSetMetadata(GDALMajorObjectH, char **, const char *);
+    // GDALGetMetadataItem(GDALMajorObjectH, const char *, const char *);
+    // GDALSetMetadataItem(GDALMajorObjectH, const char *, const char *,
+    //                     const char *);
+    GDALGetDescription(hDS);
+    //GDALSetDescription
+    GDALGetDatasetDriver(hDS);
+    char **papszFileList = GDALGetFileList(hDS);
+    CSLDestroy(papszFileList);
+    const int nXSize = GDALGetRasterXSize(hDS);
+    assert(nXSize >= 0);
+    const int nYSize = GDALGetRasterYSize(hDS);
+    assert(nYSize >= 0);
+    const int nBands = GDALGetRasterCount(hDS);
+    // GDALAddBand
+    // GDALDatasetRasterIO
+    GDALGetProjectionRef(hDS);
+    // GDALSetProjection
+    double adfGeotransform[6] = {};
+    GDALGetGeoTransform(hDS, adfGeotransform);
+    // GDALSetGeoTransform
+    GDALGetGCPCount(hDS);
+    GDALGetGCPProjection(hDS);
+    GDALGetGCPs(hDS);
+    // GDALSetGCPs
+    // GDALGetInternalHandle
+    GDALReferenceDataset(hDS);
+    GDALDereferenceDataset(hDS);
+    // GDALBuildOverviews
+    GDALGetAccess(hDS);
+    // GDALFlushCache
+    // GDALCreateDatasetMaskBand
+    // GDALDatasetCopyWholeRaster
+
+    for( int iBand = 0; iBand < nBands; iBand++ )
+    {
+        GDALRasterBandH hBand = GDALGetRasterBand(hDS, iBand + 1);
+        if( hBand == nullptr )
+            continue;
+
+        TortureBand(hBand, bReadWriteOperations, 0);
+    }
+
+    GDALClose(hDS);
+}
+
+/************************************************************************/
+/*                       ProcessTortureTarget()                         */
+/************************************************************************/
+
+static void ProcessTortureTarget( const char *pszTarget,
+                                  char **papszSiblingList,
+                                  bool bRecursive, bool bReportFailures,
+                                  bool bReadWriteOperations )
+{
+    GDALDriverH hDriver = GDALIdentifyDriver(pszTarget, papszSiblingList);
+
+    if( hDriver != nullptr )
+    {
+        printf("%s: %s\n", pszTarget, GDALGetDriverShortName(hDriver));
+        TortureDS(pszTarget, bReadWriteOperations);
+    }
+    else if( bReportFailures )
+    {
+        printf("%s: unrecognized\n", pszTarget);
+    }
+
+    if( !bRecursive || hDriver != nullptr )
+        return;
+
+    VSIStatBufL sStatBuf;
+    if( VSIStatL(pszTarget, &sStatBuf) != 0 ||
+        !VSI_ISDIR(sStatBuf.st_mode) )
+        return;
+
+    papszSiblingList = VSIReadDir(pszTarget);
+    for( int i = 0; papszSiblingList && papszSiblingList[i]; i++ )
+    {
+        if( EQUAL(papszSiblingList[i],"..") ||
+            EQUAL(papszSiblingList[i],".") )
+            continue;
+
+        const CPLString osSubTarget =
+            CPLFormFilename(pszTarget, papszSiblingList[i], nullptr);
+
+        ProcessTortureTarget(osSubTarget, papszSiblingList,
+                             bRecursive, bReportFailures, bReadWriteOperations);
+    }
+    CSLDestroy(papszSiblingList);
+}
+
+/************************************************************************/
+/*                                main()                                */
+/************************************************************************/
+
+int main( int argc, char **argv )
+{
+    GDALAllRegister();
+
+    argc = GDALGeneralCmdLineProcessor(argc, &argv, 0);
+    if( argc < 1 )
+        exit(-argc);
+
+    if( argc < 2 )
+        Usage();
+
+/* -------------------------------------------------------------------- */
+/*      Scan for command line switches                                   */
+/* -------------------------------------------------------------------- */
+    char** papszArgv = argv + 1;
+    argc--;
+
+    bool bRecursive = false;
+    bool bReportFailures = false;
+    bool bReadWriteOperations = false;
+
+    while( argc > 0 && papszArgv[0][0] == '-' )
+    {
+        if( EQUAL(papszArgv[0], "-r") )
+            bRecursive = true;
+        else if( EQUAL(papszArgv[0], "-u") )
+            bReportFailures = true;
+        else if( EQUAL(papszArgv[0], "-rw") )
+            bReadWriteOperations = true;
+        else
+            Usage();
+
+        papszArgv++;
+        argc--;
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Process given files.                                            */
+/* -------------------------------------------------------------------- */
+    while( argc > 0 )
+    {
+        ProcessTortureTarget(papszArgv[0], nullptr,
+                             bRecursive, bReportFailures, bReadWriteOperations);
+        argc--;
+        papszArgv++;
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Cleanup                                                         */
+/* -------------------------------------------------------------------- */
+    CSLDestroy(argv);
+    GDALDestroyDriverManager();
+
+    return 0;
+}
diff -Nru gdal-3.6.1-orig/apps/gdalwarpsimple.c gdal-3.6.1-patched/apps/gdalwarpsimple.c
--- gdal-3.6.1-orig/apps/gdalwarpsimple.c	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/apps/gdalwarpsimple.c	2023-01-03 06:32:17.401842279 -0500
@@ -31,6 +31,7 @@
 #include "gdal_alg.h"
 #include "cpl_string.h"
 #include "ogr_srs_api.h"
+#include "commonutils.h"
 
 
 static GDALDatasetH
@@ -90,7 +91,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main( int argc, char ** argv )
+MAIN_START(argc, argv)
 
 {
     GDALDatasetH        hSrcDS, hDstDS;
@@ -312,6 +313,7 @@
 
     exit( 0 );
 }
+MAIN_END
 
 /************************************************************************/
 /*                        GDALWarpCreateOutput()                        */
diff -Nru gdal-3.6.1-orig/apps/gdalwarpsimple.c.orig gdal-3.6.1-patched/apps/gdalwarpsimple.c.orig
--- gdal-3.6.1-orig/apps/gdalwarpsimple.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.6.1-patched/apps/gdalwarpsimple.c.orig	2022-12-13 18:02:35.000000000 -0500
@@ -0,0 +1,472 @@
+/******************************************************************************
+ *
+ * Project:  Mapinfo Image Warper
+ * Purpose:  Commandline program for doing a variety of image warps, including
+ *           image reprojection.
+ * Author:   Frank Warmerdam <warmerdam@pobox.com>
+ *
+ ******************************************************************************
+ * Copyright (c) 2002, i3 - information integration and imaging
+ *                          Fort Collin, CO
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ ****************************************************************************/
+
+#include "gdal_alg.h"
+#include "cpl_string.h"
+#include "ogr_srs_api.h"
+
+
+static GDALDatasetH
+GDALWarpCreateOutput( GDALDatasetH hSrcDS, const char *pszFilename,
+                      const char *pszFormat, const char *pszSourceSRS,
+                      const char *pszTargetSRS, int nOrder,
+                      char **papszCreateOptions );
+
+static double          dfMinX=0.0, dfMinY=0.0, dfMaxX=0.0, dfMaxY=0.0;
+static double          dfXRes=0.0, dfYRes=0.0;
+static int             nForcePixels=0, nForceLines=0;
+
+/************************************************************************/
+/*                               Usage()                                */
+/************************************************************************/
+
+static void Usage()
+
+{
+    printf(
+        "Usage: gdalwarpsimple [--version] [--formats]\n"
+        "    [-s_srs srs_def] [-t_srs srs_def] [-order n] [-et err_threshold]\n"
+        "    [-te xmin ymin xmax ymax] [-tr xres yres] [-ts width height]\n"
+        "    [-of format] [-co \"NAME=VALUE\"]* srcfile dstfile\n" );
+    exit( 1 );
+}
+
+/************************************************************************/
+/*                             SanitizeSRS                              */
+/************************************************************************/
+
+char *SanitizeSRS( const char *pszUserInput )
+
+{
+    OGRSpatialReferenceH hSRS;
+    char *pszResult = NULL;
+
+    CPLErrorReset();
+
+    hSRS = OSRNewSpatialReference( NULL );
+    if( OSRSetFromUserInput( hSRS, pszUserInput ) == OGRERR_NONE )
+        OSRExportToWkt( hSRS, &pszResult );
+    else
+    {
+        CPLError( CE_Failure, CPLE_AppDefined,
+                  "Translating source or target SRS failed:\n%s",
+                  pszUserInput );
+        exit( 1 );
+    }
+
+    OSRDestroySpatialReference( hSRS );
+
+    return pszResult;
+}
+
+/************************************************************************/
+/*                                main()                                */
+/************************************************************************/
+
+int main( int argc, char ** argv )
+
+{
+    GDALDatasetH        hSrcDS, hDstDS;
+    const char         *pszFormat = "GTiff";
+    char               *pszTargetSRS = NULL;
+    char               *pszSourceSRS = NULL;
+    const char         *pszSrcFilename = NULL, *pszDstFilename = NULL;
+    int                 bCreateOutput = FALSE, i, nOrder = 0;
+    void               *hTransformArg, *hGenImgProjArg=NULL, *hApproxArg=NULL;
+    char               **papszWarpOptions = NULL;
+    double             dfErrorThreshold = 0.125;
+    GDALTransformerFunc pfnTransformer = NULL;
+    char                **papszCreateOptions = NULL;
+
+    GDALAllRegister();
+
+/* -------------------------------------------------------------------- */
+/*      Parse arguments.                                                */
+/* -------------------------------------------------------------------- */
+    for( i = 1; i < argc; i++ )
+    {
+        if( EQUAL(argv[i],"--version") )
+        {
+            printf( "%s\n", GDALVersionInfo( "--version" ) );
+            exit( 0 );
+        }
+        else if( EQUAL(argv[i],"--formats") )
+        {
+            int iDr;
+
+            printf( "Supported Formats:\n" );
+            for( iDr = 0; iDr < GDALGetDriverCount(); iDr++ )
+            {
+                GDALDriverH hDriver = GDALGetDriver(iDr);
+
+                printf( "  %s: %s\n",
+                        GDALGetDriverShortName( hDriver ),
+                        GDALGetDriverLongName( hDriver ) );
+            }
+
+            exit( 0 );
+        }
+        else if( EQUAL(argv[i],"-co") && i < argc-1 )
+        {
+            papszCreateOptions = CSLAddString( papszCreateOptions, argv[++i] );
+            bCreateOutput = TRUE;
+        }
+        else if( EQUAL(argv[i],"-of") && i < argc-1 )
+        {
+            pszFormat = argv[++i];
+            bCreateOutput = TRUE;
+        }
+        else if( EQUAL(argv[i],"-t_srs") && i < argc-1 )
+        {
+            pszTargetSRS = SanitizeSRS(argv[++i]);
+        }
+        else if( EQUAL(argv[i],"-s_srs") && i < argc-1 )
+        {
+            pszSourceSRS = SanitizeSRS(argv[++i]);
+        }
+        else if( EQUAL(argv[i],"-order") && i < argc-1 )
+        {
+            nOrder = atoi(argv[++i]);
+        }
+        else if( EQUAL(argv[i],"-et") && i < argc-1 )
+        {
+            dfErrorThreshold = CPLAtof(argv[++i]);
+        }
+        else if( EQUAL(argv[i],"-tr") && i < argc-2 )
+        {
+            dfXRes = CPLAtof(argv[++i]);
+            dfYRes = fabs(CPLAtof(argv[++i]));
+            bCreateOutput = TRUE;
+        }
+        else if( EQUAL(argv[i],"-ts") && i < argc-2 )
+        {
+            nForcePixels = atoi(argv[++i]);
+            nForceLines = atoi(argv[++i]);
+            bCreateOutput = TRUE;
+        }
+        else if( EQUAL(argv[i],"-te") && i < argc-4 )
+        {
+            dfMinX = CPLAtof(argv[++i]);
+            dfMinY = CPLAtof(argv[++i]);
+            dfMaxX = CPLAtof(argv[++i]);
+            dfMaxY = CPLAtof(argv[++i]);
+            bCreateOutput = TRUE;
+        }
+        else if( argv[i][0] == '-' )
+            Usage();
+        else if( pszSrcFilename == NULL )
+            pszSrcFilename = argv[i];
+        else if( pszDstFilename == NULL )
+            pszDstFilename = argv[i];
+        else
+            Usage();
+    }
+
+    if( pszDstFilename == NULL )
+        Usage();
+
+/* -------------------------------------------------------------------- */
+/*      Open source dataset.                                            */
+/* -------------------------------------------------------------------- */
+    hSrcDS = GDALOpen( pszSrcFilename, GA_ReadOnly );
+
+    if( hSrcDS == NULL )
+        exit( 2 );
+
+/* -------------------------------------------------------------------- */
+/*      Check that there's at least one raster band                     */
+/* -------------------------------------------------------------------- */
+    if ( GDALGetRasterCount(hSrcDS) == 0 )
+    {
+        fprintf(stderr, "Input file %s has no raster bands.\n", pszSrcFilename );
+        exit( 2 );
+    }
+
+    if( pszSourceSRS == NULL )
+    {
+        if( GDALGetProjectionRef( hSrcDS ) != NULL
+            && strlen(GDALGetProjectionRef( hSrcDS )) > 0 )
+            pszSourceSRS = CPLStrdup(GDALGetProjectionRef( hSrcDS ));
+
+        else if( GDALGetGCPProjection( hSrcDS ) != NULL
+                 && strlen(GDALGetGCPProjection(hSrcDS)) > 0
+                 && GDALGetGCPCount( hSrcDS ) > 1 )
+            pszSourceSRS = CPLStrdup(GDALGetGCPProjection( hSrcDS ));
+        else
+            pszSourceSRS = CPLStrdup("");
+    }
+
+    if( pszTargetSRS == NULL )
+        pszTargetSRS = CPLStrdup(pszSourceSRS);
+
+/* -------------------------------------------------------------------- */
+/*      Does the output dataset already exist?                          */
+/* -------------------------------------------------------------------- */
+    CPLPushErrorHandler( CPLQuietErrorHandler );
+    hDstDS = GDALOpen( pszDstFilename, GA_Update );
+    CPLPopErrorHandler();
+
+    if( hDstDS != NULL && bCreateOutput )
+    {
+        fprintf( stderr,
+                 "Output dataset %s exists,\n"
+                 "but some commandline options were provided indicating a new dataset\n"
+                 "should be created.  Please delete existing dataset and run again.",
+                 pszDstFilename );
+        exit( 1 );
+    }
+
+/* -------------------------------------------------------------------- */
+/*      If not, we need to create it.                                   */
+/* -------------------------------------------------------------------- */
+    if( hDstDS == NULL )
+    {
+        hDstDS = GDALWarpCreateOutput( hSrcDS, pszDstFilename, pszFormat,
+                                       pszSourceSRS, pszTargetSRS, nOrder,
+                                       papszCreateOptions );
+        papszWarpOptions = CSLSetNameValue( papszWarpOptions, "INIT", "0" );
+        CSLDestroy( papszCreateOptions );
+        papszCreateOptions = NULL;
+    }
+
+    if( hDstDS == NULL )
+        exit( 1 );
+
+/* -------------------------------------------------------------------- */
+/*      Create a transformation object from the source to               */
+/*      destination coordinate system.                                  */
+/* -------------------------------------------------------------------- */
+    hTransformArg = hGenImgProjArg =
+        GDALCreateGenImgProjTransformer( hSrcDS, pszSourceSRS,
+                                         hDstDS, pszTargetSRS,
+                                         TRUE, 1000.0, nOrder );
+
+    if( hTransformArg == NULL )
+        exit( 1 );
+
+    pfnTransformer = GDALGenImgProjTransform;
+
+/* -------------------------------------------------------------------- */
+/*      Warp the transformer with a linear approximator unless the      */
+/*      acceptable error is zero.                                       */
+/* -------------------------------------------------------------------- */
+    if( dfErrorThreshold != 0.0 )
+    {
+        hTransformArg = hApproxArg =
+            GDALCreateApproxTransformer( GDALGenImgProjTransform,
+                                         hGenImgProjArg, dfErrorThreshold );
+        pfnTransformer = GDALApproxTransform;
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Now actually invoke the warper to do the work.                  */
+/* -------------------------------------------------------------------- */
+    GDALSimpleImageWarp( hSrcDS, hDstDS, 0, NULL,
+                         pfnTransformer, hTransformArg,
+                         GDALTermProgress, NULL, papszWarpOptions );
+
+    CSLDestroy( papszWarpOptions );
+
+    if( hApproxArg != NULL )
+        GDALDestroyApproxTransformer( hApproxArg );
+
+    if( hGenImgProjArg != NULL )
+        GDALDestroyGenImgProjTransformer( hGenImgProjArg );
+
+/* -------------------------------------------------------------------- */
+/*      Cleanup.                                                        */
+/* -------------------------------------------------------------------- */
+    GDALClose( hDstDS );
+    GDALClose( hSrcDS );
+
+    GDALDumpOpenDatasets( stderr );
+
+    GDALDestroyDriverManager();
+
+    exit( 0 );
+}
+
+/************************************************************************/
+/*                        GDALWarpCreateOutput()                        */
+/*                                                                      */
+/*      Create the output file based on various commandline options,    */
+/*      and the input file.                                             */
+/************************************************************************/
+
+static GDALDatasetH
+GDALWarpCreateOutput( GDALDatasetH hSrcDS, const char *pszFilename,
+                      const char *pszFormat, const char *pszSourceSRS,
+                      const char *pszTargetSRS, int nOrder,
+                      char **papszCreateOptions )
+
+{
+    GDALDriverH hDriver;
+    GDALDatasetH hDstDS;
+    void *hTransformArg;
+    double adfDstGeoTransform[6];
+    int nPixels=0, nLines=0;
+    GDALColorTableH hCT;
+
+/* -------------------------------------------------------------------- */
+/*      Find the output driver.                                         */
+/* -------------------------------------------------------------------- */
+    hDriver = GDALGetDriverByName( pszFormat );
+    if( hDriver == NULL
+        || GDALGetMetadataItem( hDriver, GDAL_DCAP_CREATE, NULL ) == NULL )
+    {
+        int iDr;
+
+        printf( "Output driver `%s' not recognised or does not support\n",
+                pszFormat );
+        printf( "direct output file creation.  The following format drivers are configured\n"
+                "and support direct output:\n" );
+
+        for( iDr = 0; iDr < GDALGetDriverCount(); iDr++ )
+        {
+            GDALDriverH hDriver = GDALGetDriver(iDr);
+
+            if( GDALGetMetadataItem( hDriver, GDAL_DCAP_CREATE, NULL) != NULL )
+            {
+                printf( "  %s: %s\n",
+                        GDALGetDriverShortName( hDriver  ),
+                        GDALGetDriverLongName( hDriver ) );
+            }
+        }
+        printf( "\n" );
+        exit( 1 );
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Create a transformation object from the source to               */
+/*      destination coordinate system.                                  */
+/* -------------------------------------------------------------------- */
+    hTransformArg =
+        GDALCreateGenImgProjTransformer( hSrcDS, pszSourceSRS,
+                                         NULL, pszTargetSRS,
+                                         TRUE, 1000.0, nOrder );
+
+    if( hTransformArg == NULL )
+        return NULL;
+
+/* -------------------------------------------------------------------- */
+/*      Get approximate output definition.                              */
+/* -------------------------------------------------------------------- */
+    if( GDALSuggestedWarpOutput( hSrcDS,
+                                 GDALGenImgProjTransform, hTransformArg,
+                                 adfDstGeoTransform, &nPixels, &nLines )
+        != CE_None )
+        return NULL;
+
+    GDALDestroyGenImgProjTransformer( hTransformArg );
+
+/* -------------------------------------------------------------------- */
+/*      Did the user override some parameters?                          */
+/* -------------------------------------------------------------------- */
+    if( dfXRes != 0.0 && dfYRes != 0.0 )
+    {
+        CPLAssert( nPixels == 0 && nLines == 0 );
+        if( dfMinX == 0.0 && dfMinY == 0.0 && dfMaxX == 0.0 && dfMaxY == 0.0 )
+        {
+            dfMinX = adfDstGeoTransform[0];
+            dfMaxX = adfDstGeoTransform[0] + adfDstGeoTransform[1] * nPixels;
+            dfMaxY = adfDstGeoTransform[3];
+            dfMinY = adfDstGeoTransform[3] + adfDstGeoTransform[5] * nLines;
+        }
+
+        nPixels = (int) ((dfMaxX - dfMinX + (dfXRes/2.0)) / dfXRes);
+        nLines = (int) ((dfMaxY - dfMinY + (dfYRes/2.0)) / dfYRes);
+        adfDstGeoTransform[0] = dfMinX;
+        adfDstGeoTransform[3] = dfMaxY;
+        adfDstGeoTransform[1] = dfXRes;
+        adfDstGeoTransform[5] = -dfYRes;
+    }
+
+    else if( nForcePixels != 0 && nForceLines != 0 )
+    {
+        if( dfMinX == 0.0 && dfMinY == 0.0 && dfMaxX == 0.0 && dfMaxY == 0.0 )
+        {
+            dfMinX = adfDstGeoTransform[0];
+            dfMaxX = adfDstGeoTransform[0] + adfDstGeoTransform[1] * nPixels;
+            dfMaxY = adfDstGeoTransform[3];
+            dfMinY = adfDstGeoTransform[3] + adfDstGeoTransform[5] * nLines;
+        }
+
+        dfXRes = (dfMaxX - dfMinX) / nForcePixels;
+        dfYRes = (dfMaxY - dfMinY) / nForceLines;
+
+        adfDstGeoTransform[0] = dfMinX;
+        adfDstGeoTransform[3] = dfMaxY;
+        adfDstGeoTransform[1] = dfXRes;
+        adfDstGeoTransform[5] = -dfYRes;
+
+        nPixels = nForcePixels;
+        nLines = nForceLines;
+    }
+
+    else if( dfMinX != 0.0 || dfMinY != 0.0 || dfMaxX != 0.0 || dfMaxY != 0.0 )
+    {
+        dfXRes = adfDstGeoTransform[1];
+        dfYRes = fabs(adfDstGeoTransform[5]);
+
+        nPixels = (int) ((dfMaxX - dfMinX + (dfXRes/2.0)) / dfXRes);
+        nLines = (int) ((dfMaxY - dfMinY + (dfYRes/2.0)) / dfYRes);
+
+        adfDstGeoTransform[0] = dfMinX;
+        adfDstGeoTransform[3] = dfMaxY;
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Create the output file.                                         */
+/* -------------------------------------------------------------------- */
+    printf( "Creating output file is that %dP x %dL.\n", nPixels, nLines );
+
+    hDstDS = GDALCreate( hDriver, pszFilename, nPixels, nLines,
+                         GDALGetRasterCount(hSrcDS),
+                         GDALGetRasterDataType(GDALGetRasterBand(hSrcDS,1)),
+                         papszCreateOptions );
+
+    if( hDstDS == NULL )
+        return NULL;
+
+/* -------------------------------------------------------------------- */
+/*      Write out the projection definition.                            */
+/* -------------------------------------------------------------------- */
+    GDALSetProjection( hDstDS, pszTargetSRS );
+    GDALSetGeoTransform( hDstDS, adfDstGeoTransform );
+
+/* -------------------------------------------------------------------- */
+/*      Copy the color table, if required.                              */
+/* -------------------------------------------------------------------- */
+    hCT = GDALGetRasterColorTable( GDALGetRasterBand(hSrcDS,1) );
+    if( hCT != NULL )
+        GDALSetRasterColorTable( GDALGetRasterBand(hDstDS,1), hCT );
+
+    return hDstDS;
+}
diff -Nru gdal-3.6.1-orig/apps/multireadtest.cpp gdal-3.6.1-patched/apps/multireadtest.cpp
--- gdal-3.6.1-orig/apps/multireadtest.cpp	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/apps/multireadtest.cpp	2023-01-03 06:32:17.401842279 -0500
@@ -30,6 +30,7 @@
 #include "gdal_alg.h"
 #include "cpl_multiproc.h"
 #include "cpl_string.h"
+#include "commonutils.h"
 #include <vector>
 
 
@@ -120,8 +121,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main( int argc, char ** argv )
-
+MAIN_START(argc, argv)
 {
 /* -------------------------------------------------------------------- */
 /*      Process arguments.                                              */
@@ -253,3 +253,4 @@
 
     return 0;
 }
+MAIN_END
diff -Nru gdal-3.6.1-orig/apps/multireadtest.cpp.orig gdal-3.6.1-patched/apps/multireadtest.cpp.orig
--- gdal-3.6.1-orig/apps/multireadtest.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.6.1-patched/apps/multireadtest.cpp.orig	2022-12-13 18:02:35.000000000 -0500
@@ -0,0 +1,255 @@
+/******************************************************************************
+ *
+ * Project:  GDAL Utilities
+ * Purpose:  Multi-threading test application.
+ * Author:   Frank Warmerdam, warmerdam@pobox.com
+ *
+ ******************************************************************************
+ * Copyright (c) 2005, Frank Warmerdam
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ ****************************************************************************/
+
+#include "gdal.h"
+#include "gdal_alg.h"
+#include "cpl_multiproc.h"
+#include "cpl_string.h"
+#include <vector>
+
+
+static int nIterations = 1;
+static bool bLockOnOpen = false;
+static int nOpenIterations = 1;
+static volatile int nPendingThreads = 0;
+static const char *pszFilename = nullptr;
+static int nChecksum = 0;
+static int nWidth = 0;
+static int nHeight = 0;
+
+static CPLMutex *pGlobalMutex = nullptr;
+
+/************************************************************************/
+/*                               Usage()                                */
+/************************************************************************/
+
+static void Usage()
+{
+    printf("multireadtest [-lock_on_open] [-open_in_main] [-t <thread#>]\n"
+           "              [-i <iterations>] [-oi <iterations>]\n"
+           "              [-width <val>] [-height <val>]\n"
+           "              filename\n");
+    exit(1);
+}
+
+/************************************************************************/
+/*                             WorkerFunc()                             */
+/************************************************************************/
+
+static void WorkerFunc( void *arg )
+{
+    GDALDatasetH hDSIn = static_cast<GDALDatasetH>(arg);
+    GDALDatasetH hDS = nullptr;
+
+    for( int iOpenIter = 0; iOpenIter < nOpenIterations; iOpenIter++ )
+    {
+        if( hDSIn != nullptr )
+        {
+            hDS = hDSIn;
+        }
+        else
+        {
+            if( bLockOnOpen )
+                CPLAcquireMutex(pGlobalMutex, 100.0);
+
+            hDS = GDALOpen(pszFilename, GA_ReadOnly);
+
+            if( bLockOnOpen )
+                CPLReleaseMutex(pGlobalMutex);
+        }
+
+        for( int iIter = 0; iIter < nIterations && hDS != nullptr; iIter++ )
+        {
+            const int nMyChecksum = GDALChecksumImage(GDALGetRasterBand(hDS, 1),
+                                                      0, 0,
+                                                      nWidth ? nWidth : GDALGetRasterXSize(hDS),
+                                                      nHeight ? nHeight : GDALGetRasterYSize(hDS));
+
+            if( nMyChecksum != nChecksum )
+            {
+                printf("Checksum ERROR in worker thread!\n");
+                break;
+            }
+        }
+
+        if( hDS && hDSIn == nullptr )
+        {
+            if( bLockOnOpen )
+                CPLAcquireMutex(pGlobalMutex, 100.0);
+            GDALClose( hDS );
+            if( bLockOnOpen )
+                CPLReleaseMutex(pGlobalMutex);
+        }
+        else if ( hDSIn != nullptr )
+        {
+            GDALFlushCache(hDSIn);
+        }
+    }
+
+    CPLAcquireMutex(pGlobalMutex, 100.0);
+    nPendingThreads--;
+    CPLReleaseMutex(pGlobalMutex);
+}
+
+/************************************************************************/
+/*                                main()                                */
+/************************************************************************/
+
+int main( int argc, char ** argv )
+
+{
+/* -------------------------------------------------------------------- */
+/*      Process arguments.                                              */
+/* -------------------------------------------------------------------- */
+    argc = GDALGeneralCmdLineProcessor(argc, &argv, 0);
+    if( argc < 1 )
+        exit(-argc);
+
+    int nThreadCount = 4;
+    bool bOpenInThreads = true;
+
+    for( int iArg = 1; iArg < argc; iArg++ )
+    {
+        if( iArg < argc-1 && EQUAL(argv[iArg], "-i") )
+        {
+            nIterations = atoi(argv[++iArg]);
+        }
+        else if( iArg < argc-1 && EQUAL(argv[iArg], "-oi") )
+        {
+            nOpenIterations = atoi(argv[++iArg]);
+        }
+        else if( iArg < argc-1 && EQUAL(argv[iArg], "-t") )
+        {
+            nThreadCount = atoi(argv[++iArg]);
+        }
+        else if( iArg < argc-1 && EQUAL(argv[iArg], "-width") )
+        {
+            nWidth = atoi(argv[++iArg]);
+        }
+        else if( iArg < argc-1 && EQUAL(argv[iArg], "-height") )
+        {
+            nHeight = atoi(argv[++iArg]);
+        }
+        else if( EQUAL(argv[iArg], "-lock_on_open") )
+        {
+            bLockOnOpen = true;
+        }
+        else if( EQUAL(argv[iArg], "-open_in_main") )
+        {
+            bOpenInThreads = false;
+        }
+        else if( pszFilename == nullptr )
+        {
+            pszFilename = argv[iArg];
+        }
+        else
+        {
+            printf("Unrecognized argument: %s\n", argv[iArg]);
+            Usage();
+        }
+    }
+
+    if( pszFilename == nullptr )
+    {
+        printf("Need a file to operate on.\n");
+        Usage();
+        exit(1);
+    }
+
+    if( nOpenIterations > 0 )
+        bLockOnOpen = false;
+
+/* -------------------------------------------------------------------- */
+/*      Get the checksum of band1.                                      */
+/* -------------------------------------------------------------------- */
+    GDALDatasetH hDS = nullptr;
+
+    GDALAllRegister();
+    for( int i = 0; i < 2; i++ )
+    {
+        hDS = GDALOpen( pszFilename, GA_ReadOnly );
+        if( hDS == nullptr )
+            exit( 1 );
+
+        nChecksum = GDALChecksumImage(GDALGetRasterBand(hDS, 1),
+                                      0, 0,
+                                      nWidth ? nWidth : GDALGetRasterXSize(hDS),
+                                      nHeight ? nHeight : GDALGetRasterYSize(hDS));
+
+        GDALClose(hDS);
+    }
+
+    printf(
+        "Got checksum %d, launching %d worker threads on %s, %d iterations.\n",
+        nChecksum, nThreadCount, pszFilename, nIterations);
+
+/* -------------------------------------------------------------------- */
+/*      Fire off worker threads.                                        */
+/* -------------------------------------------------------------------- */
+    pGlobalMutex = CPLCreateMutex();
+    CPLReleaseMutex(pGlobalMutex);
+
+    nPendingThreads = nThreadCount;
+
+    std::vector<GDALDatasetH> aoDS;
+    for( int iThread = 0; iThread < nThreadCount; iThread++ )
+    {
+        hDS = nullptr;
+        if( !bOpenInThreads )
+        {
+            hDS = GDALOpen(pszFilename, GA_ReadOnly);
+            if( !hDS )
+            {
+                printf("GDALOpen() failed.\n");
+                exit(1);
+            }
+            aoDS.push_back(hDS);
+        }
+        if( CPLCreateThread(WorkerFunc, hDS) == -1 )
+        {
+            printf("CPLCreateThread() failed.\n");
+            exit(1);
+        }
+    }
+
+    while( nPendingThreads > 0 )
+        CPLSleep(0.5);
+
+    CPLDestroyMutex(pGlobalMutex);
+
+    for( size_t i = 0; i < aoDS.size(); ++i )
+        GDALClose(aoDS[i]);
+
+    printf("All threads complete.\n");
+
+    CSLDestroy(argv);
+
+    GDALDestroyDriverManager();
+
+    return 0;
+}
diff -Nru gdal-3.6.1-orig/apps/testreprojmulti.cpp gdal-3.6.1-patched/apps/testreprojmulti.cpp
--- gdal-3.6.1-orig/apps/testreprojmulti.cpp	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/apps/testreprojmulti.cpp	2023-01-03 06:32:17.401842279 -0500
@@ -32,6 +32,7 @@
 #include "cpl_atomic_ops.h"
 #include "cpl_multiproc.h"
 #include "ogr_spatialref.h"
+#include "commonutils.h"
 
 
 double* padfRefX = nullptr;
@@ -73,7 +74,7 @@
     }
 }
 
-int main(int argc, char* argv[])
+MAIN_START(argc, argv)
 {
     int nThreads = 2;
 
@@ -118,3 +119,4 @@
 
     return 0;
 }
+MAIN_END
diff -Nru gdal-3.6.1-orig/apps/testreprojmulti.cpp.orig gdal-3.6.1-patched/apps/testreprojmulti.cpp.orig
--- gdal-3.6.1-orig/apps/testreprojmulti.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.6.1-patched/apps/testreprojmulti.cpp.orig	2022-12-13 18:02:35.000000000 -0500
@@ -0,0 +1,120 @@
+/******************************************************************************
+ *
+ * Project:  GDAL
+ * Purpose:  Test multi-threaded reprojection
+ * Author:   Even Rouault, <even dot rouault at spatialys.com>
+ *
+ ******************************************************************************
+ * Copyright (c) 2010, Even Rouault <even dot rouault at spatialys.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ ****************************************************************************/
+
+#include <assert.h>
+
+#include "cpl_string.h"
+#include "cpl_atomic_ops.h"
+#include "cpl_multiproc.h"
+#include "ogr_spatialref.h"
+
+
+double* padfRefX = nullptr;
+double* padfRefY = nullptr;
+double* padfRefResultX = nullptr;
+double* padfRefResultY = nullptr;
+OGRCoordinateTransformation *poCT = nullptr;
+volatile int nIter = 0;
+bool bCreateCTInThread = false;
+OGRSpatialReference oSrcSRS;
+OGRSpatialReference oDstSRS;
+int nCountIter = 10000;
+
+static void ReprojFunc(void* /* unused */)
+{
+    double* padfResultX =
+        static_cast<double *>(CPLMalloc(1024 * sizeof(double)));
+    double* padfResultY =
+        static_cast<double *>(CPLMalloc(1024 * sizeof(double)));
+    OGRCoordinateTransformation *poCTInThread;
+    if( !bCreateCTInThread )
+        poCTInThread = poCT;
+    while( true )
+    {
+        if( bCreateCTInThread )
+            poCTInThread = OGRCreateCoordinateTransformation(&oSrcSRS,&oDstSRS);
+
+        CPLAtomicInc(&nIter);
+        memcpy(padfResultX, padfRefX, 1024 * sizeof(double));
+        memcpy(padfResultY, padfRefY, 1024 * sizeof(double));
+        poCT->Transform( 1024, padfResultX, padfResultY, nullptr, nullptr );
+
+        /* Check that the results are consistent with the reference results */
+        assert(memcmp(padfResultX, padfRefResultX, 1024 * sizeof(double)) == 0);
+        assert(memcmp(padfResultY, padfRefResultY, 1024 * sizeof(double)) == 0);
+
+        if( bCreateCTInThread )
+            OGRCoordinateTransformation::DestroyCT(poCTInThread);
+    }
+}
+
+int main(int argc, char* argv[])
+{
+    int nThreads = 2;
+
+    for(int i=0;i<argc;i++)
+    {
+        if (EQUAL(argv[i], "-threads") && i+1 < argc)
+            nThreads = atoi(argv[++i]);
+        else if (EQUAL(argv[i], "-iter") && i+1 < argc)
+            nCountIter = atoi(argv[++i]);
+        else if (EQUAL(argv[i], "-createctinthread"))
+            bCreateCTInThread = true;
+    }
+
+    oSrcSRS.importFromEPSG(4326);
+    oSrcSRS.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);
+    oDstSRS.importFromEPSG(32631);
+    oDstSRS.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);
+    poCT = OGRCreateCoordinateTransformation(&oSrcSRS,&oDstSRS);
+    if (poCT == nullptr)
+        return -1;
+
+    padfRefX = static_cast<double *>(CPLMalloc(1024 * sizeof(double)));
+    padfRefY = static_cast<double *>(CPLMalloc(1024 * sizeof(double)));
+    padfRefResultX = static_cast<double *>(CPLMalloc(1024 * sizeof(double)));
+    padfRefResultY = static_cast<double *>(CPLMalloc(1024 * sizeof(double)));
+
+    for(int i=0;i<1024;i++)
+    {
+        padfRefX[i] = 2 + i / 1024.;
+        padfRefY[i] = 49 + i / 1024.;
+    }
+    memcpy(padfRefResultX, padfRefX, 1024 * sizeof(double));
+    memcpy(padfRefResultY, padfRefY, 1024 * sizeof(double));
+
+    poCT->Transform( 1024, padfRefResultX, padfRefResultY, nullptr, nullptr );
+
+    for(int i=0;i<nThreads;i++)
+        CPLCreateThread(ReprojFunc, nullptr);
+
+    while(nIter < nCountIter)
+        CPLSleep(0.001);
+
+    return 0;
+}
diff -Nru gdal-3.6.1-orig/cmake/modules/packages/FindBlosc.cmake gdal-3.6.1-patched/cmake/modules/packages/FindBlosc.cmake
--- gdal-3.6.1-orig/cmake/modules/packages/FindBlosc.cmake	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/cmake/modules/packages/FindBlosc.cmake	2023-01-03 06:32:17.401842279 -0500
@@ -70,5 +70,13 @@
         INTERFACE_INCLUDE_DIRECTORIES "${BLOSC_INCLUDE_DIR}"
       )
     endif()
+    # Try to find pkgconfig specified library dependencies
+    find_package(PkgConfig QUIET)
+    if(PKG_CONFIG_FOUND)
+      pkg_check_modules(PC_blosc QUIET IMPORTED_TARGET blosc)
+    endif()
+    if(PC_pq_FOUND)
+      set_target_properties(Blosc::Blosc PROPERTIES INTERFACE_LINK_LIBRARIES PkgConfig::PC_blosc)
+    endif()
   endif()
 endif()
diff -Nru gdal-3.6.1-orig/cmake/modules/packages/FindFreeXL.cmake gdal-3.6.1-patched/cmake/modules/packages/FindFreeXL.cmake
--- gdal-3.6.1-orig/cmake/modules/packages/FindFreeXL.cmake	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/cmake/modules/packages/FindFreeXL.cmake	2023-01-03 06:32:17.401842279 -0500
@@ -37,7 +37,15 @@
 
 find_package(PkgConfig QUIET)
 if(PKG_CONFIG_FOUND)
-    pkg_check_modules(PC_FREEXL QUIET freexl)
+    pkg_check_modules(PC_FREEXL QUIET IMPORTED_TARGET freexl)
+endif()
+if(PC_FREEXL_FOUND)
+    set(FREEXL_INCLUDE_DIR "${PC_FREEXL_INCLUDE_DIRS}" CACHE STRING "")
+    set(FREEXL_LIBRARY "${PC_FREEXL_LIBRARIES}" CACHE STRING "")
+    if(NOT TARGET FREEXL::freexl)
+        add_library(FREEXL::freexl INTERFACE IMPORTED)
+        set_target_properties(FREEXL::freexl PROPERTIES INTERFACE_LINK_LIBRARIES PkgConfig::PC_FREEXL)
+    endif()
 endif()
 
 find_path(FREEXL_INCLUDE_DIR
diff -Nru gdal-3.6.1-orig/cmake/modules/packages/FindHDF4.cmake gdal-3.6.1-patched/cmake/modules/packages/FindHDF4.cmake
--- gdal-3.6.1-orig/cmake/modules/packages/FindHDF4.cmake	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/cmake/modules/packages/FindHDF4.cmake	2023-01-03 08:55:42.618459716 -0500
@@ -22,110 +22,53 @@
 #]=======================================================================]
 #
 
+# The original code is modified for use with MXE where hdf4 is configured
+# with autotools and .pc files are available.
 
-include(SelectLibraryConfigurations)
-
-set(HDF4_PATHS
-    /usr/lib/hdf4
-    /usr/local/hdf4
-    )
-
-find_path(HDF4_INCLUDE_DIR hdf.h
-          PATHS ${HDF4_PATHS}
-          PATH_SUFFIXES
-          include
-          Include
-          hdf
-          hdf4
-          )
-mark_as_advanced(HDF4_INCLUDE_DIR)
-
-if(HDF4_INCLUDE_DIR AND EXISTS "${HDF4_INCLUDE_DIR}/hfile.h")
-    file(STRINGS "${HDF4_INCLUDE_DIR}/hfile.h" hdf4_version_string
-         REGEX "^#define[\t ]+LIBVER.*")
-    string(REGEX MATCH "LIBVER_MAJOR[ \t]+([0-9]+)" HDF4_VERSION_MAJOR "${hdf4_version_string}")
-    string(REGEX MATCH "([0-9]+)" HDF4_VERSION_MAJOR ${HDF4_VERSION_MAJOR})
-    string(REGEX MATCH "LIBVER_MINOR[ \t]+([0-9]+)" HDF4_VERSION_MINOR "${hdf4_version_string}")
-    string(REGEX MATCH "([0-9]+)" HDF4_VERSION_MINOR ${HDF4_VERSION_MINOR})
-    string(REGEX MATCH "LIBVER_RELEASE[ \t]+([0-9]+)" HDF4_VERSION_RELEASE "${hdf4_version_string}")
-    string(REGEX MATCH "([0-9]+)" HDF4_VERSION_RELEASE ${HDF4_VERSION_RELEASE})
-    string(REGEX MATCH "LIBVER_SUBRELEASE[ \t]+([0-9A-Za-z]+)" HDF4_VERSION_SUBRELEASE "${hdf4_version_string}")
-    unset(hdf4_version_string)
-    if(NOT HDF4_VERSION_SUBRELEASE STREQUAL "")
-        string(REGEX MATCH "([0-9A-Za-z]+)" LIBVER_SUBRELEASE ${LIBVER_SUBRELEASE})
-        set(HDF4_VERSION_STRING "${HDF4_VERSION_MAJOR}.${HDF4_VERSION_MINOR}.${HDF4_VERSION_RELEASE}_${HDF4_VERSION_SUBRELEASE}")
-    else()
-        set(HDF4_VERSION_STRING "${HDF4_VERSION_MAJOR}.${HDF4_VERSION_MINOR}.${HDF4_VERSION_RELEASE}")
+find_package(PkgConfig QUIET)
+if(PKG_CONFIG_FOUND)
+  pkg_check_modules(PC_Hdf4df QUIET IMPORTED_TARGET df)
+  if(PC_Hdf4df_VERSION)
+    set(HDF4_VERSION_STRING ${PC_Hdf4df_VERSION})
+  endif()
+endif()
+if(PC_Hdf4df_FOUND)
+  if(NOT TARGET PkgConfig::Hdf4df)
+    add_library(PkgConfig::Hdf4df INTERFACE IMPORTED)
+    set_target_properties(PkgConfig::Hdf4df PROPERTIES INTERFACE_LINK_LIBRARIES PkgConfig::PC_Hdf4df)
+  endif()
+  list(APPEND HDF4_TARGETS PkgConfig::Hdf4df)
+  pkg_check_modules(PC_Hdf4mfhdf QUIET IMPORTED_TARGET mfhdf)
+  if(PC_Hdf4mfhdf_FOUND)
+    if(NOT TARGET PkgConfig::Hdf4mfhdf)
+      add_library(PkgConfig::Hdf4mfhdf INTERFACE IMPORTED)
+      set_target_properties(PkgConfig::Hdf4mfhdf PROPERTIES INTERFACE_LINK_LIBRARIES PkgConfig::PC_Hdf4mfhdf)
     endif()
+    list(APPEND HDF4_TARGETS PkgConfig::Hdf4mfhdf)
+  endif()
 endif()
 
-if(NOT DEFINED HDF4_COMPONENTS)
-  set(HDF4_COMPONENTS df mfhdf xdr szip)
-endif()
+find_path(
+  HDF4_INCLUDE_DIR NAMES "hdf.h"
+  HINTS ${PC_Hdf4df_INCLUDE_DIRS})
 
-if(HDF4_INCLUDE_DIR)
-    # Debian supplies the HDF4 library which does not conflict with NetCDF.
-    # Test for Debian flavor first. Hint: install the libhdf4-alt-dev package.
-    foreach(tgt IN LISTS HDF4_COMPONENTS)
-        if(tgt STREQUAL "df")
-          # hdf.lib (dynamic) used by conda, but libhdf.lib (static) also present
-          set(_names_debug  ${tgt}altd ${tgt}d hdfd libhdfd)
-          set(_names_release ${tgt}alt ${tgt} hdf libhdf)
-        else()
-          set(_names_debug  ${tgt}altd ${tgt}d)
-          set(_names_release ${tgt}alt ${tgt} lib${tgt})
-        endif()
-        find_library(HDF4_${tgt}_LIBRARY_DEBUG
-                     NAMES ${_names_debug}
-                     PATHS ${HDF4_PATHS}/lib)
-        find_library(HDF4_${tgt}_LIBRARY_RELEASE
-                     NAMES ${_names_release}
-                     PATHS ${HDF4_PATHS}/lib)
-        select_library_configurations(HDF4_${tgt})
-        mark_as_advanced(HDF4_${tgt}_LIBRARY HDF4_${tgt}_LIBRARY_RELEASE HDF4_${tgt}_LIBRARY_DEBUG )
-    endforeach()
-
-    set(HDF4_LIBRARIES)
-    foreach(_comp IN LISTS HDF4_COMPONENTS)
-        if(HDF4_${_comp}_LIBRARY)
-            list(APPEND HDF4_LIBRARIES "${HDF4_${_comp}_LIBRARY}")
-        endif()
-    endforeach()
-
-    if(WIN32)
-        find_library(WS2_32_LIBRARY ws2_32)
-        if(WS2_32_LIBRARY)
-          list(APPEND HDF4_LIBRARIES ${WS2_32_LIBRARY})
-        endif()
-    endif()
-endif()
+find_library(HDF4DF_LIBRARY NAMES df HINTS ${PC_Hdf4df_LIBRARY_DIRS})
+find_library(HDF4MFHDF_LIBRARY NAMES mfhdf HINTS ${PC_Hdf4mfhdf_LIBRARY_DIRS})
 
 include(FindPackageHandleStandardArgs)
 find_package_handle_standard_args(HDF4
                                   FOUND_VAR HDF4_FOUND
-                                  REQUIRED_VARS HDF4_df_LIBRARY HDF4_mfhdf_LIBRARY HDF4_INCLUDE_DIR
+                                  REQUIRED_VARS HDF4DF_LIBRARY HDF4_INCLUDE_DIR
                                   VERSION_VAR HDF4_VERSION_STRING
                                   HANDLE_COMPONENTS
                                   )
 
-# set output variables
 if(HDF4_FOUND)
   set(HDF4_INCLUDE_DIRS "${HDF4_INCLUDE_DIR}")
   if(NOT TARGET HDF4::HDF4)
-      set(INCR 1)
-      set(HDF4_TARGETS)
-      foreach(_lib IN LISTS HDF4_LIBRARIES)
-          add_library(HDF4::HDF4_${INCR} UNKNOWN IMPORTED)
-          set_target_properties(HDF4::HDF4_${INCR} PROPERTIES
-                                IMPORTED_LINK_INTERFACE_LANGUAGES "C"
-                                IMPORTED_LOCATION "${_lib}")
-          list(APPEND HDF4_TARGETS HDF4::HDF4_${INCR})
-          math(EXPR INCR "${INCR}+1")
-      endforeach()
-
-      add_library(HDF4::HDF4 INTERFACE IMPORTED)
-      set_target_properties(HDF4::HDF4 PROPERTIES
-                            INTERFACE_INCLUDE_DIRECTORIES ${HDF4_INCLUDE_DIRS}
-                            INTERFACE_LINK_LIBRARIES "${HDF4_TARGETS}")
+    add_library(HDF4::HDF4 INTERFACE IMPORTED)
+    set_target_properties(HDF4::HDF4 PROPERTIES
+                          INTERFACE_INCLUDE_DIRECTORIES ${HDF4_INCLUDE_DIR}
+                          INTERFACE_LINK_LIBRARIES "${HDF4_TARGETS}")
   endif()
 endif()
diff -Nru gdal-3.6.1-orig/cmake/modules/packages/FindOpenJPEG.cmake gdal-3.6.1-patched/cmake/modules/packages/FindOpenJPEG.cmake
--- gdal-3.6.1-orig/cmake/modules/packages/FindOpenJPEG.cmake	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/cmake/modules/packages/FindOpenJPEG.cmake	2023-01-03 06:32:17.401842279 -0500
@@ -32,9 +32,18 @@
 
 find_package(PkgConfig QUIET)
 if(PKG_CONFIG_FOUND)
-    pkg_check_modules(PC_OPENJPEG QUIET libopenjp2)
+    pkg_check_modules(PC_OPENJPEG QUIET IMPORTED_TARGET libopenjp2)
     set(OPENJPEG_VERSION_STRING ${PC_OPENJPEG_VERSION})
 endif()
+if(PC_OPENJPEG_FOUND)
+    set(OPENJPEG_INCLUDE_DIR "${PC_OPENJPEG_INCLUDE_DIRS}" CACHE STRING "")
+    set(OPENJPEG_LIBRARY "${PC_OPENJPEG_LIBRARIES}" CACHE STRING "")
+    if(NOT TARGET OPENJPEG::OpenJPEG)
+        add_library(OPENJPEG::OpenJPEG INTERFACE IMPORTED)
+        set_target_properties(OPENJPEG::OpenJPEG PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${PC_OPENJPEG_INCLUDE_DIRS}")
+        set_target_properties(OPENJPEG::OpenJPEG PROPERTIES INTERFACE_LINK_LIBRARIES PkgConfig::PC_OPENJPEG)
+    endif()
+endif()
 
 
 find_path(OPENJPEG_INCLUDE_DIR opj_config.h
diff -Nru gdal-3.6.1-orig/cmake/modules/packages/FindPoppler.cmake gdal-3.6.1-patched/cmake/modules/packages/FindPoppler.cmake
--- gdal-3.6.1-orig/cmake/modules/packages/FindPoppler.cmake	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/cmake/modules/packages/FindPoppler.cmake	2023-01-03 06:32:17.401842279 -0500
@@ -42,11 +42,19 @@
 
 find_package(PkgConfig QUIET)
 if(PKG_CONFIG_FOUND)
-  pkg_check_modules(PC_Poppler QUIET poppler)
+  pkg_check_modules(PC_Poppler QUIET IMPORTED_TARGET poppler)
   if(PC_Poppler_VERSION)
     set(Poppler_VERSION_STRING ${PC_Poppler_VERSION})
   endif()
 endif()
+if(PC_Poppler_FOUND)
+    set(Poppler_INCLUDE_DIR "${PC_Poppler_INCLUDE_DIRS}" CACHE STRING "")
+    set(Poppler_LIBRARY "${PC_Poppler_LIBRARIES}" CACHE STRING "")
+    if(NOT TARGET Poppler::Poppler)
+        add_library(Poppler::Poppler INTERFACE IMPORTED)
+        set_target_properties(Poppler::Poppler PROPERTIES INTERFACE_LINK_LIBRARIES PkgConfig::PC_Poppler)
+    endif()
+endif()
 find_path(Poppler_INCLUDE_DIR NAMES "poppler-config.h" "cpp/poppler-version.h" "qt5/poppler-qt5.h" "qt4/poppler-qt4.h"
           "glib/poppler.h"
           HINTS ${PC_Poppler_INCLUDE_DIRS}
@@ -77,6 +85,15 @@
 foreach(_comp IN LISTS Poppler_known_components)
   list(FIND Poppler_FIND_COMPONENTS "${_comp}" _nextcomp)
   if(_nextcomp GREATER -1)
+    pkg_check_modules(PC_Poppler_${_comp} QUIET IMPORTED_TARGET ${Poppler_${_comp}_pkg_config})
+    if(PC_Poppler_${_comp}_FOUND)
+      set(Poppler_${_comp}_INCLUDE_DIR "${PC_Poppler_${_comp}_INCLUDE_DIRS}" CACHE STRING "")
+      set(Poppler_${_comp}_LIBRARY "${PC_Poppler_${_comp}_LIBRARIES}" CACHE STRING "")
+      if(NOT TARGET Poppler::Poppler_${_comp})
+          add_library(Poppler::${_comp} INTERFACE IMPORTED)
+          set_target_properties(Poppler::${_comp} PROPERTIES INTERFACE_LINK_LIBRARIES PkgConfig::PC_Poppler_${_comp})
+        endif()
+    endif()
     find_path(Poppler_${_comp}_INCLUDE_DIR
               NAMES ${Poppler_${_comp}_header}
               PATH_SUFFIXES poppler
diff -Nru gdal-3.6.1-orig/cmake/modules/packages/FindPostgreSQL.cmake gdal-3.6.1-patched/cmake/modules/packages/FindPostgreSQL.cmake
--- gdal-3.6.1-orig/cmake/modules/packages/FindPostgreSQL.cmake	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.6.1-patched/cmake/modules/packages/FindPostgreSQL.cmake	2023-01-03 06:32:17.401842279 -0500
@@ -0,0 +1,328 @@
+# Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
+# file Copyright.txt or https://cmake.org/licensing for details.
+
+# This file has been modified from the original CMake 3.24 version:
+# * Adapted to work from gdal tree
+# * use pkgconfig for linked library information.
+
+#[=======================================================================[.rst:
+FindPostgreSQL
+--------------
+
+Find the PostgreSQL installation.
+
+IMPORTED Targets
+^^^^^^^^^^^^^^^^
+
+.. versionadded:: 3.14
+
+This module defines :prop_tgt:`IMPORTED` target ``PostgreSQL::PostgreSQL``
+if PostgreSQL has been found.
+
+Result Variables
+^^^^^^^^^^^^^^^^
+
+This module will set the following variables in your project:
+
+``PostgreSQL_FOUND``
+  True if PostgreSQL is found.
+``PostgreSQL_LIBRARIES``
+  the PostgreSQL libraries needed for linking
+``PostgreSQL_INCLUDE_DIRS``
+  the directories of the PostgreSQL headers
+``PostgreSQL_LIBRARY_DIRS``
+  the link directories for PostgreSQL libraries
+``PostgreSQL_VERSION_STRING``
+  the version of PostgreSQL found
+``PostgreSQL_TYPE_INCLUDE_DIR``
+  the directories of the PostgreSQL server headers
+
+Components
+^^^^^^^^^^
+
+This module contains additional ``Server`` component, that forcibly checks
+for the presence of server headers. Note that ``PostgreSQL_TYPE_INCLUDE_DIR``
+is set regardless of the presence of the ``Server`` component in find_package call.
+
+#]=======================================================================]
+
+# ----------------------------------------------------------------------------
+# History:
+# This module is derived from the module originally found in the VTK source tree.
+#
+# ----------------------------------------------------------------------------
+# Note:
+# PostgreSQL_ADDITIONAL_VERSIONS is a variable that can be used to set the
+# version number of the implementation of PostgreSQL.
+# In Windows the default installation of PostgreSQL uses that as part of the path.
+# E.g C:\Program Files\PostgreSQL\8.4.
+# Currently, the following version numbers are known to this module:
+# "14" "13" "12" "11" "10" "9.6" "9.5" "9.4" "9.3" "9.2" "9.1" "9.0" "8.4" "8.3" "8.2" "8.1" "8.0"
+#
+# To use this variable just do something like this:
+# set(PostgreSQL_ADDITIONAL_VERSIONS "9.2" "8.4.4")
+# before calling find_package(PostgreSQL) in your CMakeLists.txt file.
+# This will mean that the versions you set here will be found first in the order
+# specified before the default ones are searched.
+#
+# ----------------------------------------------------------------------------
+# You may need to manually set:
+#  PostgreSQL_INCLUDE_DIR  - the path to where the PostgreSQL include files are.
+#  PostgreSQL_LIBRARY_DIR  - The path to where the PostgreSQL library files are.
+# If FindPostgreSQL.cmake cannot find the include files or the library files.
+#
+# ----------------------------------------------------------------------------
+# The following variables are set if PostgreSQL is found:
+#  PostgreSQL_FOUND         - Set to true when PostgreSQL is found.
+#  PostgreSQL_INCLUDE_DIRS  - Include directories for PostgreSQL
+#  PostgreSQL_LIBRARY_DIRS  - Link directories for PostgreSQL libraries
+#  PostgreSQL_LIBRARIES     - The PostgreSQL libraries.
+#
+# The ``PostgreSQL::PostgreSQL`` imported target is also created.
+#
+# ----------------------------------------------------------------------------
+# If you have installed PostgreSQL in a non-standard location.
+# (Please note that in the following comments, it is assumed that <Your Path>
+# points to the root directory of the include directory of PostgreSQL.)
+# Then you have three options.
+# 1) After CMake runs, set PostgreSQL_INCLUDE_DIR to <Your Path>/include and
+#    PostgreSQL_LIBRARY_DIR to wherever the library pq (or libpq in windows) is
+# 2) Use CMAKE_INCLUDE_PATH to set a path to <Your Path>/PostgreSQL<-version>. This will allow find_path()
+#    to locate PostgreSQL_INCLUDE_DIR by utilizing the PATH_SUFFIXES option. e.g. In your CMakeLists.txt file
+#    set(CMAKE_INCLUDE_PATH ${CMAKE_INCLUDE_PATH} "<Your Path>/include")
+# 3) Set an environment variable called ${PostgreSQL_ROOT} that points to the root of where you have
+#    installed PostgreSQL, e.g. <Your Path>.
+#
+# ----------------------------------------------------------------------------
+
+cmake_policy(PUSH)
+cmake_policy(SET CMP0057 NEW) # if IN_LIST
+
+set(PostgreSQL_INCLUDE_PATH_DESCRIPTION "top-level directory containing the PostgreSQL include directories. E.g /usr/local/include/PostgreSQL/8.4 or C:/Program Files/PostgreSQL/8.4/include")
+set(PostgreSQL_INCLUDE_DIR_MESSAGE "Set the PostgreSQL_INCLUDE_DIR cmake cache entry to the ${PostgreSQL_INCLUDE_PATH_DESCRIPTION}")
+set(PostgreSQL_LIBRARY_PATH_DESCRIPTION "top-level directory containing the PostgreSQL libraries.")
+set(PostgreSQL_LIBRARY_DIR_MESSAGE "Set the PostgreSQL_LIBRARY_DIR cmake cache entry to the ${PostgreSQL_LIBRARY_PATH_DESCRIPTION}")
+set(PostgreSQL_ROOT_DIR_MESSAGE "Set the PostgreSQL_ROOT system variable to where PostgreSQL is found on the machine E.g C:/Program Files/PostgreSQL/8.4")
+
+
+set(PostgreSQL_KNOWN_VERSIONS ${PostgreSQL_ADDITIONAL_VERSIONS}
+    "14" "13" "12" "11" "10" "9.6" "9.5" "9.4" "9.3" "9.2" "9.1" "9.0" "8.4" "8.3" "8.2" "8.1" "8.0")
+
+# Define additional search paths for root directories.
+set( PostgreSQL_ROOT_DIRECTORIES
+   ENV PostgreSQL_ROOT
+   ${PostgreSQL_ROOT}
+)
+foreach(suffix ${PostgreSQL_KNOWN_VERSIONS})
+  if(WIN32)
+    list(APPEND PostgreSQL_LIBRARY_ADDITIONAL_SEARCH_SUFFIXES
+        "PostgreSQL/${suffix}/lib")
+    list(APPEND PostgreSQL_INCLUDE_ADDITIONAL_SEARCH_SUFFIXES
+        "PostgreSQL/${suffix}/include")
+    list(APPEND PostgreSQL_TYPE_ADDITIONAL_SEARCH_SUFFIXES
+        "PostgreSQL/${suffix}/include/server")
+  endif()
+  if(UNIX)
+    list(APPEND PostgreSQL_LIBRARY_ADDITIONAL_SEARCH_SUFFIXES
+        "postgresql${suffix}"
+        "postgresql@${suffix}"
+        "pgsql-${suffix}/lib")
+    list(APPEND PostgreSQL_INCLUDE_ADDITIONAL_SEARCH_SUFFIXES
+        "postgresql${suffix}"
+        "postgresql@${suffix}"
+        "postgresql/${suffix}"
+        "pgsql-${suffix}/include")
+    list(APPEND PostgreSQL_TYPE_ADDITIONAL_SEARCH_SUFFIXES
+        "postgresql${suffix}/server"
+        "postgresql@${suffix}/server"
+        "postgresql/${suffix}/server"
+        "pgsql-${suffix}/include/server")
+  endif()
+endforeach()
+
+#
+# Look for an installation.
+#
+find_path(PostgreSQL_INCLUDE_DIR
+  NAMES libpq-fe.h
+  PATHS
+   # Look in other places.
+   ${PostgreSQL_ROOT_DIRECTORIES}
+  PATH_SUFFIXES
+    pgsql
+    postgresql
+    include
+    ${PostgreSQL_INCLUDE_ADDITIONAL_SEARCH_SUFFIXES}
+  # Help the user find it if we cannot.
+  DOC "The ${PostgreSQL_INCLUDE_DIR_MESSAGE}"
+)
+
+find_path(PostgreSQL_TYPE_INCLUDE_DIR
+  NAMES catalog/pg_type.h
+  PATHS
+   # Look in other places.
+   ${PostgreSQL_ROOT_DIRECTORIES}
+  PATH_SUFFIXES
+    postgresql
+    pgsql/server
+    postgresql/server
+    include/server
+    ${PostgreSQL_TYPE_ADDITIONAL_SEARCH_SUFFIXES}
+  # Help the user find it if we cannot.
+  DOC "The ${PostgreSQL_INCLUDE_DIR_MESSAGE}"
+)
+
+# The PostgreSQL library.
+set (PostgreSQL_LIBRARY_TO_FIND pq)
+# Setting some more prefixes for the library
+set (PostgreSQL_LIB_PREFIX "")
+if ( WIN32 )
+  set (PostgreSQL_LIB_PREFIX ${PostgreSQL_LIB_PREFIX} "lib")
+  set (PostgreSQL_LIBRARY_TO_FIND ${PostgreSQL_LIB_PREFIX}${PostgreSQL_LIBRARY_TO_FIND})
+endif()
+
+function(__postgresql_find_library _name)
+  find_library(${_name}
+   NAMES ${ARGN}
+   PATHS
+     ${PostgreSQL_ROOT_DIRECTORIES}
+   PATH_SUFFIXES
+     lib
+     ${PostgreSQL_LIBRARY_ADDITIONAL_SEARCH_SUFFIXES}
+   # Help the user find it if we cannot.
+   DOC "The ${PostgreSQL_LIBRARY_DIR_MESSAGE}"
+  )
+endfunction()
+
+# For compatibility with versions prior to this multi-config search, honor
+# any PostgreSQL_LIBRARY that is already specified and skip the search.
+if(PostgreSQL_LIBRARY)
+  set(PostgreSQL_LIBRARIES "${PostgreSQL_LIBRARY}")
+  get_filename_component(PostgreSQL_LIBRARY_DIR "${PostgreSQL_LIBRARY}" PATH)
+else()
+  __postgresql_find_library(PostgreSQL_LIBRARY_RELEASE ${PostgreSQL_LIBRARY_TO_FIND})
+  __postgresql_find_library(PostgreSQL_LIBRARY_DEBUG ${PostgreSQL_LIBRARY_TO_FIND}d)
+  include(SelectLibraryConfigurations)
+  select_library_configurations(PostgreSQL)
+  mark_as_advanced(PostgreSQL_LIBRARY_RELEASE PostgreSQL_LIBRARY_DEBUG)
+  if(PostgreSQL_LIBRARY_RELEASE)
+    get_filename_component(PostgreSQL_LIBRARY_DIR "${PostgreSQL_LIBRARY_RELEASE}" PATH)
+  elseif(PostgreSQL_LIBRARY_DEBUG)
+    get_filename_component(PostgreSQL_LIBRARY_DIR "${PostgreSQL_LIBRARY_DEBUG}" PATH)
+  else()
+    set(PostgreSQL_LIBRARY_DIR "")
+  endif()
+endif()
+
+if (PostgreSQL_INCLUDE_DIR)
+  # Some platforms include multiple pg_config.hs for multi-lib configurations
+  # This is a temporary workaround.  A better solution would be to compile
+  # a dummy c file and extract the value of the symbol.
+  file(GLOB _PG_CONFIG_HEADERS "${PostgreSQL_INCLUDE_DIR}/pg_config*.h")
+  foreach(_PG_CONFIG_HEADER ${_PG_CONFIG_HEADERS})
+    if(EXISTS "${_PG_CONFIG_HEADER}")
+      file(STRINGS "${_PG_CONFIG_HEADER}" pgsql_version_str
+           REGEX "^#define[\t ]+PG_VERSION_NUM[\t ]+.*")
+      if(pgsql_version_str)
+        string(REGEX REPLACE "^#define[\t ]+PG_VERSION_NUM[\t ]+([0-9]*).*"
+               "\\1" _PostgreSQL_VERSION_NUM "${pgsql_version_str}")
+        break()
+      endif()
+    endif()
+  endforeach()
+  if (_PostgreSQL_VERSION_NUM)
+    # 9.x and older encoding
+    if (_PostgreSQL_VERSION_NUM LESS 100000)
+      math(EXPR _PostgreSQL_major_version "${_PostgreSQL_VERSION_NUM} / 10000")
+      math(EXPR _PostgreSQL_minor_version "${_PostgreSQL_VERSION_NUM} % 10000 / 100")
+      math(EXPR _PostgreSQL_patch_version "${_PostgreSQL_VERSION_NUM} % 100")
+      set(PostgreSQL_VERSION_STRING "${_PostgreSQL_major_version}.${_PostgreSQL_minor_version}.${_PostgreSQL_patch_version}")
+      unset(_PostgreSQL_major_version)
+      unset(_PostgreSQL_minor_version)
+      unset(_PostgreSQL_patch_version)
+    else ()
+      math(EXPR _PostgreSQL_major_version "${_PostgreSQL_VERSION_NUM} / 10000")
+      math(EXPR _PostgreSQL_minor_version "${_PostgreSQL_VERSION_NUM} % 10000")
+      set(PostgreSQL_VERSION_STRING "${_PostgreSQL_major_version}.${_PostgreSQL_minor_version}")
+      unset(_PostgreSQL_major_version)
+      unset(_PostgreSQL_minor_version)
+    endif ()
+  else ()
+    foreach(_PG_CONFIG_HEADER ${_PG_CONFIG_HEADERS})
+      if(EXISTS "${_PG_CONFIG_HEADER}")
+        file(STRINGS "${_PG_CONFIG_HEADER}" pgsql_version_str
+             REGEX "^#define[\t ]+PG_VERSION[\t ]+\".*\"")
+        if(pgsql_version_str)
+          string(REGEX REPLACE "^#define[\t ]+PG_VERSION[\t ]+\"([^\"]*)\".*"
+                 "\\1" PostgreSQL_VERSION_STRING "${pgsql_version_str}")
+          break()
+        endif()
+      endif()
+    endforeach()
+  endif ()
+  unset(_PostgreSQL_VERSION_NUM)
+  unset(pgsql_version_str)
+endif()
+
+if("Server" IN_LIST PostgreSQL_FIND_COMPONENTS)
+  set(PostgreSQL_Server_FOUND TRUE)
+  if(NOT PostgreSQL_TYPE_INCLUDE_DIR)
+    set(PostgreSQL_Server_FOUND FALSE)
+  endif()
+endif()
+
+# Did we find anything?
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(PostgreSQL
+                                  REQUIRED_VARS PostgreSQL_LIBRARY PostgreSQL_INCLUDE_DIR
+                                  HANDLE_COMPONENTS
+                                  VERSION_VAR PostgreSQL_VERSION_STRING)
+set(PostgreSQL_FOUND  ${POSTGRESQL_FOUND})
+
+function(__postgresql_import_library _target _var _config)
+  if(_config)
+    set(_config_suffix "_${_config}")
+  else()
+    set(_config_suffix "")
+  endif()
+
+  set(_lib "${${_var}${_config_suffix}}")
+  if(EXISTS "${_lib}")
+    if(_config)
+      set_property(TARGET ${_target} APPEND PROPERTY
+        IMPORTED_CONFIGURATIONS ${_config})
+    endif()
+    set_target_properties(${_target} PROPERTIES
+      IMPORTED_LOCATION${_config_suffix} "${_lib}")
+  endif()
+endfunction()
+
+# Now try to get the include and library path.
+if(PostgreSQL_FOUND)
+  set(PostgreSQL_INCLUDE_DIRS ${PostgreSQL_INCLUDE_DIR})
+  if(PostgreSQL_TYPE_INCLUDE_DIR)
+    list(APPEND PostgreSQL_INCLUDE_DIRS ${PostgreSQL_TYPE_INCLUDE_DIR})
+  endif()
+  set(PostgreSQL_LIBRARY_DIRS ${PostgreSQL_LIBRARY_DIR})
+  if (NOT TARGET PostgreSQL::PostgreSQL)
+    add_library(PostgreSQL::PostgreSQL UNKNOWN IMPORTED)
+    set_target_properties(PostgreSQL::PostgreSQL PROPERTIES
+      INTERFACE_INCLUDE_DIRECTORIES "${PostgreSQL_INCLUDE_DIRS}")
+    __postgresql_import_library(PostgreSQL::PostgreSQL PostgreSQL_LIBRARY "")
+    __postgresql_import_library(PostgreSQL::PostgreSQL PostgreSQL_LIBRARY "RELEASE")
+    __postgresql_import_library(PostgreSQL::PostgreSQL PostgreSQL_LIBRARY "DEBUG")
+
+  endif ()
+  # Try to find pkgconfig specified library dependencies
+  find_package(PkgConfig QUIET)
+  if(PKG_CONFIG_FOUND)
+    pkg_check_modules(PC_pq QUIET IMPORTED_TARGET libpq)
+  endif()
+  if(PC_pq_FOUND)
+    set_target_properties(PostgreSQL::PostgreSQL PROPERTIES INTERFACE_LINK_LIBRARIES PkgConfig::PC_pq)
+  endif()
+endif()
+
+mark_as_advanced(PostgreSQL_INCLUDE_DIR PostgreSQL_TYPE_INCLUDE_DIR)
+
+cmake_policy(POP)
diff -Nru gdal-3.6.1-orig/cmake/modules/packages/FindSPATIALITE.cmake gdal-3.6.1-patched/cmake/modules/packages/FindSPATIALITE.cmake
--- gdal-3.6.1-orig/cmake/modules/packages/FindSPATIALITE.cmake	2022-12-13 18:02:35.000000000 -0500
+++ gdal-3.6.1-patched/cmake/modules/packages/FindSPATIALITE.cmake	2023-01-03 06:32:17.401842279 -0500
@@ -38,9 +38,17 @@
 
 find_package(PkgConfig QUIET)
 if(PKG_CONFIG_FOUND)
-    pkg_check_modules(PC_SPATIALITE QUIET spatialite)
+    pkg_check_modules(PC_SPATIALITE QUIET IMPORTED_TARGET spatialite)
     set(SPATIALITE_VERSION_STRING ${PC_SPATIALITE_VERSION})
 endif()
+if(PC_SPATIALITE_FOUND)
+    set(SPATIALITE_INCLUDE_DIR "${PC_SPATIALITE_INCLUDE_DIRS}" CACHE STRING "")
+    set(SPATIALITE_LIBRARY "${PC_SPATIALITE_LIBRARIES}" CACHE STRING "")
+    if(NOT TARGET SPATIALITE::SPATIALITE)
+        add_library(SPATIALITE::SPATIALITE INTERFACE IMPORTED)
+        set_target_properties(SPATIALITE::SPATIALITE PROPERTIES INTERFACE_LINK_LIBRARIES PkgConfig::PC_SPATIALITE)
+    endif()
+endif()
 
 find_path(SPATIALITE_INCLUDE_DIR
           NAMES spatialite.h
diff -Nru gdal-3.6.1-orig/port/cpl_port.h gdal-3.6.1-patched/port/cpl_port.h
--- gdal-3.6.1-orig/port/cpl_port.h	2022-12-13 18:02:36.000000000 -0500
+++ gdal-3.6.1-patched/port/cpl_port.h	2023-01-03 06:32:17.397842283 -0500
@@ -113,15 +113,6 @@
 /*      MinGW stuff                                                     */
 /* ==================================================================== */
 
-/* We need __MSVCRT_VERSION__ >= 0x0700 to have "_aligned_malloc" */
-/* Latest versions of mingw32 define it, but with older ones, */
-/* we need to define it manually */
-#if defined(__MINGW32__)
-#ifndef __MSVCRT_VERSION__
-#define __MSVCRT_VERSION__ 0x0700
-#endif
-#endif
-
 /* Needed for std=c11 on Solaris to have strcasecmp() */
 #if defined(GDAL_COMPILATION) && defined(__sun__) && (__STDC_VERSION__ + 0) >= 201112L && (_XOPEN_SOURCE + 0) < 600
 #ifdef _XOPEN_SOURCE
