diff -Nru gdal-3.5.0-orig/apps/commonutils.h gdal-3.5.0-patched/apps/commonutils.h
--- gdal-3.5.0-orig/apps/commonutils.h	2022-05-10 10:03:37.000000000 -0400
+++ gdal-3.5.0-patched/apps/commonutils.h	2022-09-13 14:32:47.631089215 -0400
@@ -75,7 +75,44 @@
 #define MAIN_END
 
 #endif // defined(WIN32)
-#endif // defined(__cplusplus)
+#else // defined(__cplusplus) ----------------------------------
+
+#if defined(WIN32) && (defined(_MSC_VER) || defined(SUPPORTS_WMAIN))
+
+#include <wchar.h>
+#include <stdlib.h>
+#include "cpl_conv.h"
+#include "cpl_string.h"
+
+int wmain( int argc, wchar_t ** argv_w, wchar_t ** envp );
+
+#define MAIN_START(argc, argv) \
+  int wmain( int argc, wchar_t ** argv_w, wchar_t **envp ) \
+  { \
+    char **argv = (char**)(CPLCalloc(argc + 1, sizeof(char*))); \
+    { \
+      int i; \
+      for( i = 0; i < argc; i++ ) \
+      { \
+        argv[i] = CPLRecodeFromWChar( argv_w[i], CPL_ENC_UCS2, CPL_ENC_UTF8 ); \
+      } \
+    }
+
+// NOTE: memory will not be explicitly freed on exit/return from wmain()
+
+#define MAIN_END CSLDestroy(argv); \
+    return 0; \
+  }
+
+#else // defined(WIN32)
+
+#define MAIN_START(argc, argv) \
+    int main( int argc, char ** argv )
+
+#define MAIN_END
+
+#endif // defined(WIN32)
+#endif // (!__cplusplus__)
 
 
 CPL_C_START
diff -Nru gdal-3.5.0-orig/apps/dumpoverviews.cpp gdal-3.5.0-patched/apps/dumpoverviews.cpp
--- gdal-3.5.0-orig/apps/dumpoverviews.cpp	2022-05-10 10:03:37.000000000 -0400
+++ gdal-3.5.0-patched/apps/dumpoverviews.cpp	2022-09-13 14:32:47.631089215 -0400
@@ -31,6 +31,7 @@
 #include "cpl_string.h"
 #include "gdal_priv.h"
 #include "ogr_spatialref.h"
+#include "commonutils.h"
 
 CPL_CVSID("$Id$")
 
@@ -51,7 +52,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main( int argc, char ** argv )
+MAIN_START(argc, argv)
 
 {
     GDALAllRegister();
@@ -180,6 +181,7 @@
 
     return 0;
 }
+MAIN_END
 
 /************************************************************************/
 /*                              DumpBand()                              */
diff -Nru gdal-3.5.0-orig/apps/gdal2ogr.c gdal-3.5.0-patched/apps/gdal2ogr.c
--- gdal-3.5.0-orig/apps/gdal2ogr.c	2022-05-10 10:03:37.000000000 -0400
+++ gdal-3.5.0-patched/apps/gdal2ogr.c	2022-09-13 14:32:47.631089215 -0400
@@ -31,6 +31,7 @@
 #include "ogr_api.h"
 #include "ogr_srs_api.h"
 #include "cpl_string.h"
+#include "commonutils.h"
 
 CPL_CVSID("$Id$")
 
@@ -73,7 +74,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main(int argc, char* argv[])
+MAIN_START(argc, argv)
 {
     const char     *pszFormat = "ESRI Shapefile";
     char           *pszLayerName = NULL;
@@ -337,3 +338,4 @@
 
     return 0;
 }
+MAIN_END
\ No newline at end of file
diff -Nru gdal-3.5.0-orig/apps/gdalasyncread.cpp gdal-3.5.0-patched/apps/gdalasyncread.cpp
--- gdal-3.5.0-orig/apps/gdalasyncread.cpp	2022-05-10 10:03:37.000000000 -0400
+++ gdal-3.5.0-patched/apps/gdalasyncread.cpp	2022-09-13 14:32:47.631089215 -0400
@@ -32,6 +32,7 @@
 #include "gdal_version.h"
 #include "gdal_priv.h"
 #include "ogr_spatialref.h"
+#include "commonutils.h"
 
 CPL_CVSID("$Id$")
 
@@ -73,7 +74,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main( int argc, char ** argv )
+MAIN_START(argc, argv)
 
 {
     GDALDatasetH        hSrcDS, hDstDS;
@@ -558,3 +559,4 @@
     GDALDumpOpenDatasets( stderr );
     GDALDestroyDriverManager();
 }
+MAIN_END
diff -Nru gdal-3.5.0-orig/apps/gdalflattenmask.c gdal-3.5.0-patched/apps/gdalflattenmask.c
--- gdal-3.5.0-orig/apps/gdalflattenmask.c	2022-05-10 10:03:37.000000000 -0400
+++ gdal-3.5.0-patched/apps/gdalflattenmask.c	2022-09-13 14:32:47.631089215 -0400
@@ -29,6 +29,7 @@
 #include "gdal.h"
 #include "cpl_conv.h"
 #include "cpl_string.h"
+#include "commonutils.h"
 
 CPL_CVSID("$Id$")
 
@@ -55,7 +56,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main(int argc, char* argv[])
+MAIN_START(argc, argv)
 {
     const char* pszFormat = "GTiff";
     const char* pszSrcFilename = NULL;
@@ -338,3 +339,4 @@
 
     return 0;
 }
+MAIN_END
diff -Nru gdal-3.5.0-orig/apps/gdaltorture.cpp gdal-3.5.0-patched/apps/gdaltorture.cpp
--- gdal-3.5.0-orig/apps/gdaltorture.cpp	2022-05-10 10:03:37.000000000 -0400
+++ gdal-3.5.0-patched/apps/gdaltorture.cpp	2022-09-13 14:32:47.631089215 -0400
@@ -29,6 +29,7 @@
 #include "gdal.h"
 #include "cpl_string.h"
 #include "cpl_conv.h"
+#include "commonutils.h"
 
 #include <cassert>
 
@@ -237,7 +238,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main( int argc, char **argv )
+MAIN_START(argc, argv)
 {
     GDALAllRegister();
 
@@ -292,3 +293,4 @@
 
     return 0;
 }
+MAIN_END
\ No newline at end of file
diff -Nru gdal-3.5.0-orig/apps/gdalwarpsimple.c gdal-3.5.0-patched/apps/gdalwarpsimple.c
--- gdal-3.5.0-orig/apps/gdalwarpsimple.c	2022-05-10 10:03:37.000000000 -0400
+++ gdal-3.5.0-patched/apps/gdalwarpsimple.c	2022-09-13 14:32:47.631089215 -0400
@@ -31,6 +31,7 @@
 #include "gdal_alg.h"
 #include "cpl_string.h"
 #include "ogr_srs_api.h"
+#include "commonutils.h"
 
 CPL_CVSID("$Id$")
 
@@ -91,7 +92,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main( int argc, char ** argv )
+MAIN_START(argc, argv)
 
 {
     GDALDatasetH        hSrcDS, hDstDS;
@@ -313,6 +314,7 @@
 
     exit( 0 );
 }
+MAIN_END
 
 /************************************************************************/
 /*                        GDALWarpCreateOutput()                        */
diff -Nru gdal-3.5.0-orig/apps/multireadtest.cpp gdal-3.5.0-patched/apps/multireadtest.cpp
--- gdal-3.5.0-orig/apps/multireadtest.cpp	2022-05-10 10:03:37.000000000 -0400
+++ gdal-3.5.0-patched/apps/multireadtest.cpp	2022-09-13 14:32:47.631089215 -0400
@@ -30,6 +30,7 @@
 #include "gdal_alg.h"
 #include "cpl_multiproc.h"
 #include "cpl_string.h"
+#include "commonutils.h"
 #include <vector>
 
 CPL_CVSID("$Id$")
@@ -121,8 +122,7 @@
 /*                                main()                                */
 /************************************************************************/
 
-int main( int argc, char ** argv )
-
+MAIN_START(argc, argv)
 {
 /* -------------------------------------------------------------------- */
 /*      Process arguments.                                              */
@@ -254,3 +254,4 @@
 
     return 0;
 }
+MAIN_END
diff -Nru gdal-3.5.0-orig/apps/testreprojmulti.cpp gdal-3.5.0-patched/apps/testreprojmulti.cpp
--- gdal-3.5.0-orig/apps/testreprojmulti.cpp	2022-05-10 10:03:37.000000000 -0400
+++ gdal-3.5.0-patched/apps/testreprojmulti.cpp	2022-09-13 14:32:47.631089215 -0400
@@ -32,6 +32,7 @@
 #include "cpl_atomic_ops.h"
 #include "cpl_multiproc.h"
 #include "ogr_spatialref.h"
+#include "commonutils.h"
 
 CPL_CVSID("$Id$")
 
@@ -74,7 +75,7 @@
     }
 }
 
-int main(int argc, char* argv[])
+MAIN_START(argc, argv)
 {
     int nThreads = 2;
 
@@ -119,3 +120,4 @@
 
     return 0;
 }
+MAIN_END
diff -Nru gdal-3.5.0-orig/configure gdal-3.5.0-patched/configure
--- gdal-3.5.0-orig/configure	2022-05-10 10:03:41.000000000 -0400
+++ gdal-3.5.0-patched/configure	2022-09-13 14:32:47.639089169 -0400
@@ -32284,78 +32284,20 @@
     NETCDF_VERSION=`$NETCDF_NCCONFIG --version`
     NETCDF_PREFIX=`$NETCDF_NCCONFIG --prefix`
     NETCDF_INCLUDEDIR=`$NETCDF_NCCONFIG --includedir`
-    NETCDF_LIBS=`$NETCDF_NCCONFIG --libs`
-    NETCDF_STATIC_LIBS=`$NETCDF_NCCONFIG --static --libs`
-
-    if echo "x" | sed -E "s/x/y/" >/dev/null 2>/dev/null; then
-        STRIPPED_LIBRARY_NAME="$(echo "${NETCDF_LIBS}" | sed -E 's:-L/(usr/)?(lib(64)?|lib/x86_64-linux-gnu)/*[[:space:]]+::')"
-    elif echo "x" | sed -r "s/x/y/" >/dev/null 2>/dev/null; then
-                STRIPPED_LIBRARY_NAME="$(echo "${NETCDF_LIBS}" | sed -r 's:-L/(usr/)?(lib(64)?|lib/x86_64-linux-gnu)/*[[:space:]]+::')"
-    else
-        STRIPPED_LIBRARY_NAME="$(echo "${NETCDF_LIBS}")"
-    fi
-
-    NETCDF_LIBS="$STRIPPED_LIBRARY_NAME"
+    NETCDF_LIBS=`$NETCDF_NCCONFIG --static --libs`
     echo ""
     { $as_echo "$as_me:${as_lineno-$LINENO}: result:  got version=\"$NETCDF_VERSION\", prefix=\"$NETCDF_PREFIX\",
  libs=\"$NETCDF_LIBS\", includedir=\"$NETCDF_INCLUDEDIR\"" >&5
 $as_echo " got version=\"$NETCDF_VERSION\", prefix=\"$NETCDF_PREFIX\",
  libs=\"$NETCDF_LIBS\", includedir=\"$NETCDF_INCLUDEDIR\"" >&6; }
 
-    SAVED_LIBS="${LIBS}"
-    LIBS="$NETCDF_LIBS"
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for nc_open in -lnetcdf" >&5
 $as_echo_n "checking for nc_open in -lnetcdf... " >&6; }
 if ${ac_cv_lib_netcdf_nc_open+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lnetcdf  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char nc_open ();
-int
-main ()
-{
-return nc_open ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_netcdf_nc_open=yes
-else
-  ac_cv_lib_netcdf_nc_open=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_netcdf_nc_open" >&5
-$as_echo "$ac_cv_lib_netcdf_nc_open" >&6; }
-if test "x$ac_cv_lib_netcdf_nc_open" = xyes; then :
-  NETCDF_SETTING=yes
-else
-  NETCDF_SETTING=no
-fi
-
-    if test "$NETCDF_SETTING" = "no" ; then
-      unset ac_cv_lib_netcdf_nc_open
-      LIBS="$NETCDF_STATIC_LIBS"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for nc_open in -lnetcdf" >&5
-$as_echo_n "checking for nc_open in -lnetcdf... " >&6; }
-if ${ac_cv_lib_netcdf_nc_open+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lnetcdf  $LIBS"
+LIBS="-lnetcdf $NETCDF_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -32391,13 +32333,13 @@
   NETCDF_SETTING=no
 fi
 
-    fi
-    LIBS="${SAVED_LIBS}"
 
     if test "$NETCDF_SETTING" = "yes" ; then
       EXTRA_INCLUDES="-I$NETCDF_INCLUDEDIR $EXTRA_INCLUDES"
       NETCDF_ROOT=$NETCDF_PREFIX
       LIBS="$NETCDF_LIBS $LIBS"
+    else
+      as_fn_error $? "\"Netcdf via nc-config not working\"" "$LINENO" 5
     fi
 
 
@@ -37142,7 +37084,7 @@
 
       HAVE_GEOS="no"
 
-      GEOS_LIBS="`${GEOS_CONFIG} --ldflags` -lgeos_c"
+      GEOS_LIBS="`${GEOS_CONFIG} --static-clibs`"
       GEOS_CFLAGS="`${GEOS_CONFIG} --cflags`"
       GEOS_VERSION="`${GEOS_CONFIG} --version`"
 
@@ -41477,7 +41419,7 @@
         if test $RETVAL -eq 0; then
             { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
-            CXXFLAGS="$CXXFLAGS -DSUPPORTS_WMAIN"
+            CPPFLAGS="$CPPFLAGS -DSUPPORTS_WMAIN"
             LDFLAGS="$LDFLAGS -municode"
         else
             { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
diff -Nru gdal-3.5.0-orig/configure.ac gdal-3.5.0-patched/configure.ac
--- gdal-3.5.0-orig/configure.ac	2022-05-10 10:03:37.000000000 -0400
+++ gdal-3.5.0-patched/configure.ac	2022-09-14 04:39:20.903982131 -0400
@@ -1537,16 +1537,21 @@
     ,,)
 
 HAVE_SPATIALITE=no
+HAVE_SPAT_PKG=no
 
 if test -z "$with_spatialite" -o "$with_spatialite" = "no"; then
     AC_MSG_RESULT(disabled)
 elif test "$with_spatialite" = "yes"; then
     AC_CHECK_HEADERS(sqlite3.h)
     if test "$ac_cv_header_sqlite3_h" = "yes"; then
-        AC_MSG_CHECKING([for spatialite.h in /usr/include or /usr/local/include])
-        if test -f "/usr/include/spatialite.h" -o -f "/usr/local/include/spatialite.h"; then
-            AC_MSG_RESULT(found)
+        #AC_MSG_CHECKING([for spatialite.h in /usr/include or /usr/local/include])
+        #if test -f "/usr/include/spatialite.h" -o -f "/usr/local/include/spatialite.h"; then
+        PKG_CHECK_MODULES(SPATIALITE, spatialite, [HAVE_SPAT_PKG=yes], [HAVE_SPAT_PKG=no])        
+        if test "$HAVE_SPAT_PKG" = "yes"; then
+            OLD_LIBS="$LIBS"
+            LIBS="$LIBS -lsqlite3 -lspatialite -lgeos_c -lgeos -lxml2 -liconv -llzma -lproj -lstdc++ -lws2_32 -lm -lz"
             AC_CHECK_LIB(spatialite,spatialite_init,SPATIALITE_INIT_FOUND=yes,SPATIALITE_INIT_FOUND=no,-lsqlite3)
+            LIBS="$OLD_LIBS"
             if test "$SPATIALITE_INIT_FOUND" = "yes"; then
                 HAVE_SPATIALITE=yes
                 SPATIALITE_LIBS="-lspatialite -lsqlite3"
@@ -2936,28 +2941,19 @@
     NETCDF_VERSION=`$NETCDF_NCCONFIG --version`
     NETCDF_PREFIX=`$NETCDF_NCCONFIG --prefix`
     NETCDF_INCLUDEDIR=`$NETCDF_NCCONFIG --includedir`
-    NETCDF_LIBS=`$NETCDF_NCCONFIG --libs`
-    NETCDF_STATIC_LIBS=`$NETCDF_NCCONFIG --static --libs`
-    STRIP_SYSTEM_LIBRARY_PATHS("${NETCDF_LIBS}")
-    NETCDF_LIBS="$STRIPPED_LIBRARY_NAME"
+    NETCDF_LIBS=`$NETCDF_NCCONFIG --static --libs`
     echo ""
     AC_MSG_RESULT([ got version="$NETCDF_VERSION", prefix="$NETCDF_PREFIX",
  libs="$NETCDF_LIBS", includedir="$NETCDF_INCLUDEDIR"])
 
-    SAVED_LIBS="${LIBS}"
-    LIBS="$NETCDF_LIBS"
-    AC_CHECK_LIB([netcdf], [nc_open], [NETCDF_SETTING=yes], [NETCDF_SETTING=no],)
-    if test "$NETCDF_SETTING" = "no" ; then
-      unset ac_cv_lib_netcdf_nc_open
-      LIBS="$NETCDF_STATIC_LIBS"
-      AC_CHECK_LIB([netcdf], [nc_open], [NETCDF_SETTING=yes], [NETCDF_SETTING=no],)
-    fi
-    LIBS="${SAVED_LIBS}"
+    AC_CHECK_LIB([netcdf], [nc_open], [NETCDF_SETTING=yes], [NETCDF_SETTING=no], $NETCDF_LIBS)
 
     if test "$NETCDF_SETTING" = "yes" ; then
       EXTRA_INCLUDES="-I$NETCDF_INCLUDEDIR $EXTRA_INCLUDES"
       NETCDF_ROOT=$NETCDF_PREFIX
       LIBS="$NETCDF_LIBS $LIBS"
+    else
+      AC_MSG_ERROR("Netcdf via nc-config not working")
     fi
 
 dnl previous behavior without nc-config
@@ -5629,7 +5625,7 @@
         rm -f testwmain*
         if test $RETVAL -eq 0; then
             AC_MSG_RESULT([yes])
-            CXXFLAGS="$CXXFLAGS -DSUPPORTS_WMAIN"
+            CPPFLAGS="$CPPFLAGS -DSUPPORTS_WMAIN"
             LDFLAGS="$LDFLAGS -municode"
         else
             AC_MSG_RESULT([no])
diff -Nru gdal-3.5.0-orig/configure.ac~ gdal-3.5.0-patched/configure.ac~
--- gdal-3.5.0-orig/configure.ac~	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.5.0-patched/configure.ac~	2022-09-13 14:32:47.000000000 -0400
@@ -0,0 +1,5778 @@
+dnl ***************************************************************************
+dnl $Id$
+dnl
+dnl Project:  GDAL
+dnl Purpose:  Configure source file.
+dnl Author:   Frank Warmerdam, warmerdam@pobox.com
+dnl
+dnl ***************************************************************************
+dnl Copyright (c) 2000, Frank Warmerdam
+dnl
+dnl Permission is hereby granted, free of charge, to any person obtaining a
+dnl copy of this software and associated documentation files (the "Software"),
+dnl to deal in the Software without restriction, including without limitation
+dnl the rights to use, copy, modify, merge, publish, distribute, sublicense,
+dnl and/or sell copies of the Software, and to permit persons to whom the
+dnl Software is furnished to do so, subject to the following conditions:
+dnl
+dnl The above copyright notice and this permission notice shall be included
+dnl in all copies or substantial portions of the Software.
+dnl
+dnl THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+dnl OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+dnl FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+dnl THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+dnl LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+dnl FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+dnl DEALINGS IN THE SOFTWARE.
+dnl ***************************************************************************
+
+dnl Disable configure caching ... it causes lots of hassles.
+define([AC_CACHE_LOAD], )
+define([AC_CACHE_SAVE], )
+
+dnl Process this file with autoconf to produce a configure script.
+AC_INIT
+AC_CONFIG_SRCDIR([GDALmake.opt.in])
+AC_SUBST(PACKAGE, gdal)
+AC_CONFIG_MACRO_DIR(m4)
+AC_CONFIG_HEADERS([generated_headers/cpl_config.h:port/cpl_config.h.in])
+AH_TOP([#ifndef CPL_CONFIG_H])
+AH_TOP([#define CPL_CONFIG_H])
+AH_BOTTOM([#include "cpl_config_extras.h"])
+AH_BOTTOM([#endif])
+
+AC_PREREQ([2.69])
+
+dnl Compute the canonical host-system (the system we are building for)
+dnl type variable $host
+AC_CANONICAL_HOST
+
+dnl Enable as much warnings as possible
+AC_LANG_PUSH([C])
+AX_COMPILER_VENDOR
+AC_LANG_POP([C])
+AX_CFLAGS_WARN_ALL(C_WFLAGS)
+AC_LANG_PUSH([C++])
+AX_COMPILER_VENDOR
+AC_LANG_POP([C++])
+AX_CXXFLAGS_WARN_ALL(CXX_WFLAGS)
+
+dnl Remove -Wdeclaration-after-statement that is no longer appropriate in C99
+C_WFLAGS=`echo "$C_WFLAGS " | sed "s/-Wdeclaration-after-statement //"`
+
+dnl For ICC: it needs -we10006 instead of -Werror to turn unknown options to errors
+dnl Some gcc/clang versions might succeed on this test, so also include -Werror in ERROR_ON_UNKNOWN_OPTIONS
+AX_CHECK_COMPILE_FLAG([-Werror -we10006],[ERROR_ON_UNKNOWN_OPTIONS="-Werror -we10006"],[ERROR_ON_UNKNOWN_OPTIONS="-Werror"])
+
+dnl A few ICC warnings to turn off
+dnl warning #188: enumerated type mixed with another type  (needed on libcsf)
+dnl warning #1684: conversion from pointer to same-sized integral type (potential portability problem)  (needed on frmts/mrf)
+dnl warning #2259: non-pointer conversion from "size_t={unsigned long}" to "int" may lose significant bits
+dnl warning #2304: non-explicit constructor with single argument may cause implicit type conversion
+dnl warning #3280: declaration hides member
+dnl remark #11074: Inlining inhibited by limit max-size
+dnl remark #11076: To get full report use -qopt-report=4 -qopt-report-phase ipo
+AX_CHECK_COMPILE_FLAG([-diag-disable 188,1684,2259,2304,3280,11074,11076],[C_WFLAGS="$C_WFLAGS -diag-disable 188,1684,2259,2304,3280,11074,11076" CXX_WFLAGS="$CXX_WFLAGS -diag-disable 188,1684,2259,2304,3280,11074,11076"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+AX_CHECK_COMPILE_FLAG([-Wextra],[C_WFLAGS="$C_WFLAGS -Wextra" CXX_WFLAGS="$CXX_WFLAGS -Wextra"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Winit-self],[C_WFLAGS="$C_WFLAGS -Winit-self" CXX_WFLAGS="$CXX_WFLAGS -Winit-self"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wunused-parameter], [C_WFLAGS="$C_WFLAGS -Wunused-parameter" CXX_WFLAGS="$CXX_WFLAGS -Wunused-parameter" NO_UNUSED_PARAMETER_FLAG="-Wno-unused-parameter"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wmissing-prototypes], [C_WFLAGS="$C_WFLAGS -Wmissing-prototypes"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wmissing-declarations], [C_WFLAGS="$C_WFLAGS -Wmissing-declarations"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wformat], [C_WFLAGS="$C_WFLAGS -Wformat" CXX_WFLAGS="$CXX_WFLAGS -Wformat"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wformat -Werror=format-security -Wno-format-nonliteral], [C_WFLAGS="$C_WFLAGS -Werror=format-security -Wno-format-nonliteral" CXX_WFLAGS="$CXX_WFLAGS -Werror=format-security -Wno-format-nonliteral"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wshorten-64-to-32], [C_WFLAGS="$C_WFLAGS -Wshorten-64-to-32" CXX_WFLAGS="$CXX_WFLAGS -Wshorten-64-to-32"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wlogical-op], [C_WFLAGS="$C_WFLAGS -Wlogical-op" CXX_WFLAGS="$CXX_WFLAGS -Wlogical-op" NO_LOGICAL_OP_FLAG="-Wno-logical-op"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wshadow], [C_WFLAGS="$C_WFLAGS -Wshadow" CXX_WFLAGS="$CXX_WFLAGS -Wshadow"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wmissing-include-dirs], [C_WFLAGS="$C_WFLAGS -Wmissing-include-dirs" CXX_WFLAGS="$CXX_WFLAGS -Wmissing-include-dirs"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl Error out on things that will fail with MSVC
+AX_CHECK_COMPILE_FLAG([-Werror=vla], [C_WFLAGS="$C_WFLAGS -Werror=vla" CXX_WFLAGS="$CXX_WFLAGS -Werror=vla"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl -Wclobbered is not reliable on most gcc versions
+dnl AX_CHECK_COMPILE_FLAG([-Wno-clobbered], [C_WFLAGS="$C_WFLAGS -Wno-clobbered" CXX_WFLAGS="$CXX_WFLAGS -Wno-clobbered"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl Warn when macros __TIME__, __DATE__ or __TIMESTAMP__ are encountered as they might prevent bit-wise-identical reproducible compilations.
+AX_CHECK_COMPILE_FLAG([-Wdate-time], [C_WFLAGS="$C_WFLAGS -Wdate-time" CXX_WFLAGS="$CXX_WFLAGS -Wdate-time"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl GCC 6 warnings
+AX_CHECK_COMPILE_FLAG([-Wnull-dereference], [C_WFLAGS="$C_WFLAGS -Wnull-dereference" CXX_WFLAGS="$CXX_WFLAGS -Wnull-dereference"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wduplicated-cond], [C_WFLAGS="$C_WFLAGS -Wduplicated-cond" CXX_WFLAGS="$CXX_WFLAGS -Wduplicated-cond"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl GCC 7 warnings
+dnl Do not enable yet. Causes warning in alg/gdalthinplate.cpp due to armadillo templates
+dnl AX_CHECK_COMPILE_FLAG([-Wduplicated-branches], [C_WFLAGS="$C_WFLAGS -Wduplicated-branches" CXX_WFLAGS="$CXX_WFLAGS -Wduplicated-branches"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl GCC 8 warnings
+AC_LANG_PUSH([C++])
+AX_CHECK_COMPILE_FLAG([-Wextra-semi], [CXX_WFLAGS="$CXX_WFLAGS -Wextra-semi"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AC_LANG_POP([C++])
+
+dnl clang >= 3.9
+AX_CHECK_COMPILE_FLAG([-Wcomma], [C_WFLAGS="$C_WFLAGS -Wcomma" CXX_WFLAGS="$CXX_WFLAGS -Wcomma"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl clang and gcc 5
+AX_CHECK_COMPILE_FLAG([-Wfloat-conversion], [C_WFLAGS="$C_WFLAGS -Wfloat-conversion" CXX_WFLAGS="$CXX_WFLAGS -Wfloat-conversion"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl clang >= 3.2
+AX_CHECK_COMPILE_FLAG([-Wdocumentation -Wno-documentation-deprecated-sync], [C_WFLAGS="$C_WFLAGS -Wdocumentation -Wno-documentation-deprecated-sync" CXX_WFLAGS="$CXX_WFLAGS -Wdocumentation -Wno-documentation-deprecated-sync"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl C++ specific stuff
+
+AC_LANG_PUSH([C++])
+AX_CHECK_COMPILE_FLAG([-Wunused-private-field], [CXX_WFLAGS="$CXX_WFLAGS -Wunused-private-field"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wmissing-declarations], [CXX_WFLAGS="$CXX_WFLAGS -Wmissing-declarations"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wnon-virtual-dtor], [CXX_WFLAGS="$CXX_WFLAGS -Wnon-virtual-dtor" NO_NON_VIRTUAL_DTOR_FLAG="-Wno-non-virtual-dtor"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wold-style-cast], [WARN_OLD_STYLE_CAST="-Wold-style-cast"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Weffc++], [WARN_EFFCPLUSPLUS="-Weffc++"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl g++-4.8 complain a bit too much with -Weffc++
+if test "$WARN_EFFCPLUSPLUS" != ""; then
+    SAVED_CXXFLAGS=$CXXFLAGS
+    CXXFLAGS="$CXXFLAGS $WARN_EFFCPLUSPLUS -Werror"
+    AC_MSG_CHECKING([if -Weffc++ should be enabled])
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+    [[
+    class Base {};
+    class A: public Base {};
+    ]])],
+    [AC_MSG_RESULT([yes])],
+    [WARN_EFFCPLUSPLUS=""]
+    [AC_MSG_RESULT([no])])
+    CXXFLAGS=$SAVED_CXXFLAGS
+fi
+
+dnl Clang enables -Woverloaded-virtual if -Wall is defined, but not GCC
+AX_CHECK_COMPILE_FLAG([-Woverloaded-virtual], [CXX_WFLAGS="$CXX_WFLAGS -Woverloaded-virtual"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl Forbid use of 'or', 'and', ... alias operators
+AX_CHECK_COMPILE_FLAG([-fno-operator-names], [CXX_WFLAGS="$CXX_WFLAGS -fno-operator-names"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT=no
+AX_CHECK_COMPILE_FLAG([-Wzero-as-null-pointer-constant], [CXX_WFLAGS="$CXX_WFLAGS -Wzero-as-null-pointer-constant" HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT=yes],,[$ERROR_ON_UNKNOWN_OPTIONS])
+if test "$HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT" = "yes"; then
+AC_DEFINE_UNQUOTED(HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT, 1,
+          [Define to 1 if the compiler supports -Wzero-as-null-pointer-constant])
+fi
+
+AC_LANG_POP([C++])
+
+CXX14_SUPPORT=no
+AC_ARG_WITH([cpp14],
+	    AS_HELP_STRING([--with-cpp14],
+	       [Enable C++14 compiler options]),,)
+
+AC_MSG_CHECKING([if use C++14 compiler options])
+if test "$with_cpp14" = "yes"; then
+    dnl Check C++ compiler compatibility with C++14
+    AC_MSG_CHECKING([C++ compiler compatibility with C++14])
+    AX_CXX_COMPILE_STDCXX([14],[noext],[optional])
+
+    if [test "$HAVE_CXX14" = "1"]; then
+        CXX14_SUPPORT=yes
+    fi
+    AC_MSG_RESULT([enabled])
+else
+    AC_MSG_RESULT([disabled by user])
+fi
+AC_SUBST(CXX14_SUPPORT,$CXX14_SUPPORT)
+
+if [test "$CXX14_SUPPORT" = "no"]; then
+    AX_CXX_COMPILE_STDCXX_11([noext],[mandatory])
+fi
+
+dnl Available in GCC 5.1
+AC_LANG_PUSH([C++])
+    AX_CHECK_COMPILE_FLAG([-Wsuggest-override], [CXX_WFLAGS="$CXX_WFLAGS -Wsuggest-override"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AC_LANG_POP([C++])
+
+dnl Enable -Wimplicit-fallthrough only if C++11 is enabled since CPL_FALLTHROUGH is only active then
+AC_LANG_PUSH([C++])
+SAVED_CXXFLAGS=$CXXFLAGS
+CXXFLAGS="$CXXFLAGS $ERROR_ON_UNKNOWN_OPTIONS -Wimplicit-fallthrough"
+AC_MSG_CHECKING([if -Wimplicit-fallthrough can be enabled])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+  [[#if !(__cplusplus >= 201103L && ( (defined(__clang__) && (__clang_major__ > 3 || (__clang_major__ == 3 && __clang_minor__ >=7))) || ((defined(__GNUC__) && __GNUC__ >= 7)) ) )
+    #error "not (C++11 and (clang >= 3.7 or gcc >= 7))"
+    #endif]])],
+  [CXX_WFLAGS="$CXX_WFLAGS -Wimplicit-fallthrough"]
+  [AC_MSG_RESULT([yes])],
+  [AC_MSG_RESULT([no])])
+CXXFLAGS=$SAVED_CXXFLAGS
+AC_LANG_POP([C++])
+
+AC_SUBST(CXX_WFLAGS,$CXX_WFLAGS)
+AC_SUBST(C_WFLAGS,$C_WFLAGS)
+AC_SUBST(NO_UNUSED_PARAMETER_FLAG,$NO_UNUSED_PARAMETER_FLAG)
+AC_SUBST(NO_SIGN_COMPARE,$NO_SIGN_COMPARE)
+AC_SUBST(NO_NON_VIRTUAL_DTOR_FLAG,$NO_NON_VIRTUAL_DTOR_FLAG)
+AC_SUBST(NO_LOGICAL_OP_FLAG,$NO_LOGICAL_OP_FLAG)
+AC_SUBST(WARN_OLD_STYLE_CAST,$WARN_OLD_STYLE_CAST)
+AC_SUBST(WARN_EFFCPLUSPLUS,$WARN_EFFCPLUSPLUS)
+
+dnl Checks for programs.
+
+dnl AC_PROG_CC_C99 is deprecated since autoconf 2.70
+m4_if(m4_version_compare(m4_defn([AC_AUTOCONF_VERSION]), [2.70]),
+     [-1], [AC_PROG_CC_C99], [AC_PROG_CC])
+
+AC_PROG_CXX
+LT_INIT([win32-dll])
+
+dnl Check that CXX is really a working compiler
+AC_LANG_PUSH([C++])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+  [[#ifndef __cplusplus
+    #error "broken C++"
+    #endif]])],,
+  [CXX=;])
+AC_LANG_POP([C++])
+
+if test "x$CXX" = x ; then
+  AC_MSG_ERROR("You don't have a working C++ compiler.")
+fi
+
+AC_MSG_CHECKING([for std::isnan])
+AC_LANG_PUSH([C++])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+  [[#include <cmath>
+    int CPLIsNan(float f) { return std::isnan(f); }]])],
+  [
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_STD_IS_NAN, 1,
+          [Define to 1 if you have the `std::isnan' function.])
+  ], [
+    AC_MSG_RESULT([no])
+  ])
+AC_LANG_POP([C++])
+
+dnl switch between libtool and native build system
+AC_ARG_WITH(libtool, [  --without-libtool     Don't use libtool to build the library],,)
+
+if test "$with_libtool" = "no"; then
+AC_PROG_RANLIB
+
+dnl AC_COMPILER_PIC as expanded by autoconf-2.68 doesn't work for the C++ part with clang++ 3.0 that doesn't like compiling .c programs
+dnl so we inline the expanded code and fix it at hand.
+dnl AC_COMPILER_PIC
+	echo 'void f(){}' > conftest.c
+	if test -z "`${CC-cc} $CFLAGS -fPIC -c conftest.c 2>&1`"; then
+	  CFLAGS="$CFLAGS -fPIC"
+	fi
+	echo 'void f(){}' > conftest.cpp
+	if test -z "`${CXX-g++} $CXXFLAGS -fPIC -c conftest.cpp 2>&1`"; then
+	  CXXFLAGS="$CXXFLAGS -fPIC"
+	fi
+	rm -f conftest*
+
+dnl Trick so that LD_SHARED test works with sanitizer flags with clang
+SAVED_CFLAGS=$CFLAGS
+CFLAGS=`echo "$CFLAGS " | sed "s/-fsanitize=undefined //" | sed "s/-fsanitize=address //" | sed "s/-fsanitize=unsigned-integer-overflow //"`
+AC_LD_SHARED
+CFLAGS=$SAVED_CFLAGS
+else
+with_libtool=yes
+fi
+AC_SUBST(HAVE_LIBTOOL,$with_libtool)
+
+dnl Checks for libraries.
+AC_CHECK_LIB(dl,dlopen,,,)
+
+dnl Needed on Solaris.
+AC_CHECK_LIB(rt,nanosleep,,,)
+
+dnl We don't need to add math library to all targets
+case "${host_os}" in
+    cygwin* | mingw32* | pw32* | beos* | darwin*)
+        ;;
+    *)
+	AC_CHECK_LIB(m,sin,,,)
+        ;;
+esac
+
+dnl Checks for header files.
+AC_CHECK_HEADERS(fcntl.h unistd.h dlfcn.h locale.h direct.h)
+
+dnl Check for userfaultfd support
+AC_CHECK_HEADERS([linux/userfaultfd.h], [ENABLE_UFFD="yes"], [ENABLE_UFFD="no"], [])
+AC_SUBST(ENABLE_UFFD,$ENABLE_UFFD)
+
+dnl cpl_vsil_unix_stdio_64.h requires linux/fs.h on Linux, and this isn't
+dnl installed by default on Alpine
+case "${host_os}" in
+    linux*)
+        AC_CHECK_HEADERS([linux/fs.h], [], [AC_MSG_ERROR([Unable to find linux/fs.h header])])
+        ;;
+    *)
+        ;;
+esac
+
+AC_C_BIGENDIAN
+
+dnl Check for 64 bit file API
+AC_UNIX_STDIO_64
+
+AC_CHECK_SIZEOF(int)
+AC_CHECK_SIZEOF(unsigned long)
+AC_CHECK_SIZEOF(void*)
+
+dnl Checks for library functions.
+AC_CHECK_FUNCS(vsnprintf)
+AC_CHECK_FUNCS(getcwd)
+AC_CHECK_FUNCS(readlink)
+AC_CHECK_FUNCS(lstat)
+AC_CHECK_FUNCS(posix_spawnp)
+AC_CHECK_FUNCS(posix_memalign)
+AC_CHECK_FUNCS(vfork)
+AC_CHECK_FUNCS(mmap)
+AC_CHECK_FUNCS(sigaction)
+AC_CHECK_FUNCS(statvfs)
+AC_CHECK_FUNCS(statvfs64)
+AC_CHECK_FUNCS(getrlimit)
+
+AC_MSG_CHECKING([for RLIMIT_AS])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <sys/time.h>
+#include <sys/resource.h>
+  ]], [[
+    return RLIMIT_AS;
+  ]])],[
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_RLIMIT_AS, 1,
+          [Define to 1 if you have the `RLIMIT_AS' constant.])
+  ],[
+    AC_MSG_RESULT([no])
+])
+
+
+dnl Make sure at least these are checked under C++.  Prototypes missing on
+dnl some platforms.
+
+AC_LANG_PUSH(C++)
+AC_CHECK_FUNC_CUSTOM(gmtime_r,[#include <time.h>],[time_t t; struct tm ltime; t = time(0); gmtime_r( &t, &ltime );])
+AC_CHECK_FUNC_CUSTOM(localtime_r,[#include <time.h>],[time_t t; struct tm ltime; t = time(0); localtime_r( &t, &ltime );])
+AC_LANG_POP(C++)
+
+AC_CHECK_HEADERS([xlocale.h],[HAVE_XLOCALE_H=1])
+if test "$HAVE_XLOCALE_H" = "1"; then
+  AC_DEFINE_UNQUOTED(HAVE_XLOCALE_H, 1,
+            [Define if you have the <xlocale.h> header file.])
+fi
+
+AC_MSG_CHECKING([for uselocale])
+AC_LANG_PUSH(C++)
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define _XOPEN_SOURCE 700
+#include <locale.h>
+  ]], [[
+    locale_t alocale = newlocale (LC_NUMERIC_MASK, "C", 0);
+    locale_t oldlocale = uselocale(alocale);
+    uselocale(oldlocale);
+    freelocale(alocale);
+    return 0;
+  ]])],[
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_USELOCALE, 1,
+          [Define to 1 if you have the `uselocale' function.])
+  ],[
+    AC_MSG_RESULT([no])
+])
+AC_LANG_POP(C++)
+
+
+OPT_GDAL_FORMATS=
+EXTRA_INCLUDES=
+
+dnl ---------------------------------------------------------------------------
+dnl Check for --enable-debug
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([to enable debug build])
+
+AC_ARG_ENABLE(debug,
+	      AS_HELP_STRING([--enable-debug],
+			     [enable debugging (disabled by default)]),
+	      [HAVE_DEBUG=$enableval], [HAVE_DEBUG=yes])
+
+CFLAGS_NOFTRAPV="$CFLAGS"
+CXXFLAGS_NOFTRAPV="$CXXFLAGS"
+
+if test "x$enable_debug" = "xyes" ; then
+
+  dnl Try to strip out optimization.
+
+  CXXFLAGS=`echo "$CXXFLAGS " | sed "s/-O2 //"`
+  CFLAGS=`echo "$CFLAGS " | sed "s/-O2 //"`
+  CXXFLAGS=`echo "$CXXFLAGS" | sed "s/-O //"`
+  CFLAGS=`echo "$CFLAGS" | sed "s/-O //"`
+
+  dnl remove existing -g to avoid duplicates.
+
+  CXXFLAGS=`echo "$CXXFLAGS" | sed "s/-g //"`
+  CFLAGS=`echo "$CFLAGS" | sed "s/-g //"`
+
+  dnl add -g and -DDEBUG
+
+  CXXFLAGS="$CXXFLAGS -g -DDEBUG"
+  CFLAGS="$CFLAGS -g -DDEBUG"
+
+  CFLAGS_NOFTRAPV="$CFLAGS"
+  CXXFLAGS_NOFTRAPV="$CXXFLAGS"
+
+  AC_MSG_RESULT([yes, modified CFLAGS="$CFLAGS"])
+
+  # Some clang version on 32 bits have linking error with 64bit operations (undefined reference to `__mulodi4')
+  AC_MSG_CHECKING([whether -ftrapv can be used])
+  rm -f testftrapv.c
+  echo 'int main(int argc, char** argv) { return (long long)argc * argc; } ' > testftrapv.c
+  if test -z "`${CC} ${CFLAGS} -ftrapv testftrapv.c -o testftrapv 2>&1`" ; then
+    AC_MSG_RESULT([yes])
+    CFLAGS="$CFLAGS -ftrapv"
+    CXXFLAGS="$CXXFLAGS -ftrapv"
+  else
+    AC_MSG_RESULT([no])
+  fi
+  rm -f testftrapv.* testftrapv
+
+else
+  AC_MSG_RESULT([no, CFLAGS="$CFLAGS"])
+fi
+
+AC_SUBST(CFLAGS_NOFTRAPV,$CFLAGS_NOFTRAPV)
+AC_SUBST(CXXFLAGS_NOFTRAPV,$CXXFLAGS_NOFTRAPV)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if GCC 4.1 atomic builtins are really available
+dnl (some GCC versions are broken w.r.t this on some exotic architectures...)
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([whether GCC 4.1 atomic builtins are available])
+
+rm -f atomicbuiltins.c
+echo 'int main(int argc, char** argv) { int i; __sync_add_and_fetch(&i, 1); __sync_sub_and_fetch(&i, 1); __sync_bool_compare_and_swap(&i, 0, 1); return 0; } ' > atomicbuiltins.c
+if test -z "`${CC} ${CFLAGS} atomicbuiltins.c -o atomicbuiltins 2>&1`" ; then
+    HAVE_GCC_ATOMIC_BUILTINS=yes
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_GCC_ATOMIC_BUILTINS,1, [Define to 1 if GCC atomic builtins are available])
+else
+    HAVE_GCC_ATOMIC_BUILTINS=no
+    AC_MSG_RESULT([no])
+fi
+rm -rf atomicbuiltins.* atomicbuiltins
+
+AC_SUBST(HAVE_GCC_ATOMIC_BUILTINS,$HAVE_GCC_ATOMIC_BUILTINS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if GCC bswap builtins are available
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([whether GCC bswap builtins are available])
+
+rm -f bswapbuiltins.c
+echo 'int main(int argc, char** argv) { (void)__builtin_bswap32(0); (void)__builtin_bswap64(0); return 0; } ' >> bswapbuiltins.c
+if test -z "`${CC} ${CFLAGS} bswapbuiltins.c -o bswapbuiltins 2>&1`" ; then
+    HAVE_GCC_BSWAP=yes
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_GCC_BSWAP,1, [Define to 1 if GCC bswap builtins are available])
+else
+    HAVE_GCC_BSWAP=no
+    AC_MSG_RESULT([no])
+fi
+rm -rf bswapbuiltins.* bswapbuiltins
+
+AC_SUBST(HAVE_GCC_BSWAP,$HAVE_GCC_BSWAP)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if __uint128_t is available and usable
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([for __uint128_t])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+  ]], [[
+      unsigned long long v1 = 1024ULL;
+      unsigned long long v2 = 0x8000000000000000ULL;
+      __uint128_t u = ((__uint128_t)v1)*((__uint128_t)v2);
+      return u == 0;
+  ]])],[
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_UINT128_T, 1,
+          [Define to 1 if the system has the type __uint128_t])
+  ],[
+    AC_MSG_RESULT([no])
+])
+
+dnl ---------------------------------------------------------------------------
+dnl Check SSE availability
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(sse,
+[  --with-sse[=ARG]        Detect SSE availability for some optimized routines (ARG=yes(default), no)],,)
+
+AC_MSG_CHECKING([whether SSE is available at compile time])
+
+if test "$with_sse" = "yes" -o "$with_sse" = ""; then
+
+    rm -f detectsse.cpp
+    echo '#ifdef __SSE__' > detectsse.cpp
+    echo '#include <xmmintrin.h>' >> detectsse.cpp
+    echo 'void foo() { float fEpsilon = 0.0000000000001f; __m128 xmm_small = _mm_load1_ps(&fEpsilon); }  int main() { return 0; }' >> detectsse.cpp
+    echo '#else' >> detectsse.cpp
+    echo 'some_error' >> detectsse.cpp
+    echo '#endif' >> detectsse.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -o detectsse detectsse.cpp 2>&1`" ; then
+        AC_MSG_RESULT([yes])
+        SSEFLAGS=""
+        HAVE_SSE_AT_COMPILE_TIME=yes
+    else
+        if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -msse -o detectsse detectsse.cpp 2>&1`" ; then
+            AC_MSG_RESULT([yes])
+            SSEFLAGS="-msse"
+            HAVE_SSE_AT_COMPILE_TIME=yes
+        else
+            AC_MSG_RESULT([no])
+            if test "$with_sse" = "yes"; then
+                AC_MSG_ERROR([--with-sse was requested, but SSE is not available])
+            fi
+        fi
+    fi
+
+    dnl On Solaris, the presence of SSE instructions is flagged in the binary
+    dnl and prevent it to run on non SSE hardware even if the instructions are
+    dnl not executed. So if the user did not explicitly requires SSE, test that
+    dnl we can run SSE binaries
+    if test "$HAVE_SSE_AT_COMPILE_TIME" = "yes"; then
+       case $host_os in
+         solaris*)
+           AC_MSG_CHECKING([whether SSE is available and needed at runtime])
+           if ./detectsse; then
+             AC_MSG_RESULT([yes])
+           else
+             AC_MSG_RESULT([no])
+             if test "$with_sse" = "yes"; then
+               echo "Caution: the generated binaries will not run on this system."
+             else
+               echo "Disabling SSE as it is not explicitly required"
+               HAVE_SSE_AT_COMPILE_TIME=""
+               SSEFLAGS=""
+             fi
+           fi
+           ;;
+       esac
+    fi
+
+    if test "$HAVE_SSE_AT_COMPILE_TIME" = "yes"; then
+        CFLAGS="-DHAVE_SSE_AT_COMPILE_TIME $CFLAGS"
+        CXXFLAGS="-DHAVE_SSE_AT_COMPILE_TIME $CXXFLAGS"
+    fi
+
+    rm -rf detectsse*
+else
+    AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(SSEFLAGS,$SSEFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check SSSE3 availability
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(ssse3,
+[  --with-ssse3[=ARG]        Detect SSSE3 availability for some optimized routines (ARG=yes(default), no)],,)
+
+AC_MSG_CHECKING([whether SSSE3 is available at compile time])
+
+if test "$with_ssse3" = "yes" -o "$with_ssse3" = ""; then
+
+    rm -f detectssse3.cpp
+    echo '#ifdef __SSSE3__' > detectssse3.cpp
+    echo '#include <tmmintrin.h>' >> detectssse3.cpp
+    echo 'void foo() { __m128i xmm_i = _mm_set1_epi16(0); xmm_i = _mm_shuffle_epi8(xmm_i, xmm_i); }  int main() { return 0; }' >> detectssse3.cpp
+    echo '#else' >> detectssse3.cpp
+    echo 'some_error' >> detectssse3.cpp
+    echo '#endif' >> detectssse3.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -o detectssse3 detectssse3.cpp 2>&1`" ; then
+        AC_MSG_RESULT([yes])
+        SSSE3FLAGS=""
+        HAVE_SSSE3_AT_COMPILE_TIME=yes
+    else
+        if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -mssse3 -o detectssse3 detectssse3.cpp 2>&1`" ; then
+            AC_MSG_RESULT([yes])
+            SSSE3FLAGS="-mssse3"
+            HAVE_SSSE3_AT_COMPILE_TIME=yes
+        else
+            AC_MSG_RESULT([no])
+            if test "$with_ssse3" = "yes"; then
+                AC_MSG_ERROR([--with-ssse3 was requested, but SSSE3 is not available])
+            fi
+        fi
+    fi
+
+    dnl On Solaris, the presence of SSSE3 instructions is flagged in the binary
+    dnl and prevent it to run on non SSSE3 hardware even if the instructions are
+    dnl not executed. So if the user did not explicitly requires SSSE3, test that
+    dnl we can run SSSE3 binaries
+    if test "$HAVE_SSSE3_AT_COMPILE_TIME" = "yes"; then
+       case $host_os in
+         solaris*)
+           AC_MSG_CHECKING([whether SSSE3 is available and needed at runtime])
+           if ./detectssse3; then
+             AC_MSG_RESULT([yes])
+           else
+             AC_MSG_RESULT([no])
+             if test "$with_ssse3" = "yes"; then
+               echo "Caution: the generated binaries will not run on this system."
+             else
+               echo "Disabling SSSE3 as it is not explicitly required"
+               HAVE_SSSE3_AT_COMPILE_TIME=""
+               SSSE3FLAGS=""
+             fi
+           fi
+           ;;
+       esac
+    fi
+
+    if test "$HAVE_SSSE3_AT_COMPILE_TIME" = "yes"; then
+        CFLAGS="-DHAVE_SSSE3_AT_COMPILE_TIME $CFLAGS"
+        CXXFLAGS="-DHAVE_SSSE3_AT_COMPILE_TIME $CXXFLAGS"
+    fi
+
+    rm -rf detectssse3*
+else
+    AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(SSSE3FLAGS,$SSSE3FLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check AVX availability
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(avx,
+[  --with-avx[=ARG]        Detect AVX availability for some optimized routines (ARG=yes(default), no)],,)
+
+AC_MSG_CHECKING([whether AVX is available at compile time])
+
+if test "$with_avx" = "yes" -o "$with_avx" = ""; then
+
+    rm -f detectavx.cpp
+    echo '#ifdef __AVX__' > detectavx.cpp
+    echo '#include <immintrin.h>' >> detectavx.cpp
+    echo 'int foo() { unsigned int nXCRLow, nXCRHigh;' >> detectavx.cpp
+    echo '__asm__ ("xgetbv" : "=a" (nXCRLow), "=d" (nXCRHigh) : "c" (0));' >> detectavx.cpp
+    echo 'float fEpsilon = 0.0000000000001f;' >> detectavx.cpp
+    echo '__m256 ymm_small = _mm256_set_ps(fEpsilon,fEpsilon,fEpsilon,fEpsilon,fEpsilon,fEpsilon,fEpsilon,fEpsilon);' >> detectavx.cpp
+    echo 'return (int)nXCRLow + _mm256_movemask_ps(ymm_small); }' >> detectavx.cpp
+    echo 'int main(int argc, char**) { if( argc == 0 ) return foo(); return 0; }' >> detectavx.cpp
+    echo '#else' >> detectavx.cpp
+    echo 'some_error' >> detectavx.cpp
+    echo '#endif' >> detectavx.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -o detectavx detectavx.cpp 2>&1`" ; then
+        AC_MSG_RESULT([yes])
+        AVXFLAGS=""
+        HAVE_AVX_AT_COMPILE_TIME=yes
+    else
+        if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -mavx -o detectavx detectavx.cpp 2>&1`" ; then
+            AC_MSG_RESULT([yes])
+            AVXFLAGS="-mavx"
+            HAVE_AVX_AT_COMPILE_TIME=yes
+        else
+            AC_MSG_RESULT([no])
+            if test "$with_avx" = "yes"; then
+                AC_MSG_ERROR([--with-avx was requested, but AVX is not available])
+            fi
+        fi
+    fi
+
+    dnl On Solaris, the presence of AVX instructions is flagged in the binary
+    dnl and prevent it to run on non AVX hardware even if the instructions are
+    dnl not executed. So if the user did not explicitly requires AVX, test that
+    dnl we can run AVX binaries
+    if test "$HAVE_AVX_AT_COMPILE_TIME" = "yes"; then
+       case $host_os in
+         solaris*)
+           AC_MSG_CHECKING([whether AVX is available and needed at runtime])
+           if ./detectavx; then
+             AC_MSG_RESULT([yes])
+           else
+             AC_MSG_RESULT([no])
+             if test "$with_avx" = "yes"; then
+               echo "Caution: the generated binaries will not run on this system."
+             else
+               echo "Disabling AVX as it is not explicitly required"
+               AVXFLAGS=""
+               HAVE_AVX_AT_COMPILE_TIME=""
+             fi
+           fi
+           ;;
+       esac
+    fi
+
+    if test "$HAVE_AVX_AT_COMPILE_TIME" = "yes"; then
+        CFLAGS="-DHAVE_AVX_AT_COMPILE_TIME $CFLAGS"
+        CXXFLAGS="-DHAVE_AVX_AT_COMPILE_TIME $CXXFLAGS"
+    fi
+
+    rm -rf detectavx*
+else
+    AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(AVXFLAGS,$AVXFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for --enable-lto
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([to enable LTO (link time optimization) build])
+
+AC_ARG_ENABLE(lto,
+              AS_HELP_STRING([--enable-lto],
+                             [enable LTO(link time optimization) (disabled by default)]))
+
+CXXFLAGS_NO_LTO_IF_AVX_NONDEFAULT="$CXXFLAGS"
+CXXFLAGS_NO_LTO_IF_SSSE3_NONDEFAULT="$CXXFLAGS"
+
+if test "x$enable_lto" = "xyes" ; then
+
+  dnl remove existing -g.
+
+  CXXFLAGS=`echo "$CXXFLAGS" | sed "s/-g //"`
+  CFLAGS=`echo "$CFLAGS" | sed "s/-g //"`
+
+  dnl add -flto
+
+  CXXFLAGS="$CXXFLAGS -flto"
+  CFLAGS="$CFLAGS -flto"
+  LDFLAGS="$LDFLAGS -flto"
+
+  dnl in case we have avx available by default, then we can compile everything
+  dnl with -flto
+  if test "$HAVE_AVX_AT_COMPILE_TIME" = "yes"; then
+    if test "$AVXFLAGS" = ""; then
+        CXXFLAGS_NO_LTO_IF_AVX_NONDEFAULT="$CXXFLAGS"
+    fi
+  fi
+  if test "$HAVE_SSSE3_AT_COMPILE_TIME" = "yes"; then
+    if test "$SSSE3FLAGS" = ""; then
+        CXXFLAGS_NO_LTO_IF_SSSE3_NONDEFAULT="$CXXFLAGS"
+    fi
+  fi
+
+  AC_MSG_RESULT([yes])
+else
+  AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(CXXFLAGS_NO_LTO_IF_AVX_NONDEFAULT,$CXXFLAGS_NO_LTO_IF_AVX_NONDEFAULT)
+AC_SUBST(CXXFLAGS_NO_LTO_IF_SSSE3_NONDEFAULT,$CXXFLAGS_NO_LTO_IF_SSSE3_NONDEFAULT)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if we need -lws2_32 (mingw)
+dnl ---------------------------------------------------------------------------
+
+echo "#include <winsock2.h>" > test_ws2_32.c
+echo "#include <ws2tcpip.h>" >> test_ws2_32.c
+echo "void foo() {}" >> test_ws2_32.c
+
+if test -z "`${CC} -c test_ws2_32.c 2>&1`" ; then
+  LIBS="$LIBS -lws2_32"
+fi
+rm -f test_ws2_32*
+
+dnl ---------------------------------------------------------------------------
+dnl Check if we need -lpsapi (mingw)
+dnl ---------------------------------------------------------------------------
+
+echo "#include <windows.h>" > test_psapi.c
+echo "#include <psapi.h>" >> test_psapi.c
+echo "void foo() {}" >> test_psapi.c
+
+if test -z "`${CC} -c test_psapi.c 2>&1`" ; then
+  LIBS="$LIBS -lpsapi"
+fi
+rm -f test_psapi*
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if we have getaddrinfo
+dnl ---------------------------------------------------------------------------
+
+echo "#include <sys/types.h>" > test_getaddrinfo.c
+echo "#include <sys/socket.h>" >> test_getaddrinfo.c
+echo "#include <netdb.h>" >> test_getaddrinfo.c
+echo "void test() { getaddrinfo(0,0,0,0); }"  >> test_getaddrinfo.c
+
+HAVE_GETADDRINFO=NO
+if test -z "`${CC} -c test_getaddrinfo.c 2>&1`" ; then
+  AC_DEFINE_UNQUOTED(HAVE_GETADDRINFO,1, [Define to 1 if you have the `getaddrinfo' function.])
+fi
+rm -f test_getaddrinfo*
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests hiding internal symbols
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(hide_internal_symbols,[  --with-hide-internal-symbols[=ARG] Try to hide internal symbols (ARG=yes/no)],,)
+
+HAVE_HIDE_INTERNAL_SYMBOLS=no
+
+if test "$with_hide_internal_symbols" = "yes"; then
+
+    AC_MSG_CHECKING([whether we should hide internal symbols])
+
+    rm -f hiddensymbols.c
+    echo 'int visible() { return 0; } __attribute__ ((visibility("default")))' >> hiddensymbols.c
+    echo 'int hidden() { return 0; }' >> hiddensymbols.c
+    if test -z "`${CC} -fvisibility=hidden -c hiddensymbols.c 2>&1`" ; then
+      HAVE_HIDE_INTERNAL_SYMBOLS=yes
+    else
+      HAVE_HIDE_INTERNAL_SYMBOLS=no
+    fi
+    if test "$HAVE_HIDE_INTERNAL_SYMBOLS" = "yes"; then
+        AC_MSG_RESULT([yes])
+        CFLAGS="$CFLAGS -fvisibility=hidden"
+        CXXFLAGS="$CXXFLAGS -fvisibility=hidden"
+        CFLAGS_NOFTRAPV="$CFLAGS_NOFTRAPV -fvisibility=hidden"
+        CXXFLAGS_NOFTRAPV="$CXXFLAGS_NOFTRAPV -fvisibility=hidden"
+        CXXFLAGS_NO_LTO_IF_AVX_NONDEFAULT="$CXXFLAGS_NO_LTO_IF_AVX_NONDEFAULT -fvisibility=hidden"
+        CXXFLAGS_NO_LTO_IF_SSSE3_NONDEFAULT="$CXXFLAGS_NO_LTO_IF_SSSE3_NONDEFAULT -fvisibility=hidden"
+    else
+        AC_MSG_RESULT([no])
+    fi
+    rm -f hiddensymbols.*
+else
+  AC_MSG_CHECKING([whether we should hide internal symbols])
+  AC_MSG_RESULT([no])
+fi
+
+if test "$HAVE_HIDE_INTERNAL_SYMBOLS" = "yes" ; then
+  AC_DEFINE_UNQUOTED(USE_GCC_VISIBILITY_FLAG,1, [Define to 1 if you want to use the -fvisibility GCC flag])
+fi
+
+AC_SUBST(HAVE_HIDE_INTERNAL_SYMBOLS,$HAVE_HIDE_INTERNAL_SYMBOLS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests renaming internal libtiff symbols
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rename_internal_libtiff_symbols,[  --with-rename-internal-libtiff-symbols[=ARG] Prefix internal libtiff symbols with gdal_ (ARG=yes/no)],,)
+
+RENAME_INTERNAL_LIBTIFF_SYMBOLS=no
+if test "x$with_rename_internal_libtiff_symbols" = "xyes" -o "x$with_rename_internal_libtiff_symbols" = "x"; then
+  RENAME_INTERNAL_LIBTIFF_SYMBOLS=yes
+fi
+
+AC_SUBST(RENAME_INTERNAL_LIBTIFF_SYMBOLS,$RENAME_INTERNAL_LIBTIFF_SYMBOLS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests renaming internal libgeotiff symbols
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rename_internal_libgeotiff_symbols,[  --with-rename-internal-libgeotiff-symbols[=ARG] Prefix internal libgeotiff symbols with gdal_ (ARG=yes/no)],,)
+
+RENAME_INTERNAL_LIBGEOTIFF_SYMBOLS=no
+if test "x$with_rename_internal_libgeotiff_symbols" = "xyes" -o "x$with_rename_internal_libgeotiff_symbols" = "x"; then
+   RENAME_INTERNAL_LIBGEOTIFF_SYMBOLS=yes
+fi
+
+AC_SUBST(RENAME_INTERNAL_LIBGEOTIFF_SYMBOLS,$RENAME_INTERNAL_LIBGEOTIFF_SYMBOLS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests renaming internal shapelib symbols
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rename_internal_shapelib_symbols,[  --with-rename-internal-shapelib-symbols[=ARG] Prefix internal shapelib symbols with gdal_ (ARG=yes/no)],,)
+
+RENAME_INTERNAL_SHAPELIB_SYMBOLS=no
+if test "x$with_rename_internal_shapelib_symbols" = "xyes" -o "x$with_rename_internal_shapelib_symbols" = "x"; then
+    RENAME_INTERNAL_SHAPELIB_SYMBOLS=yes
+fi
+AC_SUBST(RENAME_INTERNAL_SHAPELIB_SYMBOLS,$RENAME_INTERNAL_SHAPELIB_SYMBOLS)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests /usr/local to be included.
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([for local include/lib path])
+
+AC_ARG_WITH(local,[  --with-local[=dir]      Include /usr/local or other local tree for INCLUDE/LIBS],,)
+
+if test "$with_local" != "no" -a "$with_local" != "" ; then
+
+  if test "$with_local" = "yes" ; then
+    ADD_PREFIX=/usr/local
+  else
+    ADD_PREFIX=$with_local
+  fi
+
+  AC_MSG_RESULT(adding $ADD_PREFIX)
+
+  LIBS="$LIBS -L$ADD_PREFIX/lib"
+  CPPFLAGS="$CPPFLAGS -I$ADD_PREFIX/include"
+else
+  AC_MSG_RESULT([none])
+fi
+
+dnl ---------------------------------------------------------------------
+dnl ENABLE THREADS ONLY IF REQUESTED.
+dnl ---------------------------------------------------------------------
+
+THREAD_LIB=""
+THREAD_FLAG=""
+PTHREAD_ENABLED="no"
+
+AC_ARG_WITH(threads,
+[  --with-threads[=ARG]    Include thread safe support (ARG=yes(default), no or linkopt)],,)
+
+if test "$with_threads" = "yes" -o "$with_threads" = "" ; then
+
+  AC_CHECK_LIB(pthread,pthread_create,THREAD_FLAG=CPL_MULTIPROC_PTHREAD,,,)
+
+  if test -n "$THREAD_FLAG" ; then
+      THREAD_LIB="-lpthread"
+  else
+    # For Android, pthread_create is in Bionic libc
+    unset ac_cv_lib_pthread_pthread_create
+    AC_CHECK_LIB(c,pthread_create,THREAD_FLAG=CPL_MULTIPROC_PTHREAD,,,)
+  fi
+
+  AC_MSG_CHECKING([for PTHREAD_MUTEX_RECURSIVE])
+
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define _GNU_SOURCE
+#include <pthread.h>
+  ]], [[
+    return (PTHREAD_MUTEX_RECURSIVE);
+  ]])],[
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_PTHREAD_MUTEX_RECURSIVE, 1,
+          [Define to 1 if you have the `PTHREAD_MUTEX_RECURSIVE' constant.])
+  ],[
+    AC_MSG_RESULT([no])
+  ])
+
+
+
+  AC_MSG_CHECKING([for PTHREAD_MUTEX_ADAPTIVE_NP])
+
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define _GNU_SOURCE
+#include <pthread.h>
+  ]], [[
+    return PTHREAD_MUTEX_ADAPTIVE_NP;
+  ]])],[
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_PTHREAD_MUTEX_ADAPTIVE_NP, 1,
+          [Define to 1 if you have the `PTHREAD_MUTEX_ADAPTIVE_NP' constant.])
+  ],[
+    AC_MSG_RESULT([no])
+  ])
+
+  AC_MSG_CHECKING([for pthread_spinlock_t])
+
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define _GNU_SOURCE
+#include <pthread.h>
+  ]], [[
+    pthread_spinlock_t spin;
+    return 1;
+  ]])],[
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_PTHREAD_SPINLOCK, 1,
+          [Define to 1 if you have the `pthread_spinlock_t' type.])
+  ],[
+    AC_MSG_RESULT([no])
+  ])
+
+elif test "$with_threads" != "no" ; then
+
+  THREAD_FLAG=CPL_MULTIPROC_PTHREAD
+  THREAD_LIB="$with_threads"
+
+  AS_MESSAGE([checking whether we should include thread/mutex support......])
+  AC_MSG_RESULT([        using threads with link options "$THREAD_LIB".])
+
+else
+  AS_MESSAGE([checking whether we should include thread/mutex support......])
+  AC_MSG_RESULT([        thread safe support disabled.])
+fi
+
+if test "$THREAD_FLAG" = "CPL_MULTIPROC_PTHREAD" ; then
+  AC_DEFINE_UNQUOTED(CPL_MULTIPROC_PTHREAD,1, [Define if you want to use pthreads based multiprocessing support])
+  PTHREAD_ENABLED="yes"
+fi
+
+LIBS="$THREAD_LIB $LIBS"
+
+dnl ---------------------------------------------------------------------------
+dnl Check if mremap() with 5 args is available
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([for 5 args mremap()])
+
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define _GNU_SOURCE
+#include <sys/mman.h>
+]], [[
+return (mremap(0,0,0,0,0));
+]])],[
+AC_MSG_RESULT([yes])
+AC_DEFINE_UNQUOTED(HAVE_5ARGS_MREMAP, 1,
+        [Define to 1 if you have the 5 args `mremap' function.])
+],[
+AC_MSG_RESULT([no])
+])
+
+dnl ---------------------------------------------------------------------------
+dnl Check if _SC_PHYS_PAGES is available
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([for _SC_PHYS_PAGES])
+
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <unistd.h>
+]], [[
+return (sysconf(_SC_PHYS_PAGES));
+]])],[
+AC_MSG_RESULT([yes])
+AC_DEFINE_UNQUOTED(HAVE_SC_PHYS_PAGES, 1,
+        [Define to 1 if you have the _SC_PHYS_PAGES' constant.])
+],[
+AC_MSG_RESULT([no])
+])
+
+dnl '---------------------------------------------------------------------------
+dnl Remove possible system library paths from a *_LIB variable to prevent other, perhaps unrelated, system libraries
+dnl from shadowing custom libraries of the same name the user might have installed e.g. under /usr/local.
+dnl System library paths are things like /lib, /usr/lib, /lib64, /usr/lib64, and /usr/lib/x86_64-linux-gnu.
+dnl There may be others as well, that will need be addressed as they arise. We avoid wildcards such as
+dnl /usr/lib/* to avoid potential cases such as /usr/lib/mysql/lib, which might not have an /etc/ld.so.conf.d
+dnl entry and would not shadow any possible custom installs anyway:
+
+AC_DEFUN([STRIP_SYSTEM_LIBRARY_PATHS],[
+    if echo "x" | sed -E "s/x/y/" >/dev/null 2>/dev/null; then
+        STRIPPED_LIBRARY_NAME="$(echo [$1] | sed -E 's:-L/(usr/)?(lib(64)?|lib/x86_64-linux-gnu)/*[[[:space:]]]+::')"
+    elif echo "x" | sed -r "s/x/y/" >/dev/null 2>/dev/null; then
+        dnl Compatibility with older GNU sed that doesn't support -E
+        STRIPPED_LIBRARY_NAME="$(echo [$1] | sed -r 's:-L/(usr/)?(lib(64)?|lib/x86_64-linux-gnu)/*[[[:space:]]]+::')"
+    else
+        STRIPPED_LIBRARY_NAME="$(echo [$1])"
+    fi
+])
+
+dnl ---------------------------------------------------------------------------
+dnl Check if libz is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(libz,[  --with-libz[=ARG]       Include libz support (ARG=internal or libz directory)],,)
+
+if test "$with_libz" = "external" -o "$with_libz" = "" -o "$with_libz" = "yes" ; then
+
+  AC_CHECK_LIB(z,deflateInit_,LIBZ_SETTING=external,LIBZ_SETTING=internal,)
+
+  if test "$LIBZ_SETTING" = "external" ; then
+    AC_CHECK_LIB(z,inflateCopy,LIBZ_SETTING=external,LIBZ_SETTING=internal,)
+    if test "$LIBZ_SETTING" = "external" ; then
+        AC_MSG_RESULT([using pre-installed libz])
+    else
+        AC_MSG_RESULT([using internal libz code as inflateCopy is missing])
+    fi
+  else
+    AC_MSG_RESULT([using internal libz code as deflateInit_ is missing])
+  fi
+
+elif test "$with_libz" != "no" -a "$with_libz" != "internal" ; then
+
+  LIBS="-L$with_libz -L$with_libz/lib $LIBS"
+
+  AC_CHECK_LIB(z,deflateInit_,LIBZ_SETTING=external,LIBZ_SETTING=internal,-L$with_libz -L$with_libz/lib -lz)
+  if test "$LIBZ_SETTING" = "external" ; then
+    AC_CHECK_LIB(z,inflateCopy,LIBZ_SETTING=external,LIBZ_SETTING=internal,-L$with_libz -L$with_libz/lib -lz)
+     if test "$LIBZ_SETTING" = "external" ; then
+        AC_MSG_RESULT([using libz library from $with_libz])
+    else
+        AC_MSG_RESULT([using internal libz code as inflateCopy from $with_libz is missing])
+    fi
+  else
+    AC_MSG_RESULT([using internal libz code as deflateInit_ from $with_libz is missing])
+  fi
+
+fi
+
+if test "$LIBZ_SETTING" = "external" ; then
+  LIBS="-lz $LIBS"
+  if test "$with_libz" != "" -a "$with_libz" != "yes" -a "$with_libz" != "external" ; then
+    EXTRA_INCLUDES="-I$with_libz -I$with_libz/include $EXTRA_INCLUDES"
+  fi
+elif test "$with_libz" = "no" ; then
+  LIBZ_SETTING=no
+  AC_MSG_RESULT([not using libz at all.])
+else
+  LIBZ_SETTING=internal
+  OPT_GDAL_FORMATS="zlib $OPT_GDAL_FORMATS"
+  AC_MSG_RESULT([using internal libz code.])
+fi
+
+AC_SUBST(LIBZ_SETTING,$LIBZ_SETTING)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for libdeflate.
+dnl ---------------------------------------------------------------------------
+
+LIBDEFLATE_SETTING=no
+
+AC_ARG_WITH(libdeflate,
+            AS_HELP_STRING([--with-libdeflate],
+                            [enable libdeflate usage (optional for faster Deflate support (still requires zlib) (ARG=yes/no/prefix), enabled by default)]),,)
+
+if test "$with_libdeflate" != "no" ; then
+
+  if test "$with_libdeflate" != "" -a "$with_libdeflate" != "yes"; then
+    AC_CHECK_LIB(deflate, libdeflate_zlib_decompress, [libdeflate_lib=yes], [libdeflate_lib=no],-L$with_libdeflate/lib)
+  else
+    AC_CHECK_LIB(deflate, libdeflate_zlib_decompress, [libdeflate_lib=yes], [libdeflate_lib=no])
+  fi
+
+  if test "$libdeflate_lib" = "no" -a "$with_libdeflate" = "yes"; then
+    AC_MSG_ERROR([libdeflate library not found])
+  fi
+
+  if test "$with_libdeflate" != "" -a "$with_libdeflate" != "yes"; then
+    if test -r "$with_libdeflate/include/libdeflate.h" ; then
+      libdeflate_h=yes
+    else
+      libdeflate_h=no
+    fi
+  else
+    AC_CHECK_HEADER(libdeflate.h, [libdeflate_h=yes], [libdeflate_h=no])
+  fi
+  if test "$libdeflate_h" = "no" -a "$with_libdeflate" = "yes"; then
+    AC_MSG_ERROR([libdeflate headers not found])
+  fi
+
+  if test "$libdeflate_lib" = "yes" -a "$libdeflate_h" = "yes" ; then
+    LIBDEFLATE_SETTING=yes
+  fi
+
+fi
+
+if test "$LIBDEFLATE_SETTING" = "yes" ; then
+  if test "$with_libdeflate" != "" -a "$with_libdeflate" != "yes"; then
+    EXTRA_INCLUDES="-I$with_libdeflate/include $EXTRA_INCLUDES"
+    LIBS="-L$with_libdeflate/lib -ldeflate $LIBS"
+  else
+    LIBS="-ldeflate $LIBS"
+  fi
+fi
+
+AC_SUBST(LIBDEFLATE_SETTING,$LIBDEFLATE_SETTING)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for iconv/libiconv.
+dnl A rationale for this macro is described in "GNU `gettext' utilities"
+dnl manual at
+dnl http://www.gnu.org/software/gettext/manual/html_node/AM_005fICONV.html
+dnl ---------------------------------------------------------------------------
+AM_ICONV
+
+dnl Extra test needed for GCC 4.5 on Solaris 11, where there is
+dnl a different behavior if the tests are compiled with gcc or g++.
+dnl So we introduce a ICONV_CPP_CONST that must be used instead of
+dnl ICONV_CONST when used from .cpp files.
+if test "$am_func_iconv" = "yes"; then
+    rm -f testiconv.*
+    echo '#include <iconv.h>' > testiconv.cpp
+    echo 'int main(int argc, char** argv) { iconv_t cd = 0; return iconv (cd, (const char **) 0, 0, 0, 0); } ' >> testiconv.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testiconv.cpp -c 2>&1`" ; then
+        AC_MSG_RESULT([using ICONV_CPP_CONST="const"])
+        ICONV_CPP_CONST="const"
+    else
+        AC_MSG_RESULT([using ICONV_CPP_CONST=""])
+        ICONV_CPP_CONST=""
+    fi
+    rm -f testiconv.*
+
+    AC_DEFINE_UNQUOTED(ICONV_CPP_CONST,$ICONV_CPP_CONST, [For.cpp files, define as const if the declaration of iconv() needs const.])
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Bash completions
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([bash-completion],
+  AS_HELP_STRING([--with-bash-completion[=ARG]],
+    [Install Bash completions (ARG=yes or path)]),,)
+
+if test "x$with_bash_completion" = "xno" -o "x$with_bash_completion" = "x"; then
+  AC_MSG_NOTICE([Bash completions not requested])
+elif test "x$with_bash_completion" = "xyes"; then
+  PKG_CHECK_VAR(bashcompdir, [bash-completion], [completionsdir], ,
+    bashcompdir="${sysconfdir}/bash_completion.d")
+  AC_SUBST(bashcompdir)
+else
+  AC_SUBST(bashcompdir, $with_bash_completion)
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select a JPEG Library to use, or disable driver.
+dnl libtiff could depend on it so it must appear before.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(jpeg,[  --with-jpeg[=ARG]       Include JPEG support (ARG=internal, no or path)],,)
+
+if test "$with_jpeg" = "no" ; then
+
+  JPEG_SETTING=no
+
+  echo "jpeg support disabled."
+
+elif test "$with_jpeg" = "yes" -o "$with_jpeg" = "" ; then
+
+  AC_CHECK_LIB(jpeg,jpeg_read_scanlines,JPEG_SETTING=external,JPEG_SETTING=internal,)
+  AC_CHECK_HEADERS(jpeglib.h)
+
+  if test "$JPEG_SETTING" = "external" -a "$ac_cv_header_jpeglib_h" = "no" ; then
+    JPEG_SETTING=internal
+  fi
+
+  if test "$JPEG_SETTING" = "external" -a "$TIFF_SETTING" = "internal" ; then
+    AC_MSG_CHECKING([for width_in_blocks in jpeglib.h])
+
+    rm -f conftest.c
+    echo '#include <stdio.h>' >> conftest.c
+    echo '#include "jpeglib.h"' >> conftest.c
+    echo 'int main() { jpeg_component_info *comptr=0; int i; i = comptr->width_in_blocks; }' >> conftest.c
+    if test -z "`${CC} ${CPPFLAGS} ${CFLAGS} -c conftest.c 2>&1`" ; then
+      AC_MSG_RESULT([yes])
+    else
+      AC_MSG_RESULT([no])
+      JPEG_SETTING=internal
+    fi
+    rm -f conftest*
+  fi
+
+  if test "$JPEG_SETTING" = "external" ; then
+    LIBS="-ljpeg $LIBS"
+    echo "using pre-installed libjpeg."
+  else
+    echo "using internal jpeg code."
+  fi
+
+elif test "$with_jpeg" = "internal" ; then
+
+  JPEG_SETTING=internal
+
+  echo "using internal jpeg code."
+
+else
+
+  JPEG_SETTING=external
+  LIBS="-L$with_jpeg -L$with_jpeg/lib -ljpeg $LIBS"
+  EXTRA_INCLUDES="-I$with_jpeg -I$with_jpeg/include $EXTRA_INCLUDES"
+
+  echo "using libjpeg from $with_jpeg."
+
+fi
+
+AC_SUBST(JPEG_SETTING,$JPEG_SETTING)
+
+if test "$JPEG_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="jpeg $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests renaming internal libjpeg symbols
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rename_internal_libjpeg_symbols,[  --with-rename-internal-libjpeg-symbols[=ARG] Prefix internal libjpeg symbols with gdal_ (ARG=yes/no)],,)
+
+RENAME_INTERNAL_LIBJPEG_SYMBOLS=no
+if test "x$with_rename_internal_libjpeg_symbols" = "xyes" -o "x$with_rename_internal_libjpeg_symbols" = "x"; then
+    RENAME_INTERNAL_LIBJPEG_SYMBOLS=yes
+fi
+
+AC_SUBST(RENAME_INTERNAL_LIBJPEG_SYMBOLS,$RENAME_INTERNAL_LIBJPEG_SYMBOLS)
+
+dnl ---------------------------------------------------------------------------
+dnl Select a libtiff library to use.
+dnl Proj depends on it so it must appear before.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(libtiff,[  --with-libtiff=ARG    Libtiff library to use (ARG=internal, yes or path)],,)
+
+AC_MSG_CHECKING([for libtiff])
+
+if test "x${with_libtiff}" = "xyes" -o "x${with_libtiff}" = "x" ; then
+
+  dnl Only automatically pick up the external libtiff if it is >= 4.0.
+  AC_CHECK_LIB(tiff,TIFFScanlineSize64,TIFF_SETTING=external HAVE_BIGTIFF=yes,TIFF_SETTING=internal HAVE_BIGTIFF=yes,)
+
+  if test "$TIFF_SETTING" = "external" ; then
+    LIBS="-ltiff $LIBS"
+    AC_MSG_RESULT([using pre-installed libtiff.])
+  else
+    AC_MSG_RESULT([using internal TIFF code.])
+  fi
+
+elif test "x${with_libtiff}" = "xno" ; then
+
+  AC_MSG_ERROR([libtiff is a required dependency])
+
+elif test "x${with_libtiff}" = "xinternal" ; then
+
+  TIFF_SETTING=internal
+  HAVE_BIGTIFF=yes
+
+  AC_MSG_RESULT([using internal TIFF code.])
+
+else
+
+  TIFF_SETTING=external
+  if test -r "$with_libtiff/tiff.h" ; then
+    LIBS="-L$with_libtiff -ltiff $LIBS"
+    EXTRA_INCLUDES="-I$with_libtiff $EXTRA_INCLUDES"
+  else
+    LIBS="-L$with_libtiff/lib -ltiff $LIBS"
+    EXTRA_INCLUDES="-I$with_libtiff/include $EXTRA_INCLUDES"
+  fi
+
+  AC_MSG_RESULT([using libtiff from ${with_libtiff}.])
+
+  dnl Check for the BigTIFF enabled library (libtiff >= 4.0)
+  AC_CHECK_LIB(tiff,TIFFScanlineSize64,HAVE_BIGTIFF=yes,HAVE_BIGTIFF=no,)
+
+fi
+
+if test "${HAVE_BIGTIFF}" != "yes" ; then
+  AC_MSG_ERROR([libtiff >= 4.0 is required.])
+fi
+
+AC_SUBST(TIFF_SETTING,${TIFF_SETTING})
+
+dnl ---------------------------------------------------------------------------
+dnl Check for curl (i.e. for wcs).
+dnl Proj depends on it so it must appear before.
+dnl ---------------------------------------------------------------------------
+CURL_SETTING=no
+CURL_INC=
+CURL_LIB=
+
+AC_ARG_WITH(curl,
+    [  --with-curl[=ARG]       Include curl (ARG=path to curl-config.)],,,)
+
+dnl Clear some cache variables
+unset ac_cv_path_LIBCURL
+
+if test "`basename xx/$with_curl`" = "curl-config" ; then
+  LIBCURL_CONFIG="$with_curl"
+elif test "$with_curl" = "no" ; then
+  LIBCURL_CONFIG=no
+else
+  AC_PATH_PROG(LIBCURL_CONFIG, curl-config, no)
+fi
+
+if test "$LIBCURL_CONFIG" != "no" ; then
+
+  CURL_VERNUM=`$LIBCURL_CONFIG --vernum`
+  CURL_VER=`$LIBCURL_CONFIG --version | awk '{print $2}'`
+
+  AC_MSG_RESULT([        found libcurl version $CURL_VER])
+
+  AC_CHECK_LIB(curl,curl_global_init,CURL_SETTING=yes,CURL_SETTING=no,`$LIBCURL_CONFIG --libs`)
+
+fi
+
+AC_SUBST(CURL_SETTING,$CURL_SETTING)
+AC_SUBST(CURL_INC,    $CURL_INC)
+AC_SUBST(CURL_LIB,    $CURL_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for SQLite
+dnl Proj depends on it so it must appear before.
+dnl ---------------------------------------------------------------------------
+
+SQLITE3_REQ_VERSION="3.0.0"
+AX_LIB_SQLITE3($SQLITE3_REQ_VERSION)
+
+if test "$HAVE_SQLITE3" = "yes"; then
+    LIBS="$SQLITE3_LDFLAGS $LIBS"
+    AC_CHECK_LIB(sqlite3,sqlite3_column_table_name,SQLITE_HAS_COLUMN_METADATA=yes,SQLITE_HAS_COLUMN_METADATA=no,$LIBS)
+fi
+
+AC_SUBST([SQLITE_INC], $SQLITE3_CFLAGS)
+AC_SUBST([HAVE_SQLITE], $HAVE_SQLITE3)
+AC_SUBST([SQLITE_HAS_COLUMN_METADATA], $SQLITE_HAS_COLUMN_METADATA)
+HAVE_SQLITE=$HAVE_SQLITE3
+
+dnl ---------------------------------------------------------------------------
+dnl PROJ.6 related stuff
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([for PROJ >= 6 library])
+
+AC_ARG_WITH(proj,[  --with-proj=ARG Compile with PROJ.x (ARG=yes or path)],,)
+
+AC_ARG_WITH(proj-extra-lib-for-test,
+    [  --with-proj-extra-lib-for-test=ARG   Additional libraries to pass the detection test, but not used for libgdal linking (i.e. -lcurl -ltiff ...). Mainly for static libproj],,,)
+
+PROJ_INCLUDE=""
+if test "x$with_proj" = "xno" ; then
+
+  AC_MSG_ERROR([PROJ >= 6 is a required dependency.])
+
+else
+
+  if test "x$with_proj" = "xyes" -o "x$with_proj" = "x"; then
+    ORIG_LIBS="$LIBS"
+    LIBS="-lproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+    AC_LANG_PUSH([C++])
+    AC_CHECK_LIB(proj,proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+    AC_LANG_POP([C++])
+    if test "$PROJ_FOUND" = "no"; then
+        AC_LANG_PUSH([C++])
+        AC_CHECK_LIB(proj,internal_proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+        AC_LANG_POP([C++])
+        if test "$PROJ_FOUND" = "yes"; then
+            PROJ_INCLUDE="-DPROJ_RENAME_SYMBOLS"
+        fi
+    fi
+    if test "$PROJ_FOUND" = "no"; then
+        LIBS="-linternalproj $ORIG_LIBS"
+        AC_LANG_PUSH([C++])
+        AC_CHECK_LIB(internalproj,internal_proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+        AC_LANG_POP([C++])
+        if test "$PROJ_FOUND" = "yes"; then
+            PROJ_INCLUDE="-DPROJ_RENAME_SYMBOLS"
+        fi
+    fi
+    if test "$PROJ_FOUND" = "no"; then
+        AC_MSG_ERROR([PROJ 6 symbols not found])
+    fi
+    AC_CHECK_HEADERS([proj.h])
+    if test "$ac_cv_header_proj_h" = "yes" ; then
+        AC_MSG_NOTICE([proj.h found])
+    else
+        AC_MSG_ERROR([proj.h not found])
+    fi
+  else
+    ORIG_LIBS="$LIBS"
+    LIBS="-L$with_proj/lib -lproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+    AC_LANG_PUSH([C++])
+    AC_CHECK_LIB(proj,proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+    AC_LANG_POP([C++])
+    if test "$PROJ_FOUND" = "no"; then
+        LIBS="-L$with_proj/lib -lproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+        unset ac_cv_lib_proj_proj_create_from_wkt
+        AC_LANG_PUSH([C++])
+        AC_CHECK_LIB(proj,proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+        AC_LANG_POP([C++])
+    fi
+    if test "$PROJ_FOUND" = "no"; then
+        LIBS="-L$with_proj/lib64 -lproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+        unset ac_cv_lib_proj_proj_create_from_wkt
+        AC_LANG_PUSH([C++])
+        AC_CHECK_LIB(proj,proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+        AC_LANG_POP([C++])
+    fi
+    if test "$PROJ_FOUND" = "no"; then
+        LIBS="-L$with_proj/lib -lproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+        AC_LANG_PUSH([C++])
+        AC_CHECK_LIB(proj,internal_proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+        AC_LANG_POP([C++])
+        if test "$PROJ_FOUND" = "no"; then
+            LIBS="-L$with_proj/lib -lproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+            unset ac_cv_lib_proj_internal_proj_create_from_wkt
+            AC_LANG_PUSH([C++])
+            AC_CHECK_LIB(proj,internal_proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+            AC_LANG_POP([C++])
+        fi
+        if test "$PROJ_FOUND" = "yes"; then
+            PROJ_INCLUDE="-DPROJ_RENAME_SYMBOLS"
+        fi
+    fi
+    if test "$PROJ_FOUND" = "no"; then
+        LIBS="-L$with_proj/lib -linternalproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+        AC_LANG_PUSH([C++])
+        AC_CHECK_LIB(internalproj,internal_proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+        AC_LANG_POP([C++])
+        if test "$PROJ_FOUND" = "no"; then
+            LIBS="-L$with_proj/lib -linternalproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+            unset ac_cv_lib_internal_proj_internal_proj_create_from_wkt
+            AC_LANG_PUSH([C++])
+            AC_CHECK_LIB(internalproj,internal_proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+            AC_LANG_POP([C++])
+        fi
+        if test "$PROJ_FOUND" = "yes"; then
+            PROJ_INCLUDE="-DPROJ_RENAME_SYMBOLS"
+        fi
+    fi
+    if test "$PROJ_FOUND" = "no"; then
+        AC_MSG_ERROR([PROJ 6 symbols not found])
+    fi
+    if test -r "$with_proj/include/proj.h" ; then
+        PROJ_INCLUDE="$PROJ_INCLUDE -I$with_proj/include"
+        AC_MSG_NOTICE([proj.h found])
+    else
+        AC_MSG_ERROR([proj.h not found])
+    fi
+  fi
+fi
+
+AC_SUBST(PROJ_INCLUDE)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for SpatiaLite.
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING(for spatialite)
+
+AC_ARG_WITH(spatialite,
+    [  --with-spatialite=ARG Include SpatiaLite support (ARG=no(default), yes, dlopen (only supported for Spatialite >= 4.1.2) or path)],
+    ,,)
+
+AC_ARG_WITH(spatialite-soname,
+    [  --with-spatialite-soname=ARG Spatialite shared object name (e.g. libspatialite.so), only used if --with-spatialite=dlopen],
+    ,,)
+
+HAVE_SPATIALITE=no
+
+if test -z "$with_spatialite" -o "$with_spatialite" = "no"; then
+    AC_MSG_RESULT(disabled)
+elif test "$with_spatialite" = "yes"; then
+    AC_CHECK_HEADERS(sqlite3.h)
+    if test "$ac_cv_header_sqlite3_h" = "yes"; then
+        AC_MSG_CHECKING([for spatialite.h in /usr/include or /usr/local/include])
+        if test -f "/usr/include/spatialite.h" -o -f "/usr/local/include/spatialite.h"; then
+            AC_MSG_RESULT(found)
+            AC_CHECK_LIB(spatialite,spatialite_init,SPATIALITE_INIT_FOUND=yes,SPATIALITE_INIT_FOUND=no,-lsqlite3)
+            if test "$SPATIALITE_INIT_FOUND" = "yes"; then
+                HAVE_SPATIALITE=yes
+                SPATIALITE_LIBS="-lspatialite -lsqlite3"
+                LIBS="$LIBS $SPATIALITE_LIBS"
+                HAVE_SQLITE3=yes
+            fi
+        else
+            AC_MSG_RESULT(not found : spatialite support disabled)
+        fi
+    fi
+elif test "$with_spatialite" = "dlopen"; then
+  HAVE_SPATIALITE=dlopen
+  AC_MSG_RESULT(dlopen)
+
+  if test "$with_spatialite_soname" != ""; then
+      SPATIALITE_SONAME="$with_spatialite_soname"
+  else
+      SPATIALITE_SONAME="spatialite.so"
+  fi
+else
+    AC_CHECK_LIB(spatialite,spatialite_init,SPATIALITE_INIT_FOUND=yes,SPATIALITE_INIT_FOUND=no,-L$with_spatialite/lib -lspatialite)
+
+    if test -f "$with_spatialite/include/spatialite.h" -a \
+        "$SPATIALITE_INIT_FOUND" = "yes"; then
+
+        if test "$HAVE_SQLITE3" = "yes"; then
+            SPATIALITE_INC="-I$with_spatialite/include"
+            HAVE_SPATIALITE=yes
+            SPATIALITE_LIBS="-L$with_spatialite/lib -lspatialite"
+            LIBS="$SQLITE3_LDFLAGS $LIBS $SPATIALITE_LIBS"
+            AC_MSG_RESULT(spatialite enabled)
+        else
+            AC_MSG_RESULT(spatialite disabled)
+        fi
+    else
+        AC_MSG_RESULT(disabled)
+    fi
+fi
+
+if test "$HAVE_SPATIALITE" = "yes"; then
+    AC_CHECK_LIB(spatialite,spatialite_target_cpu,SPATIALITE_412_OR_LATER=yes,SPATIALITE_412_OR_LATER=no)
+fi
+
+AC_SUBST([HAVE_SPATIALITE], $HAVE_SPATIALITE)
+AC_SUBST([SPATIALITE_SONAME], $SPATIALITE_SONAME)
+AC_SUBST([SPATIALITE_INC], $SPATIALITE_INC)
+AC_SUBST([SPATIALITE_412_OR_LATER], $SPATIALITE_412_OR_LATER)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if liblzma is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(liblzma,[  --with-liblzma[=ARG]       Include liblzma support (ARG=yes/no)],,)
+
+if test "$with_liblzma" = "yes" ; then
+  AC_CHECK_LIB(lzma,lzma_code,LIBLZMA_SETTING=yes,LIBLZMA_SETTING=no,)
+  AC_CHECK_HEADERS(lzma.h)
+
+  if test "$LIBLZMA_SETTING" = "yes" -a "$ac_cv_header_lzma_h" = "yes" ; then
+    LIBS="-llzma $LIBS"
+  else
+    LIBLZMA_SETTING=no
+  fi
+else
+    LIBLZMA_SETTING=no
+fi
+
+AC_SUBST(LIBLZMA_SETTING,$LIBLZMA_SETTING)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if zstd is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(zstd,[  --with-zstd[=ARG]       Include zstd support (ARG=yes/no/installation_prefix)],,)
+
+if test "$with_zstd" = "" -o "$with_zstd" = "yes" ; then
+  AC_CHECK_LIB(zstd,ZSTD_decompressStream,ZSTD_SETTING=yes,ZSTD_SETTING=no,)
+
+  if test "$ZSTD_SETTING" = "yes" ; then
+    LIBS="-lzstd $LIBS"
+  else
+    if test "$with_zstd" = "yes" ; then
+      AC_MSG_ERROR([libzstd not found])
+    else
+      echo "libzstd not found - ZSTD support disabled"
+    fi
+  fi
+elif test "$with_zstd" != "" -a "$with_zstd" != "no"; then
+
+  AC_CHECK_LIB(zstd,ZSTD_decompressStream,ZSTD_SETTING=yes,ZSTD_SETTING=no,-L$with_zstd/lib)
+
+  if test "$ZSTD_SETTING" = "yes" -a -f "$with_zstd/include/zstd.h" ; then
+    LIBS="-L$with_zstd/lib -lzstd $LIBS"
+    EXTRA_INCLUDES="-I$with_zstd/include $EXTRA_INCLUDES"
+  else
+    AC_MSG_ERROR([libzstd not found])
+  fi
+
+else
+    ZSTD_SETTING=no
+fi
+
+AC_SUBST(ZSTD_SETTING,$ZSTD_SETTING)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if blosc is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(blosc,[  --with-blosc[=ARG]       Include blosc support (ARG=yes/no/installation_prefix)],,)
+
+if test "$with_blosc" = "" -o "$with_blosc" = "yes" ; then
+  AC_CHECK_LIB(blosc,blosc_cbuffer_validate,HAVE_BLOSC=yes,HAVE_BLOSC=no,)
+
+  if test "$HAVE_BLOSC" = "yes" ; then
+    LIBS="-lblosc $LIBS"
+  else
+    if test "$with_blosc" = "yes" ; then
+      AC_MSG_ERROR([libblosc not found])
+    else
+      echo "libblosc not found - BLOSC support disabled"
+    fi
+  fi
+elif test "$with_blosc" != "" -a "$with_blosc" != "no"; then
+
+  AC_CHECK_LIB(blosc,blosc_cbuffer_validate,HAVE_BLOSC=yes,HAVE_BLOSC=no,-L$with_blosc/lib)
+
+  if test "$HAVE_BLOSC" = "yes" -a -f "$with_blosc/include/blosc.h" ; then
+    LIBS="-L$with_blosc/lib -lblosc $LIBS"
+    EXTRA_INCLUDES="-I$with_blosc/include $EXTRA_INCLUDES"
+  else
+    AC_MSG_ERROR([libblosc not found])
+  fi
+
+else
+    HAVE_BLOSC=no
+fi
+
+AC_SUBST(HAVE_BLOSC,$HAVE_BLOSC)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if lz4 is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(lz4,[  --with-lz4[=ARG]       Include lz4 support (ARG=yes/no/installation_prefix)],,)
+
+if test "$with_lz4" = "" -o "$with_lz4" = "yes" ; then
+  AC_CHECK_LIB(lz4,LZ4_decompress_safe,HAVE_LZ4=yes,HAVE_LZ4=no,)
+
+  if test "$HAVE_LZ4" = "yes" ; then
+    LIBS="-llz4 $LIBS"
+  else
+    if test "$with_lz4" = "yes" ; then
+      AC_MSG_ERROR([liblz4 not found])
+    else
+      echo "liblz4 not found - LZ4 support disabled"
+    fi
+  fi
+elif test "$with_lz4" != "" -a "$with_lz4" != "no"; then
+
+  AC_CHECK_LIB(lz4,LZ4_decompress_safe,HAVE_LZ4=yes,HAVE_LZ4=no,-L$with_lz4/lib)
+
+  if test "$HAVE_LZ4" = "yes" -a -f "$with_lz4/include/lz4.h" ; then
+    LIBS="-L$with_lz4/lib -llz4 $LIBS"
+    EXTRA_INCLUDES="-I$with_lz4/include $EXTRA_INCLUDES"
+  else
+    AC_MSG_ERROR([liblz4 not found])
+  fi
+
+else
+    HAVE_LZ4=no
+fi
+
+AC_SUBST(HAVE_LZ4,$HAVE_LZ4)
+
+dnl ---------------------------------------------------------------------------
+dnl Set up drivers and formats
+dnl ---------------------------------------------------------------------------
+
+GDALFORMATS_ENABLED=
+GDALFORMATS_DISABLED=
+OGRFORMATS_ENABLED=
+OGRFORMATS_ENABLED_CFLAGS=
+OGRFORMATS_DISABLED=
+
+AC_DEFUN([INTERNAL_FORMATS],[aaigrid adrg aigrid airsar arg blx bmp bsb cals ceos ceos2 coasp cosar ctg dimap dted elas envisat ers esric fit gff gsg gxf hf2 idrisi ilwis iris iso8211 jaxapalsar jdem kmlsuperoverlay l1b leveller map mrf msgn ngsgeoid nitf northwood pds prf r raw rmf rs2 safe saga sdts sentinel2 sgi sigdem srtmhgt stacit stacta terragen tga til tsx usgsdem xpm xyz zarr zmap])
+AC_DEFUN([INTERNAL_OPT_FORMATS],[grib ozi pdf rik])
+AC_DEFUN([INTERNAL_DRIVERS],[avc cad csv dgn dxf edigeo flatgeobuf geoconcept georss gml gmt gpsbabel gpx jml mapml mvt ntf openfilegdb pgdump s57 selafin shape svg sxf tiger vdv wasp])dnl
+AC_DEFUN([CURL_FORMATS],[eeda plmosaic wcs wms wmts daas ogcapi])dnl
+AC_DEFUN([CURL_DRIVERS],[amigocloud carto csw elastic ngw plscenes wfs])dnl
+AC_DEFUN([SQLITE_FORMATS],[rasterlite mbtiles])dnl
+AC_DEFUN([SQLITE_DRIVERS],[gpkg vfk osm])dnl
+AC_DEFUN([EXPAT_DRIVERS],[ods xlsx lvbag])dnl
+AC_DEFUN([XERCES_DRIVERS],[nas ili gmlas])dnl
+AC_DEFUN([ODBC_DRIVERS],[odbc pgeo mssqlspatial])dnl
+
+AC_ARG_ENABLE(all-optional-drivers, AS_HELP_STRING([--disable-all-optional-drivers], [disable all non-mandatory internal drivers. Individual drivers can be added with --enable-driver-XXX]))
+if test "x$enable_all_optional_drivers" = "xno"; then :
+  all_drivers_disabled=yes
+else
+  all_drivers_disabled=no
+fi
+
+m4_define([ARG_DRIVER_ENABLED],[dnl
+cur_driver_enabled=yes
+requested=m4_join([_],[$enable_driver],$1)
+if test "$all_drivers_disabled" = "yes"; then :
+  if test "x$requested" = "xyes"; then :
+    cur_driver_enabled=yes
+  else
+    cur_driver_enabled=no
+  fi
+else
+  if test "x$requested" != "xno"; then :
+    cur_driver_enabled=yes
+  else
+    cur_driver_enabled=no
+  fi
+fi
+])
+
+
+
+m4_foreach_w([frmt], INTERNAL_FORMATS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  GDALFORMATS_DISABLED="$GDALFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],INTERNAL_OPT_FORMATS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt format support (enabled by default, requires dependency)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  GDALFORMATS_DISABLED="$GDALFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_define([_OGRDEFINE],[m4_join([],[-D],m4_toupper([$1]),[_ENABLED])])
+
+m4_foreach_w([frmt],INTERNAL_DRIVERS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+  OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+AC_DEFUN([INTERNAL_DRIVERS_WITH_SAME_NAME_AS_FORMAT],[idrisi pds sdts])dnl
+m4_foreach_w([frmt],INTERNAL_DRIVERS_WITH_SAME_NAME_AS_FORMAT,
+[
+driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+if test "x$driver_enabled" != "xno"; then :
+  OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+  OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+fi
+])
+
+m4_foreach_w([frmt],CURL_FORMATS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt format support (enabled by default, requires curl)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  GDALFORMATS_DISABLED="$GDALFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],CURL_DRIVERS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default, requires curl)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],SQLITE_FORMATS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt format support (enabled by default, requires sqlite3)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  GDALFORMATS_DISABLED="$GDALFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],SQLITE_DRIVERS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default, requires sqlite3)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],EXPAT_DRIVERS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default, requires expat)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],XERCES_DRIVERS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default, requires xerces-c)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],ODBC_DRIVERS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default, requires odbc)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+AC_SUBST(OGRFORMATS_ENABLED,$OGRFORMATS_ENABLED)
+AC_SUBST(OGRFORMATS_ENABLED_CFLAGS,$OGRFORMATS_ENABLED_CFLAGS)
+AC_SUBST(GDALFORMATS_ENABLED,$GDALFORMATS_ENABLED)
+
+if test "$LIBZ_SETTING" != "no" ; then
+  if test "x$INTERNAL_FORMAT_rik_ENABLED" = "xyes"; then
+      GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED rik"
+  fi
+  if test "x$INTERNAL_FORMAT_ozi_ENABLED" = "xyes"; then
+      GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED ozi"
+  fi
+fi
+
+if test "$CURL_SETTING" = "yes" ; then
+
+  CURL_INC=`$LIBCURL_CONFIG --cflags`
+  CURL_LIB=`$LIBCURL_CONFIG --libs`
+m4_foreach_w([frmt],CURL_FORMATS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED frmt"
+  fi
+])
+m4_foreach_w([frmt],CURL_DRIVERS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+    OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+  fi
+])
+
+fi
+
+if test "$HAVE_SQLITE3" = "yes"; then
+m4_foreach_w([frmt],SQLITE_FORMATS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED frmt"
+  fi
+])
+
+m4_foreach_w([frmt],SQLITE_DRIVERS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+    OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+  fi
+])
+
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select an PostgreSQL Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+PG_CONFIG=no
+
+AC_ARG_WITH(pg,
+	    AS_HELP_STRING([--with-pg[=ARG]],
+	       [Include PostgreSQL GDAL/OGR Support (ARG=yes,no)]),,)
+
+if test "x$with_pg" = "xyes" -o "x$with_pg" = "x" ; then
+  PG_CONFIG=yes
+elif test "x$with_pg" != "xno"; then
+  AC_MSG_ERROR([Only --with-pg=yes/no supported])
+fi
+
+AC_MSG_CHECKING([for PostgreSQL])
+
+if test "x$PG_CONFIG" = "xno" ; then
+
+  HAVE_PG=no
+  PG_LIB=
+  PG_INC=
+
+  AC_MSG_RESULT([no])
+
+else
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([PQ],[libpq > 9.1], [HAVE_PG=yes], [HAVE_PG=no])
+
+  if test "${HAVE_PG}" = "yes" ; then
+    PG_LIB="${PQ_LIBS}"
+    PG_INC="${PQ_CFLAGS}"
+    SAVED_LIBS="${LIBS}"
+    LIBS="${PG_LIB}"
+    AC_CHECK_LIB(pq,PQconnectdb,HAVE_PG=yes,HAVE_PG=no)
+    LIBS="${SAVED_LIBS}"
+    if test "${HAVE_PG}" = "yes" ; then
+      LIBS="${PG_LIB} ${LIBS}"
+    fi
+  else
+    if test "x$with_pg" = "xyes"; then
+      AC_MSG_ERROR([--with-pg was requested, but libpq is not available])
+    fi
+  fi
+
+fi
+
+AC_SUBST(HAVE_PG,$HAVE_PG)
+AC_SUBST(PG_INC,$PG_INC)
+AC_SUBST(PG_LIB,$PG_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if cfitsio library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(cfitsio,[  --with-cfitsio[=ARG]    Include FITS support (ARG=no or libcfitsio path)],,)
+
+if test "$with_cfitsio" = "no" ; then
+
+  FITS_SETTING=no
+
+  echo "FITS support disabled."
+
+elif test "$with_cfitsio" = "yes" -o "$with_cfitsio" = "" ; then
+
+  AC_CHECK_LIB(cfitsio,ffopen,FITS_SETTING=external,FITS_SETTING=no,)
+
+  if test "$FITS_SETTING" = "external" ; then
+    LIBS="-lcfitsio $LIBS"
+    echo "using pre-installed libcfitsio."
+  else
+    echo "libcfitsio not found - FITS support disabled"
+  fi
+
+dnl Fedora has cfitsio headers in /usr/include/cfitsio
+  if test "$FITS_SETTING" = "external" -a -d /usr/include/cfitsio ; then
+    EXTRA_INCLUDES="-I/usr/include/cfitsio $EXTRA_INCLUDES"
+  fi
+
+else
+
+  FITS_SETTING=external
+  LIBS="-L$with_cfitsio -L$with_cfitsio/lib -lcfitsio $LIBS"
+  EXTRA_INCLUDES="-I$with_cfitsio -I$with_cfitsio/include $EXTRA_INCLUDES"
+
+  echo "using libcfitsio from $with_cfitsio."
+fi
+
+AC_SUBST(FITS_SETTING,$FITS_SETTING)
+
+if test "$FITS_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="fits $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if PCRaster (libcsf) library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(pcraster,[  --with-pcraster[=ARG]   Include PCRaster (libcsf) support (ARG=internal, no or path)],,)
+
+if test "$with_pcraster" = "no" ; then
+
+  PCRASTER_SETTING=no
+
+  echo "PCRaster support disabled."
+
+elif test "$with_pcraster" = "yes" -o "$with_pcraster" = "" ; then
+
+  AC_CHECK_LIB(csf,Mopen,PCRASTER_SETTING=external,PCRASTER_SETTING=internal,$LIBS)
+  AC_CHECK_HEADERS(csf.h)
+
+  if test "$PCRASTER_SETTING" = "external" -a "$ac_cv_header_csf_h" = "no" ; then
+    PCRASTER_SETTING=internal
+  fi
+
+  if test "$PCRASTER_SETTING" = "external" ; then
+    LIBS="-lcsf $LIBS"
+    echo "using pre-installed libcsf."
+  else
+    echo "using internal csf code."
+  fi
+
+elif test "$with_pcraster" = "internal" ; then
+
+  PCRASTER_SETTING=internal
+
+  echo "using internal csf code."
+
+else
+
+  PCRASTER_SETTING=external
+  LIBS="-L$with_pcraster/lib -lcsf $LIBS"
+  EXTRA_INCLUDES="-I$with_pcraster/include $EXTRA_INCLUDES"
+
+  echo "using libcsf from $with_pcraster."
+
+fi
+
+AC_SUBST(PCRASTER_SETTING,$PCRASTER_SETTING)
+
+if test "$PCRASTER_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="pcraster $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select a PNG Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([png], [  --with-png[=ARG]        Include PNG support (ARG=internal, no or path)],,)
+
+AC_MSG_CHECKING([for libpng])
+
+if test "$with_png" = "no" ; then
+
+  PNG_SETTING=no
+
+  echo "png support disabled."
+
+elif test "$with_png" = "yes" -o "$with_png" = "" ; then
+
+  AC_CHECK_LIB([png], [png_set_IHDR], [PNG_SETTING=external], [PNG_SETTING=internal], [$LIBS])
+  AC_CHECK_HEADERS([png.h])
+
+  if test "$PNG_SETTING" = "external" -a "$ac_cv_header_png_h" = "no" ; then
+    PNG_SETTING=internal
+  fi
+  if test "$PNG_SETTING" = "external" ; then
+    LIBS="-lpng $LIBS"
+    echo "using pre-installed libpng."
+  else
+    echo "using internal png code."
+  fi
+
+elif test "$with_png" = "internal" ; then
+
+  PNG_SETTING=internal
+
+  echo "using internal png code."
+
+else
+
+  PNG_SETTING=external
+  LIBS="-L$with_png -L$with_png/lib -lpng $LIBS"
+  EXTRA_INCLUDES="-I$with_png -I$with_png/include $EXTRA_INCLUDES"
+
+  echo "using libpng from $with_png."
+
+fi
+
+AC_SUBST([PNG_SETTING], [$PNG_SETTING])
+
+if test "$PNG_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="png $OPT_GDAL_FORMATS"
+  if test "x$INTERNAL_FORMAT_grib_ENABLED" = "xyes"; then
+  	GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED grib"
+  fi
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests renaming internal libpng symbols
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rename_internal_libpng_symbols,[  --with-rename-internal-libpng-symbols[=ARG] Prefix internal libpng symbols with gdal_ (ARG=yes/no)],,)
+
+RENAME_INTERNAL_PNG_SYMBOLS=no
+if test "x$with_rename_internal_libpng_symbols" = "xyes" -o "x$with_rename_internal_libpng_symbols" = "x"; then
+    RENAME_INTERNAL_PNG_SYMBOLS=yes
+fi
+
+AC_SUBST(RENAME_INTERNAL_PNG_SYMBOLS,$RENAME_INTERNAL_PNG_SYMBOLS)
+
+dnl ---------------------------------------------------------------------------
+dnl Enable DDS driver.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([dds], [  --with-dds[=ARG]        Include DDS support (ARG=no, or path)],,)
+
+AC_MSG_CHECKING([for libcrunch])
+
+if test "$with_dds" = "no" -o "$with_dds" = ""; then
+
+  DDS_SETTING="no"
+  CRUNCHDIR=""
+
+  echo "dds support disabled."
+
+else
+
+  DDS_SETTING=yes
+  CRUNCHDIR="$with_dds"
+  LIBS="-L$with_dds/lib/ -lcrunch $LIBS"
+  echo "using libcrunch from $with_dds."
+
+fi
+
+AC_SUBST(CRUNCHDIR,$CRUNCHDIR)
+AC_SUBST([DDS_SETTING], [$DDS_SETTING])
+
+if test "$DDS_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="dds $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if GTA library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([gta],[  --with-gta[=ARG]        Include GTA support (ARG=no or libgta tree prefix)],,)
+
+if test "$with_gta" = "no" ; then
+
+  GTA_SETTING=no
+
+  echo "GTA support disabled."
+
+elif test "$with_gta" = "yes" -o "$with_gta" = "" ; then
+
+  AC_CHECK_LIB([gta], [gta_version], [GTA_SETTING=yes], [GTA_SETTING=no],)
+
+  if test "$GTA_SETTING" = "yes" ; then
+    LIBS="-lgta $LIBS"
+    echo "using pre-installed libgta."
+  else
+    echo "libgta not found - GTA support disabled"
+  fi
+
+else
+
+  GTA_SETTING=yes
+  LIBS="-L$with_gta -L$with_gta/lib -lgta $LIBS"
+  EXTRA_INCLUDES="-I$with_gta -I$with_gta/include $EXTRA_INCLUDES"
+
+  echo "using libgta from $with_gta."
+fi
+
+AC_SUBST([GTA_SETTING], [$GTA_SETTING])
+
+if test "$GTA_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="gta $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select PCIDSK options.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([pcidsk], [  --with-pcidsk[=ARG]     Path to external PCIDSK SDK or internal (default)],,)
+
+AC_MSG_CHECKING([for PCIDSK])
+
+PCIDSK_LIB=
+PCIDSK_INCLUDE=
+
+if test "$with_pcidsk" = "no" ; then
+
+  PCIDSK_SETTING=no
+
+  echo "pcidsk support disabled."
+
+elif test "$with_pcidsk" = "" -o "$with_pcidsk" = "yes" -o "$with_pcidsk" = "internal" ; then
+
+  PCIDSK_SETTING=internal
+
+  echo "using internal libpcidsk."
+
+else
+
+  PCIDSK_SETTING=external
+  PCIDSK_LIB="-L$with_pcidsk/lib -lpcidsk"
+  PCIDSK_INCLUDE="-I$with_pcidsk/include -I$with_pcidsk/include/pcidsk"
+
+  echo "using libpcidsk from $with_pcidsk."
+
+fi
+
+if test "$with_pcidsk" != "no" ; then
+
+  AC_SUBST([PCIDSK_SETTING], [$PCIDSK_SETTING])
+  AC_SUBST([PCIDSK_LIB], [$PCIDSK_LIB])
+  AC_SUBST([PCIDSK_INCLUDE], [$PCIDSK_INCLUDE])
+
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select a libgeotiff library to use.
+dnl ---------------------------------------------------------------------------
+
+GEOTIFF_INCLUDE=
+AC_ARG_WITH(geotiff,[  --with-geotiff=ARG    Libgeotiff library to use (ARG=internal, yes or path)],,)
+
+if test "$with_geotiff" = "yes" -o "$with_geotiff" = "" ; then
+
+  if test "$TIFF_SETTING" = "internal" ; then
+    GEOTIFF_SETTING=internal
+  else
+    dnl We now require libgeotiff 1.5.0
+    AC_CHECK_LIB(geotiff,GTIFAttachPROJContext,GEOTIFF_SETTING=external,GEOTIFF_SETTING=internal)
+
+  fi
+
+  if test "$GEOTIFF_SETTING" = "external" ; then
+
+    dnl Now search for headers
+    if test -r /usr/include/geotiff.h ; then
+      GEOTIFF_INCLUDE=
+    dnl Debian (at least some versions of it) install in /usr/include/geotiff
+    elif test -r /usr/include/geotiff/geotiff.h ; then
+      GEOTIFF_INCLUDE="-I/usr/include/geotiff"
+    dnl Fedora and OpenSuse in /usr/include/libgeotiff (#4706)
+    elif test -r /usr/include/libgeotiff/geotiff.h ; then
+      GEOTIFF_INCLUDE="-I/usr/include/libgeotiff"
+    else
+      AC_CHECK_HEADERS([geotiff.h])
+      if test "$ac_cv_header_geotiff_h" = "no" ; then
+        AC_MSG_ERROR([cannot find geotiff.h])
+      fi
+    fi
+
+    LIBS="-lgeotiff $LIBS"
+    echo "using pre-installed libgeotiff."
+
+  else
+
+    echo "using internal GeoTIFF code."
+
+  fi
+
+elif test "$with_geotiff" = "internal" ; then
+
+  GEOTIFF_SETTING=internal
+
+  echo "using internal GeoTIFF code."
+
+elif test "x${with_geotiff}" = "xno" ; then
+
+  AC_MSG_ERROR([libgeotiff is a required dependency])
+
+else
+
+  GEOTIFF_SETTING=external
+
+  dnl We now require libgeotiff 1.5.0
+  dnl first check if $with_geotiff/lib has the library:
+  AC_CHECK_LIB(geotiff,GTIFAttachPROJContext,GEOTIFF_SETTING=external,GEOTIFF_SETTING=not_found,-L$with_geotiff/lib)
+
+  if test $GEOTIFF_SETTING = "external" ; then
+    LIBS="-L$with_geotiff/lib -lgeotiff $LIBS"
+    if test  -d $with_geotiff/include ; then
+      EXTRA_INCLUDES="-I$with_geotiff/include $EXTRA_INCLUDES"
+    fi
+  else
+    dnl check if $with_geotiff itself contains the header and library (e.g. as an uninstalled build directory would)
+    AC_CHECK_LIB(geotiff,GTIFAttachPROJContext,GEOTIFF_SETTING=external,AC_MSG_ERROR([We require at least GeoTIFF 1.5.0. Consider using the one supplied with GDAL]),-L$with_geotiff)
+    if test $GEOTIFF_SETTING = "external" ; then
+      LIBS="-L$with_geotiff -lgeotiff $LIBS"
+      EXTRA_INCLUDES="-I$with_geotiff $EXTRA_INCLUDES"
+    fi
+  fi
+
+  echo "using libgeotiff from $with_geotiff."
+fi
+
+AC_SUBST(GEOTIFF_SETTING,$GEOTIFF_SETTING)
+AC_SUBST(GEOTIFF_INCLUDE,$GEOTIFF_INCLUDE)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for JPEG 12 bit
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([jpeg12],
+	    AS_HELP_STRING([--without-jpeg12],
+	       [Disable JPEG 8/12bit TIFF support]),,)
+
+TIFF_JPEG12_ENABLED=no
+AC_MSG_CHECKING([for jpeg12])
+if test "$with_jpeg12" =  no ; then
+    JPEG12_ENABLED=no
+    AC_MSG_RESULT([disabled by user])
+
+elif test "$JPEG_SETTING" = "no" -a "$with_jpeg12" = ""; then
+    JPEG12_ENABLED=no
+    AC_MSG_RESULT([disabled, JPEG disabled])
+
+elif test "$TIFF_SETTING" = "internal" ; then
+    AC_MSG_RESULT([enabled])
+    JPEG12_ENABLED=yes
+    TIFF_JPEG12_ENABLED=yes
+
+else
+    AC_MSG_RESULT([enabled])
+    JPEG12_ENABLED=yes
+
+fi
+
+AC_SUBST(JPEG12_ENABLED,$JPEG12_ENABLED)
+AC_SUBST(TIFF_JPEG12_ENABLED,$TIFF_JPEG12_ENABLED)
+
+dnl ---------------------------------------------------------------------------
+dnl Select a GIF Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(gif,[  --with-gif[=ARG]        Include GIF support (ARG=internal, no or path)],,)
+
+if test "$with_gif" = "no" ; then
+
+  GIF_SETTING=no
+
+  echo "gif support disabled."
+
+elif test "$with_gif" = "yes" -o "$with_gif" = "" ; then
+
+  AC_CHECK_LIB(gif,DGifOpenFileName,GIF_SETTING=external,GIF_SETTING=internal,)
+  AC_CHECK_HEADERS(gif_lib.h)
+
+  if test "$GIF_SETTING" = "external" ; then
+    LIBS="-lgif $LIBS"
+    echo "using pre-installed libgif."
+  else
+    echo "using internal gif code."
+  fi
+
+elif test "$with_gif" = "internal" ; then
+
+  GIF_SETTING=internal
+
+  echo "using internal gif code."
+
+else
+
+  GIF_SETTING=external
+  LIBS="-L$with_gif -L$with_gif/lib -lgif $LIBS"
+  EXTRA_INCLUDES="-I$with_gif -I$with_gif/include $EXTRA_INCLUDES"
+
+  echo "using libgif from $with_gif."
+
+fi
+
+AC_SUBST(GIF_SETTING,$GIF_SETTING)
+
+if test "$GIF_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="gif $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select an OGDI Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+OGDI_INCLUDE=
+export OGDI_INCLUDE
+
+AC_ARG_WITH(ogdi,[  --with-ogdi[=ARG]       Include OGDI support (ARG=path)],,)
+
+if test "$with_ogdi" = "no" ; then
+
+  HAVE_OGDI=no
+
+  echo "ogdi support disabled."
+
+elif test "$with_ogdi" = "yes" -o "$with_ogdi" = "" ; then
+
+  PKG_CHECK_MODULES([OGDI], [ogdi], [HAVE_OGDI=yes], [:])
+  if test "$HAVE_OGDI" = yes; then
+    OGDI_INCLUDE=$OGDI_CFLAGS
+    LIBS="$OGDI_LIBS $LIBS"
+  else
+    AC_CHECK_HEADERS(ecs.h)
+    if test "$ac_cv_header_ecs_h" = "no" ; then
+      if test -f "/usr/include/ogdi/ecs.h"; then
+          OGDI_INCLUDE="-I/usr/include/ogdi"
+      elif test -f "/usr/local/include/ogdi/ecs.h"; then
+          OGDI_INCLUDE="-I/usr/local/include/ogdi"
+      elif test -f "/usr/include/ecs.h"; then
+          OGDI_INCLUDE="-I/usr/include"
+      elif test -f "/usr/local/include/ecs.h"; then
+          OGDI_INCLUDE="-I/usr/local/include"
+      fi
+    fi
+
+    if test "$OGDI_INCLUDE" != "" -o "$ac_cv_header_ecs_h" = "yes"; then
+      AC_CHECK_LIB(ogdi,cln_GetLayerCapabilities,HAVE_OGDI=yes,HAVE_OGDI=no,)
+      if test "$HAVE_OGDI" = "yes" ; then
+        LIBS="-logdi $LIBS"
+      else
+        dnl For backward compatibility. Retry with ogdi31 as a name
+        AC_CHECK_LIB(ogdi31,cln_GetLayerCapabilities,HAVE_OGDI=yes,HAVE_OGDI=no,)
+        if test "$HAVE_OGDI" = "yes" ; then
+          LIBS="-logdi31 $LIBS"
+        fi
+      fi
+    else
+      HAVE_OGDI=no
+    fi
+  fi
+
+else
+
+  AC_CHECK_LIB(ogdi,cln_GetLayerCapabilities,HAVE_OGDI=yes,HAVE_OGDI=no,-L$with_ogdi -L$with_ogdi/lib -logdi)
+  if test "$HAVE_OGDI" = "yes" ; then
+    if test -f "$with_ogdi/ecs.h" -o -f "$with_ogdi/include/ecs.h"; then
+        LIBS="-L$with_ogdi -L$with_ogdi/lib -logdi $LIBS"
+        OGDI_INCLUDE="-I$with_ogdi -I$with_ogdi/include"
+
+        echo "using libogdi from $with_ogdi."
+     else
+        HAVE_OGDI=no
+        AC_MSG_ERROR([ecs.h not found.])
+     fi
+  else
+    dnl For backward compatibility. Retry with ogdi31 as a name
+    AC_CHECK_LIB(ogdi31,cln_GetLayerCapabilities,HAVE_OGDI=yes,HAVE_OGDI=no,-L$with_ogdi -L$with_ogdi/lib -logdi31)
+    if test "$HAVE_OGDI" = "yes" ; then
+      if test -f "$with_ogdi/ecs.h" -o -f "$with_ogdi/include/ecs.h"; then
+        LIBS="-L$with_ogdi -L$with_ogdi/lib -logdi31 $LIBS"
+        OGDI_INCLUDE="-I$with_ogdi -I$with_ogdi/include"
+
+        echo "using libogdi31 from $with_ogdi."
+      else
+        HAVE_OGDI=no
+        AC_MSG_ERROR([ecs.h not found.])
+      fi
+    else
+      AC_MSG_ERROR([libogdi not found.])
+    fi
+  fi
+
+fi
+
+AC_SUBST(HAVE_OGDI,$HAVE_OGDI)
+AC_SUBST(OGDI_INCLUDE,$OGDI_INCLUDE)
+
+dnl ---------------------------------------------------------------------------
+dnl Select a SOSI lib to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(sosi,[  --with-sosi[=ARG]        Include SOSI support (ARG=SOSI lib Path, yes or no)],,)
+
+if test -z "$with_sosi" -o "$with_sosi" = "no" ; then
+
+  SOSI_ENABLED=no
+
+  echo "SOSI support disabled."
+
+elif test "$with_sosi" = "yes" ; then
+
+    AC_MSG_CHECKING([for libfyba])
+
+    rm -f testfyba.*
+    rm -f testfyba
+    echo "#include <fyba.h>" > testfyba.cpp
+    echo "int main() { LC_Init(); return 0; }" >> testfyba.cpp
+    if test  -r /usr/include/fyba -a -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -I/usr/include/fyba -DLINUX testfyba.cpp -lfyba -lfygm -lfyut -o testfyba 2>&1`" ; then
+        AC_MSG_RESULT([found])
+        SOSI_ENABLED=yes
+        SOSI_LIB="-lfyba -lfygm -lfyut"
+        SOSI_INC="-I/usr/include/fyba"
+    else
+        AC_MSG_RESULT([not found])
+        AC_MSG_CHECKING([for libfyba.a, libfygm.a and libfyut.a in /usr/local/lib])
+        if test -r /usr/local/lib/libfyba.a -a -r /usr/local/lib/libfygm.a -a -r /usr/local/lib/libfyut.a ; then
+            AC_MSG_RESULT([found])
+            SOSI_ENABLED=yes
+            SOSI_LIB="/usr/local/lib/libfyba.a /usr/local/lib/libfygm.a /usr/local/lib/libfyut.a"
+        else
+            AC_MSG_ERROR([not found.])
+        fi
+
+        AC_MSG_CHECKING([for fyba.h, fygm.h and fyut.h in /usr/local/include/fyba])
+        if test -r /usr/local/include/fyba/fyba.h -a -r /usr/local/include/fyba/fygm.h -a -r /usr/local/include/fyba/fyut.h ; then
+            AC_MSG_RESULT([found])
+            SOSI_ENABLED=yes
+            SOSI_INC="-I/usr/local/include/fyba"
+        else
+            AC_MSG_ERROR([not found.])
+        fi
+    fi
+
+    rm -f testfyba.*
+    rm -f testfyba
+else
+
+  AC_MSG_CHECKING([for libfyba.a, libfygm.a and libfyut.a in $with_sosi/lib])
+  if test -r $with_sosi/lib/libfyba.a -a -r $with_sosi/lib/libfygm.a -a -r $with_sosi/lib/libfyut.a ; then
+    AC_MSG_RESULT([found.])
+    SOSI_LIB="$with_sosi/lib/libfyba.a $with_sosi/lib/libfygm.a $with_sosi/lib/libfyut.a"
+    SOSI_ENABLED=yes
+  else
+    AC_MSG_ERROR([not found.])
+  fi
+
+  AC_MSG_CHECKING([for fyba.h in $with_sosi/include/fyba])
+  if test -r $with_sosi/include/fyba/fyba.h -a -r $with_sosi/include/fyba/fygm.h -a -r $with_sosi/include/fyba/fyut.h ; then
+    AC_MSG_RESULT([found.])
+    SOSI_INC="-I$with_sosi/include/fyba"
+    SOSI_ENABLED=yes
+  else
+    AC_MSG_ERROR([not found.])
+  fi
+
+fi
+
+AC_SUBST(SOSI_ENABLED, $SOSI_ENABLED)
+AC_SUBST(SOSI_LIB, $SOSI_LIB)
+AC_SUBST(SOSI_INC, $SOSI_INC)
+
+dnl ---------------------------------------------------------------------------
+dnl MongoCXXv3 driver
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(mongocxxv3,[  --with-mongocxxv3[=ARG]        Include MongoCXXv3 support (ARG=yes or no)],,)
+
+MONGOCXXV3_ENABLED=no
+
+if test "$with_mongocxxv3" = "no" ; then
+
+  echo "MONGODBv3 support disabled."
+
+elif test "$with_mongocxxv3" = "yes" -o "$with_mongocxxv3" = "" ; then
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([MONGOCXXV3], [libmongocxx >= 3.4.0], [MONGOCXXV3_ENABLED=yes], [MONGOCXXV3_ENABLED=no])
+
+  if test "$MONGOCXXV3_ENABLED" = "no" -a "$with_mongocxxv3" = "yes" ; then
+    AC_MSG_ERROR([mongocxxv3 requested but no found])
+  fi
+
+fi
+
+AC_SUBST(MONGOCXXV3_ENABLED, $MONGOCXXV3_ENABLED)
+AC_SUBST(MONGOCXXV3_LIBS, $MONGOCXXV3_LIBS)
+AC_SUBST(MONGOCXXV3_CFLAGS, $MONGOCXXV3_CFLAGS)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Select an HDF4 Library to use, or disable driver.
+dnl
+dnl We assume the user will have libjpeg and libz from other sources when
+dnl linking against static HDF4 libraries.
+dnl ---------------------------------------------------------------------------
+
+HDF4_INCLUDE=""
+
+AC_ARG_WITH(hdf4,[  --with-hdf4[=ARG]       Include HDF4 support (ARG=path)],,)
+
+if test x"$with_hdf4" = x"no" ; then
+
+  HAVE_HDF4=no
+
+  echo "hdf4 support disabled."
+
+else
+
+  if test x"$with_hdf4" = x"yes" -o x"$with_hdf4" = x"" ; then
+dnl Fedora has hdf static libraries in /usr/lib/hdf
+    if test -d /usr/lib64/hdf; then
+      HDF_LIB_DIR="/usr/lib64/hdf"
+    elif test -d /usr/lib/hdf; then
+      HDF_LIB_DIR="/usr/lib/hdf"
+    else
+      HDF_LIB_DIR=""
+    fi
+  else
+    if test -d $with_hdf4/lib ; then
+      HDF_LIB_DIR="$with_hdf4/lib"
+    else
+      HDF_LIB_DIR="$with_hdf4"
+    fi
+  fi
+
+  ORIG_LIBS="$LIBS"
+  if test "$HDF_LIB_DIR" != "" ; then
+    LIBS="-L$HDF_LIB_DIR $LIBS"
+  fi
+
+dnl Debian supplies the HDF4 library which does not conflict with NetCDF.
+dnl Test for Debian flavor first. Hint: install the libhdf4-alt-dev package.
+  AC_CHECK_LIB(mfhdfalt,SDreaddata,HDF_LIB_NAME="-lmfhdfalt -ldfalt",HDF_LIB_NAME=missing,-ldfalt)
+
+dnl If it fails, test again for normal libmfhdf/libdf
+  if test "$HDF_LIB_NAME" = "missing" ; then
+    unset ac_cv_lib_mfhdf_SDreaddata
+    AC_CHECK_LIB(mfhdf,SDreaddata,HDF_LIB_NAME="-lmfhdf -ldf",HDF_LIB_NAME=missing,-ldf)
+    if test "$HDF_LIB_NAME" = "missing" ; then
+      unset ac_cv_lib_mfhdf_SDreaddata
+      AC_CHECK_LIB(hdf4,SDreaddata,HDF_LIB_NAME=-lhdf4,HDF_LIB_NAME=missing,)
+    fi
+  fi
+
+dnl Test again, with -ldf, -ljpeg and -lz this time.
+  if test "$HDF_LIB_NAME" = "missing" ; then
+    unset ac_cv_lib_mfhdf_SDreaddata
+    AC_CHECK_LIB(mfhdf,SDreaddata,HDF_LIB_NAME="-lmfhdf -ldf",HDF_LIB_NAME=missing,-ldf -ljpeg -lz)
+  fi
+
+dnl Not found... again, with -lsz.
+  if test "$HDF_LIB_NAME" = "missing" ; then
+    unset ac_cv_lib_mfhdf_SDreaddata
+    AC_CHECK_LIB(mfhdf,SDreaddata,HDF_LIB_NAME="-lmfhdf -ldf -lsz",HDF_LIB_NAME=missing,-ldf -lsz -ljpeg -lz)
+  fi
+
+  if test "$HDF_LIB_NAME" != "missing" ; then
+
+    if test "$HDF_LIB_DIR" != "" ; then
+      LIBS="-L$HDF_LIB_DIR $HDF_LIB_NAME $ORIG_LIBS"
+    else
+      LIBS="$HDF_LIB_NAME $ORIG_LIBS"
+    fi
+
+    dnl HDF4 library newer than 4.2.5 has a SDreset_maxopenfiles/SDget_maxopenfiles interface
+    dnl which allows opening many HDF files simultaneously (the max number of files was previously
+    dnl hardcoded and too low, smth. like 32). Search for it and use if available.
+    AC_CHECK_LIB(mfhdfalt,SDget_maxopenfiles,HDF4_HAS_MAXOPENFILES=yes,HDF4_HAS_MAXOPENFILES=no,$HDF_LIB_NAME)
+    if test "$HDF4_HAS_MAXOPENFILES" = "no" ; then
+      AC_CHECK_LIB(mfhdf,SDget_maxopenfiles,HDF4_HAS_MAXOPENFILES=yes,HDF4_HAS_MAXOPENFILES=no,$HDF_LIB_NAME)
+    fi
+
+  dnl Now search for headers
+    if test "$with_hdf4" = "yes" -o "$with_hdf4" = "" -a -r /usr/include/hdf/hdf.h ; then
+      HDF4_INCLUDE="-I/usr/include/hdf"
+    elif test -r "$with_hdf4/hdf/hdf.h" ; then
+      HDF4_INCLUDE="-I$with_hdf4/hdf"
+    elif test -r "$with_hdf4/include/hdf/hdf.h" ; then
+      HDF4_INCLUDE="-I$with_hdf4/include/hdf"
+    elif test -r "$with_hdf4/include/hdf.h" ; then
+      HDF4_INCLUDE="-I$with_hdf4/include"
+    elif test -r "$with_hdf4/hdf.h" ; then
+      HDF4_INCLUDE="-I$with_hdf4"
+    fi
+
+    HAVE_HDF4=yes
+
+  else
+
+    if test x"$with_hdf4" != x"" ; then
+      AC_MSG_ERROR([HDF4 support requested with arg "$with_hdf4", but neither hdf4 nor mfhdf lib found])
+    else
+      LIBS="$ORIG_LIBS"
+      HAVE_HDF4=no
+    fi
+
+  fi
+
+fi
+
+AC_SUBST(HAVE_HDF4,$HAVE_HDF4)
+AC_SUBST(HDF4_INCLUDE,$HDF4_INCLUDE)
+AC_SUBST(HDF4_HAS_MAXOPENFILES,$HDF4_HAS_MAXOPENFILES)
+
+if test "$HAVE_HDF4" != "no" ; then
+  OPT_GDAL_FORMATS="hdf4 $OPT_GDAL_FORMATS"
+fi
+
+
+dnl ---------------------------------------------------------------------------
+dnl Select an HDF5 Library to use, or disable driver.
+dnl
+dnl ---------------------------------------------------------------------------
+
+HDF5_INCLUDE=""
+
+AC_ARG_WITH(hdf5,[  --with-hdf5[=ARG]       Include HDF5 support (ARG=path)],,)
+
+if test "$with_hdf5" = "no" ; then
+
+  HAVE_HDF5=no
+
+  echo "hdf5 support disabled."
+
+elif test "$with_hdf5" = "yes" -o "$with_hdf5" = "" ; then
+
+  HDF5_CFLAGS=""
+  HDF5_LIBS=""
+  PKG_PROG_PKG_CONFIG([0.21]) # check and set $PKG_CONFIG
+  PKG_CHECK_MODULES([HDF5], [hdf5], [HAVE_HDF5=yes], [HAVE_HDF5=no])
+
+  if test "$HAVE_HDF5" = "yes"; then
+
+    # Test that the package found is for the right architecture
+    saved_LIBS="$LIBS"
+    LIBS="$HDF5_LIBS"
+    AC_CHECK_LIB(hdf5,H5Fopen, [HAVE_HDF5=yes], [HAVE_HDF5=no])
+    LIBS="$saved_LIBS"
+
+    if test "$HAVE_HDF5" = "yes"; then
+        LIBS="$HDF5_LIBS $LIBS"
+        HDF5_INCLUDE="$HDF5_CFLAGS"
+    fi
+
+  else
+
+    AC_CHECK_LIB(hdf5,H5Fopen,HAVE_HDF5=yes,HAVE_HDF5=no,)
+
+    if test "$HAVE_HDF5" = "yes" ; then
+        LIBS="-lhdf5 $LIBS"
+    fi
+
+    dnl Some Linux distros install hdf include files here.
+    dnl if test "$HAVE_HDF5" = "yes" -a -r /usr/include/hdf5.h ; then
+    dnl    HDF5_INCLUDE="-I/usr/include"
+    dnl fi
+  fi
+
+else
+
+  if test -d $with_hdf5/lib ; then
+    HDF5_LIB_DIR=$with_hdf5/lib
+  else
+    HDF5_LIB_DIR=$with_hdf5
+  fi
+
+  ORIG_LIBS="$LIBS"
+  LIBS="-L$HDF5_LIB_DIR $LIBS -lhdf5"
+
+  AC_CHECK_LIB(hdf5,H5Fopen,HDF5_LIB_NAME="-lhdf5 ",HDF5_LIB_NAME=missing,-lhdf5)
+
+  if test "$HDF5_LIB_NAME" = "missing" ; then
+    AC_MSG_ERROR([HDF5 support requested with arg $with_hdf5, but no hdf5 lib found])
+  fi
+
+  LIBS="-L$HDF5_LIB_DIR $HDF5_LIB_NAME $ORIG_LIBS"
+
+  if test -r "$with_hdf5/hdf5/hdf5.h" ; then
+    HDF5_INCLUDE="-I$with_hdf5/hdf5"
+  elif test -r "$with_hdf5/include/hdf5/hdf5.h" ; then
+    HDF5_INCLUDE="-I$with_hdf5/include/hdf5"
+  elif test -r "$with_hdf5/include/hdf5.h" ; then
+    HDF5_INCLUDE="-I$with_hdf5/include"
+  elif test -r "$with_hdf5/hdf.h" ; then
+    HDF5_INCLUDE="-I$with_hdf5"
+  fi
+
+  HAVE_HDF5=yes
+fi
+
+AC_SUBST(HAVE_HDF5,$HAVE_HDF5)
+AC_SUBST(HDF5_INCLUDE,$HDF5_INCLUDE)
+
+if test "$HAVE_HDF5" != "no" ; then
+  OPT_GDAL_FORMATS="hdf5 $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if kealib library is available.
+dnl ---------------------------------------------------------------------------
+
+KEA_CONFIG=no
+
+AC_ARG_WITH(kea,[  --with-kea[=ARG]      Include kealib (ARG=path to kea-config) [[default=yes]]],,)
+
+if test "$with_kea" = "yes" -o "x$with_kea" = "x" ; then
+  AC_PATH_PROG(KEA_CONFIG, kea-config, no)
+else
+   KEA_CONFIG=$with_kea
+fi
+
+AC_MSG_CHECKING([for kea])
+
+if test "$KEA_CONFIG" = "no" ; then
+
+  HAVE_KEA=no
+  KEA_LIB=
+  KEA_INC=
+
+  AC_MSG_RESULT([no])
+
+else
+  if test -d $KEA_CONFIG ; then
+      AC_MSG_RESULT([no])
+      AC_MSG_ERROR([--with-kea argument is a directory.  It should be the path to the kea_config script, often somewhere like /usr/local/bin/kea_config.])
+  fi
+
+  if test \! -x $KEA_CONFIG ; then
+      AC_MSG_RESULT([no])
+      AC_MSG_ERROR([--with-kea argument is a not an executable file.  It should be the path to the kea_config script, often somewhere like /usr/local/bin/kea_config.])
+  fi
+
+  HAVE_KEA=yes
+  KEA_LIB="`$KEA_CONFIG --libs --hdflibs`"
+  KEA_INC="`$KEA_CONFIG --cflags --hdfcflags`"
+  AC_MSG_RESULT([yes])
+fi
+
+AC_SUBST(HAVE_KEA,$HAVE_KEA)
+AC_SUBST(KEA_INC,$KEA_INC)
+AC_SUBST(KEA_LIB,$KEA_LIB)
+
+if test "$HAVE_KEA" != "no" ; then
+  OPT_GDAL_FORMATS="kea $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if netcdf library is available.
+dnl ---------------------------------------------------------------------------
+
+NETCDF_SETTING=
+NETCDF_MEM=
+NETCDF_ROOT=
+NETCDF_HAS_NC4=
+NETCDF_HAS_HDF4=
+NETCDF_NCCONFIG=
+
+AC_ARG_WITH([netcdf],[  --with-netcdf[=ARG]     Include netCDF support (ARG=no or netCDF tree prefix)],,)
+
+if test "$with_netcdf" = "no" ; then
+
+  NETCDF_SETTING=no
+  NETCDF_MEM=no
+
+  echo "netCDF support disabled."
+
+else
+
+  dnl find nc-config location
+  unset ac_cv_path_NETCDF_NCCONFIG
+  if test "$with_netcdf" = "yes" -o "$with_netcdf" = "" ; then
+    AC_PATH_PROG(NETCDF_NCCONFIG, nc-config, no)
+  else
+    tmp_path="$with_netcdf/bin$PATH_SEPARATOR$with_netcdf"
+    AC_PATH_PROG(NETCDF_NCCONFIG, nc-config, no, $tmp_path)
+  fi
+
+  dnl test nc-config
+  if test "$NETCDF_NCCONFIG" = "no" ; then
+    echo "        did not find nc-config, some features may be missing"
+    echo "        use --with-netcdf=/path/to/netcdf or add nc-config to PATH"
+    NETCDF_NCCONFIG=
+  elif test "`$NETCDF_NCCONFIG --version`" = "" ; then
+    echo "did not get netCDF version from $NETCDF_NCCONFIG ... using fallback"
+    NETCDF_NCCONFIG=
+  fi
+
+  dnl test linking using flags from nc-config
+  if test "$NETCDF_NCCONFIG" != "" ; then
+
+    AC_MSG_CHECKING([libnetcdf compiler and linker flags with nc-config])
+    NETCDF_VERSION=`$NETCDF_NCCONFIG --version`
+    NETCDF_PREFIX=`$NETCDF_NCCONFIG --prefix`
+    NETCDF_INCLUDEDIR=`$NETCDF_NCCONFIG --includedir`
+    NETCDF_LIBS=`$NETCDF_NCCONFIG --static --libs`
+    echo ""
+    AC_MSG_RESULT([ got version="$NETCDF_VERSION", prefix="$NETCDF_PREFIX",
+ libs="$NETCDF_LIBS", includedir="$NETCDF_INCLUDEDIR"])
+
+    AC_CHECK_LIB([netcdf], [nc_open], [NETCDF_SETTING=yes], [NETCDF_SETTING=no], $NETCDF_LIBS)
+
+    if test "$NETCDF_SETTING" = "yes" ; then
+      EXTRA_INCLUDES="-I$NETCDF_INCLUDEDIR $EXTRA_INCLUDES"
+      NETCDF_ROOT=$NETCDF_PREFIX
+      LIBS="$NETCDF_LIBS $LIBS"
+    else
+      AC_MSG_ERROR("Netcdf via nc-config not working")
+    fi
+
+dnl previous behavior without nc-config
+
+dnl test linking using default settings
+elif test "$with_netcdf" = "yes" -o "$with_netcdf" = "" ; then
+
+  AC_CHECK_LIB([netcdf], [nc_open], [NETCDF_SETTING=yes], [NETCDF_SETTING=no],)
+
+  if test "$NETCDF_SETTING" = "yes" ; then
+
+    dnl Fedora has netcdf headers in /usr/include/netcdf
+    if test -d /usr/include/netcdf ; then
+      EXTRA_INCLUDES="-I/usr/include/netcdf $EXTRA_INCLUDES"
+      NETCDF_ROOT="/usr"
+    dnl RHEL 5 has netcdf headers in /usr/include/netcdf-3
+    elif test -d /usr/include/netcdf-3 ; then
+      EXTRA_INCLUDES="-I/usr/include/netcdf-3 $EXTRA_INCLUDES"
+      NETCDF_ROOT="/usr"
+    dnl ubuntu and fedora have netcdf headers in /usr/include
+    elif test -f /usr/include/netcdf.h ; then
+      NETCDF_ROOT="/usr"
+    dnl try /usr/local
+    elif test -f /usr/local/include/netcdf.h ; then
+      NETCDF_ROOT="/usr/local"
+    dnl print warning if include cannot be found
+    else
+      echo "using pre-installed libnetcdf."
+      echo -n "libnetcdf is installed but its location cannot be found, "
+      echo "use --with-netcdf=/path_to_netcdf for proper support"
+    fi
+    NETCDF_INCLUDEDIR="$NETCDF_ROOT/include/"
+
+    LIBS="-lnetcdf $LIBS"
+    if test "$NETCDF_ROOT" != "" ; then
+      echo "using pre-installed libnetcdf from "$NETCDF_ROOT
+    fi
+
+  else
+    echo "libnetcdf not found ... netCDF support disabled"
+  fi
+
+dnl test linking using --with_netcdf dir
+else
+
+  AC_CHECK_LIB([netcdf], [nc_open], [NETCDF_SETTING=yes], [NETCDF_SETTING=no],-L$with_netcdf -L$with_netcdf/lib)
+
+  if test "$NETCDF_SETTING" = "yes" ; then
+
+    NETCDF_SETTING=yes
+    NETCDF_ROOT="$with_netcdf"
+
+    if test -d $with_netcdf/lib ; then
+      LIBS="-L$with_netcdf/lib -lnetcdf $LIBS"
+      EXTRA_INCLUDES="-I$with_netcdf/include $EXTRA_INCLUDES"
+    else
+      LIBS="-L$with_netcdf -lnetcdf $LIBS"
+      EXTRA_INCLUDES="-I$with_netcdf $EXTRA_INCLUDES"
+    fi
+    NETCDF_INCLUDEDIR="$with_netcdf/include/"
+
+    echo "using libnetcdf from $with_netcdf"
+
+  else
+    echo "libnetcdf not found in "$with_netcdf" ... netCDF support disabled"
+  fi
+
+fi
+
+dnl test for NC4 and HDF4 support with nc-config
+  if test "$NETCDF_SETTING" = "yes" ; then
+
+    if test "$NETCDF_NCCONFIG" != "" ; then
+
+      AC_MSG_CHECKING([for netcdf-4 (and HDF5) support in libnetcdf])
+        if test "x$($NETCDF_NCCONFIG --has-nc4)" = "xyes"; then :
+          AC_MSG_RESULT([yes])
+          NETCDF_HAS_NC4=yes
+        else
+          AC_MSG_RESULT([no])
+          NETCDF_HAS_NC4=no
+        fi
+
+      AC_MSG_CHECKING([for HDF4 support in libnetcdf])
+        if test "x$($NETCDF_NCCONFIG --has-hdf4)" = "xyes"; then :
+          AC_MSG_RESULT([yes])
+          NETCDF_HAS_HDF4=yes
+        else
+          AC_MSG_RESULT([no])
+          NETCDF_HAS_HDF4=no
+        fi
+
+    else
+      NETCDF_HAS_NC4=no
+      NETCDF_HAS_HDF4=no
+    fi
+fi
+
+fi
+
+dnl export results
+
+AC_SUBST([NETCDF_SETTING], [$NETCDF_SETTING])
+
+if test "$NETCDF_SETTING" != "no" ; then
+
+   NETCDF_MEM=no
+   if test -f "$NETCDF_INCLUDEDIR/netcdf_mem.h"; then
+       NETCDF_MEM=yes;
+   fi
+
+   AC_SUBST([NETCDF_MEM], [$NETCDF_MEM])
+   AC_SUBST([NETCDF_ROOT], [$NETCDF_ROOT])
+   AC_SUBST([NETCDF_HAS_NC4], [$NETCDF_HAS_NC4])
+   AC_SUBST([NETCDF_HAS_HDF4], [$NETCDF_HAS_HDF4])
+
+   OPT_GDAL_FORMATS="netcdf $OPT_GDAL_FORMATS"
+
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select a OpenJPEG Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(openjpeg,[  --with-openjpeg     Include JPEG-2000 support via OpenJPEG 2.x library],,)
+
+HAVE_OPENJPEG=no
+
+if test "$with_openjpeg" = "no" ; then
+
+  AC_MSG_NOTICE([OpenJPEG (JPEG2000) support disabled.])
+
+else
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([OPENJPEG], [libopenjp2 >= 2.1.0],
+        [OPENJPEG_VERSION=`$PKG_CONFIG --modversion libopenjp2`],
+        [OPENJPEG_VERSION=;])
+
+  if test -n "$OPENJPEG_CFLAGS"; then
+
+    # Test that the package found is for the right architecture
+    saved_LIBS="$LIBS"
+    LIBS="$OPENJPEG_LIBS"
+    AC_CHECK_LIB(openjp2,opj_setup_decoder, [HAVE_OPENJPEG=yes], [HAVE_OPENJPEG=no])
+    LIBS="$saved_LIBS"
+
+    if test "$HAVE_OPENJPEG" = "yes"; then
+        EXTRA_INCLUDES="$OPENJPEG_CFLAGS $EXTRA_INCLUDES"
+        LIBS="$OPENJPEG_LIBS $LIBS"
+    fi
+  fi
+fi
+
+if test "$HAVE_OPENJPEG" != "no" ; then
+  OPT_GDAL_FORMATS="openjpeg $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select a FGDB API to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(fgdb,[  --with-fgdb[=ARG]        Include ESRI File Geodatabase support (ARG=FGDP API Path, yes or no)],,)
+
+FGDB_ENABLED=no
+FGDB_LIB=
+
+if test "$with_fgdb" = "no" ; then
+
+  echo "FGDB support disabled."
+
+elif test "$with_fgdb" = "yes" -o "$with_fgdb" = "" ; then
+
+    AC_MSG_CHECKING([for FileGDBAPI])
+
+    rm -f testfgdb.*
+    rm -f testfgdb
+    echo "#include <FileGDBAPI.h>" > testfgdb.cpp
+    echo "using namespace FileGDBAPI;" >> testfgdb.cpp
+    echo "int main() { Geodatabase oDB; std::wstring osStr; ::OpenGeodatabase(osStr, oDB); return 0; }" >> testfgdb.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testfgdb.cpp -lFileGDBAPI -lfgdbunixrtl -o testfgdb 2>&1`" ; then
+        AC_MSG_RESULT([FileGDBAPI found])
+        FGDB_ENABLED="yes"
+        FGDB_LIB="-lFileGDBAPI -lfgdbunixrtl"
+    else
+        if test "$with_fgdb" = "yes"; then
+            AC_MSG_ERROR([FileGDBAPI not found.])
+        else
+            AC_MSG_RESULT([FileGDBAPI not found.])
+        fi
+    fi
+    rm -f testfgdb.*
+    rm -f testfgdb
+
+else
+
+  AC_MSG_CHECKING([for libFileGDBAPI.so in in $with_fgdb/lib])
+  FGDB_ENABLED=yes
+  if test -r $with_fgdb/lib/libFileGDBAPI.so -a -r $with_fgdb/lib/libfgdbunixrtl.so ; then
+    AC_MSG_RESULT([found.])
+    FGDB_LIB="-L$with_fgdb/lib -lFileGDBAPI -lfgdbunixrtl"
+  elif test -r $with_fgdb/lib/libFileGDBAPI.dylib -a -r $with_fgdb/lib/libfgdbunixrtl.dylib ; then
+    AC_MSG_RESULT([found.])
+    FGDB_LIB="-L$with_fgdb/lib -lFileGDBAPI -lfgdbunixrtl"
+  else
+    AC_MSG_ERROR([not found.])
+  fi
+
+  AC_MSG_CHECKING([for FileGDBAPI.h in $with_fgdb/include])
+  if test -r $with_fgdb/include/FileGDBAPI.h ; then
+    AC_MSG_RESULT([found.])
+    FGDB_INC="-I$with_fgdb/include"
+  else
+    AC_MSG_ERROR([not found.])
+  fi
+
+fi
+
+if test "$FGDB_LIB" != ""; then
+  dnl pj_datums is not a function but an object, but for linking that doesn't matter.
+  AC_CHECK_LIB(FileGDBAPI,pj_datums,FGDB_HAS_PROJ4=yes,FGDB_HAS_PROJ4=no,$FGDB_LIB)
+fi
+
+AC_SUBST(FGDB_ENABLED, $FGDB_ENABLED)
+AC_SUBST(FGDB_LIB, $FGDB_LIB)
+AC_SUBST(FGDB_INC, $FGDB_INC)
+
+dnl ---------------------------------------------------------------------------
+dnl Select a ECW Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+ECW_FLAGS=
+ECW_LIBS=
+ECW_INCLUDE=
+ECW_54=
+
+AC_ARG_WITH(ecw,[  --with-ecw[=ARG]        Include ECW support (ARG=ECW SDK Path, yes or no)],,)
+
+if test ! -z "`uname | grep Darwin`" ; then
+  CARBON_FRAMEWORK="-framework Carbon"
+else
+  CARBON_FRAMEWORK=
+fi
+
+if test "$with_ecw" = "no" ; then
+
+  ECW_SETTING=no
+
+  echo "ECW support disabled."
+
+elif test "$with_ecw" = "yes" -o "$with_ecw" = "" ; then
+
+  AC_CHECK_LIB(NCSEcw,NCScbmOpenFileView,ECW_SETTING=yes,ECW_SETTING=no,-lNCSCnet -lNCSUtil)
+
+  if test "$ECW_SETTING" = "yes" ; then
+    ECW_LIBS="-lNCSEcw -lNCSEcwC -lNCSCnet -lNCSUtil"
+  fi
+
+  if test "$ECW_SETTING" = "no" ; then
+    AC_CHECK_LIB(ecwj2,NCScbmOpenFileView,ECW_SETTING=yes,ECW_SETTING=no,$CARBON_FRAMEWORK)
+    if test "$ECW_SETTING" = "yes" ; then
+      ECW_LIBS="-lecwj2 $CARBON_FRAMEWORK"
+    fi
+  fi
+else
+
+  AC_MSG_CHECKING([for libNCSEcw.a or libecwj2])
+  ECW_ARCH=x86
+  ECW_CONF="release"
+  ECW_FLAGS="-DLINUX -DX86 -DPOSIX -DHAVE_COMPRESS -DECW_COMPRESS_RW_SDK_VERSION"
+  ECW_FRAMEWORK_COCOA=""
+  if test "`arch`" = "x86_64" ; then
+    ECW_ARCH="x64"
+  fi
+  if test ! -z "`uname | grep Darwin`" ; then
+    ECW_ARCH=""
+    ECW_CONF=""
+    ECW_FLAGS=""
+    ECW_FRAMEWORK_COCOA=" -framework Cocoa "
+  fi
+
+  ECW_SETTING=yes
+  if test -r $with_ecw/lib/libNCSCnet.so -o -r $with_ecw/lib/libNCSCnet.dylib ; then
+    ECW_LIBS="-L$with_ecw/lib -lNCSEcw -lNCSEcwC -lNCSCnet -lNCSUtil"
+    AC_MSG_RESULT([found in $with_ecw/lib.])
+  elif test -r $with_ecw/lib/libNCSCNet.so -o -r $with_ecw/lib/libNCSCNet.dylib ; then
+    ECW_LIBS="-L$with_ecw/lib -lNCSEcw -lNCSEcwC -lNCSCNet -lNCSUtil"
+    AC_MSG_RESULT([found in $with_ecw/lib.])
+  elif test -r $with_ecw/bin/libNCSEcw.so -o -r $with_ecw/bin/libNCSEcw.dylib ; then
+    ECW_LIBS="-L$with_ecw/bin -lNCSEcw -lNCSEcwC -lNCSCnet -lNCSUtil"
+    AC_MSG_RESULT([found in $with_ecw/bin.])
+  elif test -r $with_ecw/lib/libecwj2.dylib ; then
+    ECW_LIBS="-L$with_ecw/lib -lecwj2 $CARBON_FRAMEWORK"
+    AC_MSG_RESULT([found libecwj2 in $with_ecw/lib.])
+
+  # ECW SDK 5.0 style and also for the case where license type is included in path i.e. specific license type is requested.
+  elif test -r $with_ecw/lib/$ECW_ARCH/$ECW_CONF/libNCSEcw.a ; then
+    # Test if we must use the newabi/cpp11abi version (SDK 5.4+)
+    if test -r $with_ecw/lib/newabi/$ECW_ARCH/$ECW_CONF/libNCSEcw.a || test -r $with_ecw/lib/cpp11abi/$ECW_ARCH/$ECW_CONF/libNCSEcw.a; then
+        if test -d $with_ecw/lib/newabi; then
+            ECW_ABIDIR=newabi
+        else
+            ECW_ABIDIR=cpp11abi
+        fi
+        echo "#include <string>" > testnewabi.cpp
+        echo "namespace NCS { class CString { public: static std::wstring Utf8Decode (const std::string &sUtf8); }; }" >> testnewabi.cpp
+        echo "int main() { return static_cast<int>(NCS::CString::Utf8Decode(std::string()).size()); }" >> testnewabi.cpp
+        if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testnewabi.cpp -L$with_ecw/lib/$ECW_ABIDIR/$ECW_ARCH/$ECW_CONF -lNCSEcw -o testnewabi 2>&1`" ; then
+            ECW_LIBDIR=$with_ecw/lib/$ECW_ABIDIR/$ECW_ARCH/$ECW_CONF
+            ECW_LIBS="-L$ECW_LIBDIR -lNCSEcw $ECW_FRAMEWORK_COCOA"
+            with_ecw=$with_ecw/$ecw_license_type
+            ECW_54="yes"
+            AC_MSG_RESULT([found Intergraph 5.4+ SDK with ${ECW_ABIDIR} in ${ECW_LIBDIR}.])
+            rm -f testnewabi.*
+            rm -f testnewabi
+            break
+        fi
+        rm -f testnewabi.*
+        rm -f testnewabi
+    fi
+    if test "$ECW_LIBS" = ""; then
+        ECW_LIBDIR=$with_ecw/lib/$ECW_ARCH/$ECW_CONF
+        ECW_LIBS="-L$ECW_LIBDIR -lNCSEcw $ECW_FRAMEWORK_COCOA"
+        AC_MSG_RESULT([found Intergraph 5.x+ SDK in ${ECW_LIBDIR}.])
+    fi
+ # ECWJP2 SDK 5.1 style
+  elif test -d $with_ecw; then
+    for ecw_license_type in "Desktop_Read-Write" "Server_Read-Only_EndUser" "Server_Read-Only" "Server_Read-Write" "Desktop_Read-Only"
+      do
+        # Test if we must use the newabi/cpp11abi version (SDK 5.4+)
+        if test -r $with_ecw/$ecw_license_type/lib/newabi/$ECW_ARCH/$ECW_CONF/libNCSEcw.a || test -r $with_ecw/$ecw_license_type/lib/cpp11abi/$ECW_ARCH/$ECW_CONF/libNCSEcw.a; then
+            if test -d $with_ecw/lib/newabi; then
+                ECW_ABIDIR=newabi
+            else
+                ECW_ABIDIR=cpp11abi
+            fi
+            echo "#include <string>" > testnewabi.cpp
+            echo "namespace NCS { class CString { public: static std::wstring Utf8Decode (const std::string &sUtf8); }; }" >> testnewabi.cpp
+            echo "int main() { return static_cast<int>(NCS::CString::Utf8Decode(std::string()).size()); }" >> testnewabi.cpp
+            if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testnewabi.cpp -L$with_ecw/$ecw_license_type/lib/$ECW_ABIDIR/$ECW_ARCH/$ECW_CONF -lNCSEcw -o testnewabi 2>&1`" ; then
+                ECW_LIBDIR=$with_ecw/$ecw_license_type/lib/$ECW_ABIDIR/$ECW_ARCH/$ECW_CONF
+                ECW_LIBS="-L$ECW_LIBDIR -lNCSEcw $ECW_FRAMEWORK_COCOA"
+                with_ecw=$with_ecw/$ecw_license_type
+                AC_MSG_RESULT([found Intergraph 5.4+ SDK with ${ECW_ABIDIR} in ${ECW_LIBDIR}.])
+                ECW_54="yes"
+                rm -f testnewabi.*
+                rm -f testnewabi
+                break
+            fi
+            rm -f testnewabi.*
+            rm -f testnewabi
+        fi
+        if test "$ECW_LIBS" = ""; then
+            ECW_LIBDIR=$with_ecw/$ecw_license_type/lib/$ECW_ARCH/$ECW_CONF
+            if test -r $ECW_LIBDIR/libNCSEcw.a; then
+                ECW_LIBS="-L$ECW_LIBDIR -lNCSEcw $ECW_FRAMEWORK_COCOA"
+                with_ecw=$with_ecw/$ecw_license_type
+                AC_MSG_RESULT([found Intergraph 5.x+ SDK in ${ECW_LIBDIR}.])
+                break
+            fi
+        fi
+      done
+ else
+    AC_MSG_ERROR([not found in $with_ecw.])
+  fi
+
+  AC_MSG_CHECKING([for NCSECWClient.h in $with_ecw/include])
+  if test -r $with_ecw/include/NCSECWClient.h ; then
+    AC_MSG_RESULT([found.])
+    ECW_INCLUDE="-I$with_ecw/include"
+  else
+    AC_MSG_ERROR([not found.])
+  fi
+  AC_MSG_CHECKING([for ECWJP2BuildNumber.h in $with_ecw/include])
+  if test -r $with_ecw/include/ECWJP2BuildNumber.h ; then
+    AC_MSG_RESULT([found.])
+    ECW_FLAGS="-DHAVE_ECW_BUILDNUMBER_H $ECW_FLAGS"
+  else
+    AC_MSG_RESULT([not found.])
+  fi
+fi
+
+AC_SUBST(ECW_SETTING,$ECW_SETTING)
+AC_SUBST(ECW_LIBS,$ECW_LIBS)
+AC_SUBST(ECW_FLAGS,$ECW_FLAGS)
+AC_SUBST(ECW_INCLUDE,$ECW_INCLUDE)
+
+if test "$ECW_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="ecw $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select Kakadu library or disable driver.
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([for Kakadu JPEG2000 support])
+
+AC_ARG_WITH(kakadu,[  --with-kakadu[=ARG]     Include Kakadu/JPEG2000 support],,)
+
+if test "$with_kakadu" = "no" -o "$with_kakadu" = "" ; then
+  KAKDIR=
+  AC_MSG_RESULT([not requested.])
+  HAVE_KAKADU=no
+elif test "$with_kakadu" = "yes" ; then
+  AC_MSG_ERROR([
+For JPEG2000 support using Kakadu you need provide the path to the Kakadu
+build directory.  Note that Kakadu is *not* free software.])
+else
+  KAKDIR=$with_kakadu
+  OPT_GDAL_FORMATS="jp2kak jpipkak $OPT_GDAL_FORMATS"
+  LIBS="$LIBS -L$with_kakadu/lib -lkdu"
+  AC_MSG_RESULT([requested.])
+  HAVE_KAKADU=yes
+fi
+
+AC_SUBST(KAKDIR,$KAKDIR)
+
+dnl ---------------------------------------------------------------------------
+dnl Select MrSID library or disable driver.
+dnl ---------------------------------------------------------------------------
+MRSID_FLAGS=
+HAVE_MRSID=no
+
+AC_ARG_WITH(mrsid,[  --with-mrsid[=ARG]      Include MrSID support (ARG=path to MrSID DSDK or no)],,)
+
+AC_ARG_WITH(jp2mrsid,[  --with-jp2mrsid[=ARG]   Enable MrSID JPEG2000 support (ARG=yes/no)],,)
+
+if test "x$with_mrsid" = "xno"  -o "x$with_mrsid" = "x" ; then
+
+  HAVE_MRSID=no
+
+  AC_MSG_NOTICE([MrSID support disabled.])
+
+else
+
+  MRSID_BASE="$with_mrsid/include"
+
+  AC_MSG_CHECKING([for lt_base.h in $MRSID_BASE/support])
+  if test -r "$MRSID_BASE/support/lt_base.h" ; then
+
+    AC_MSG_RESULT([found MrSID DSDK version 4.x or newer.])
+    HAVE_MRSID=yes
+    MRSID_INCLUDE="-I$MRSID_BASE/base -I$MRSID_BASE/metadata -I$MRSID_BASE/mrsid_readers -I$MRSID_BASE/j2k_readers -I$MRSID_BASE/support"
+
+  else
+
+    AC_MSG_RESULT([not found.])
+
+    AC_MSG_CHECKING([for lt_base.h in $MRSID_BASE])
+    if test -r "$MRSID_BASE/lt_base.h" ; then
+
+      AC_MSG_RESULT([found MrSID DSDK version 7.x or newer.]);
+      HAVE_MRSID=yes
+      MRSID_INCLUDE="-I$MRSID_BASE"
+
+    fi
+
+  fi
+
+  if test $HAVE_MRSID = yes ; then
+
+    MRSID_LIBS="-lpthread"
+
+    if test -r "$with_mrsid/lib/libltiesdk.a" ; then # v8+ esdk contains dsdk
+      _LIBPART=lib
+      MRSID_LIBS="-lltiesdk $MRSID_LIBS"
+    elif test -e "$with_mrsid/lib/libltidsdk.a" \
+           -o -e "$with_mrsid/lib/libltidsdk.so" \
+           -o -e "$with_mrsid/lib/libltidsdk.dylib" ; then
+      _LIBPART=lib
+      MRSID_LIBS="-lltidsdk $MRSID_LIBS"
+    else
+      _LIBPART=lib/Release
+      MRSID_LIBS="-lltidsdk $MRSID_LIBS"
+    fi
+
+    AC_MSG_CHECKING([for MG3ImageWriter.h in $with_mrsid/include/mrsid_writers])
+    if test -r "$with_mrsid/include/mrsid_writers/MG3ImageWriter.h" ; then
+      AC_MSG_RESULT([found MrSID ESDK version 4.x or newer.])
+      MRSID_FLAGS="-DMRSID_ESDK $MRSID_FLAGS"
+      MRSID_INCLUDE="-I$with_mrsid/include/mrsid_writers -I$with_mrsid/include/j2k_writers $MRSID_INCLUDE"
+      if test -r $with_mrsid/3rd-party/lib/Release/libcryptopp.a ; then
+        MRSID_LIBS="-lltiesdk -lcryptopp -lxmlparse $MRSID_LIBS"
+      else
+        MRSID_LIBS="-lltiesdk -lxmlparse $MRSID_LIBS"
+      fi
+    else
+      AC_MSG_RESULT([no encoding support.])
+    fi
+
+    AC_MSG_CHECKING([for MrSID JPEG2000 support])
+    if test "x$with_jp2mrsid" = "xyes" -a "$HAVE_KAKADU" = "yes" ; then
+      # SDK v8 or later don't seem to conflict with Kakadu
+      major_version=`cat $with_mrsid/include/lti_version.h | grep MAJOR | sed 's/#define LTI_SDK_MAJOR[ ]*\(.*\)/\1/'`
+      if test "x$major_version" != "x"; then
+        if test "$major_version" -ge 8; then
+            V8_OR_LATER=yes
+        fi
+      fi
+      if test "x$V8_OR_LATER" = "x"; then
+        AC_MSG_ERROR([MrSID JPEG2000 support requested, but this is incompatible with use of standalone Kakadu])
+      fi
+    fi
+
+    MRSID_KAKADU_LIB=""
+    if test "$HAVE_KAKADU" = "no" ; then
+      if test x"$with_jp2mrsid" = x"" -o x"$with_jp2mrsid" = x"yes" ; then
+        if test -r "$with_mrsid/3rd-party/$_LIBPART/libltikdu.a" ; then
+          with_jp2mrsid=yes
+          MRSID_KAKADU_LIB=-lltikdu
+        elif test -r "$with_mrsid/3rd-party/$_LIBPART/liblt_kakadu.a" ; then
+          with_jp2mrsid=yes
+          MRSID_KAKADU_LIB=-llt_kakadu
+        elif test -e "$with_mrsid/lib/libltidsdk.so" \
+               -o -e "$with_mrsid/lib/libltidsdk.dylib"; then # v8+ .so has kdu
+          with_jp2mrsid=yes
+        elif test x"$with_jp2mrsid" = x"yes" ; then
+          AC_MSG_ERROR([MrSID JPEG2000 support requested, but libltikdu.a not found.])
+        else
+          with_jp2mrsid=no
+        fi
+      fi
+    fi
+
+    if test "x$with_jp2mrsid" = "xyes" ; then
+      MRSID_LIBS="$MRSID_LIBS $MRSID_KAKADU_LIB"
+      MRSID_FLAGS="-DMRSID_J2K $MRSID_FLAGS"
+      AC_MSG_RESULT([enabled])
+    else
+      AC_MSG_RESULT([disabled])
+    fi
+
+    MRSID_LIBS="-L$with_mrsid/$_LIBPART $MRSID_LIBS"
+    MRSID_LIBS="-L$with_mrsid/3rd-party/$_LIBPART $MRSID_LIBS"
+
+  else
+    HAVE_MRSID=no
+    AC_MSG_RESULT([not found.])
+    AC_MSG_ERROR([  MrSID requested, but components not found.])
+  fi
+fi
+
+AC_SUBST(MRSID_INCLUDE,$MRSID_INCLUDE)
+AC_SUBST(MRSID_FLAGS,$MRSID_FLAGS)
+AC_SUBST(MRSID_LIBS,$MRSID_LIBS)
+
+if test "$HAVE_MRSID" != "no" ; then
+  CPPFLAGS="-D_REENTRANT $CPPFLAGS"
+  OPT_GDAL_FORMATS="mrsid $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if LuraTech library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(jp2lura,[  --with-j2lura[=ARG]    Include JP2Lua support (ARG=no, lura SDK install path)],,)
+
+AC_MSG_CHECKING([for JP2Lura support])
+
+HAVE_JP2LURA=no
+JP2LURA_INCLUDE=
+
+if test "$with_jp2lura" != "" -a "$with_jp2lura" != "no" ; then
+  AC_MSG_CHECKING([for lwf_jp2.h])
+  if test -f "$with_jp2lura/include/lwf_jp2.h"; then
+    AC_MSG_RESULT([yes])
+  else
+    AC_MSG_RESULT([no])
+    AC_MSG_ERROR([JP2Lura support requested but header not found])
+  fi
+  JP2LURA_INCLUDE="-I$with_jp2lura/include"
+
+  # mingw support
+  if test -f "$with_jp2lura/library/lwf_jp2.lib"; then
+      ln -s "$with_jp2lura/library/lwf_jp2.lib" "$with_jp2lura/library/lib_lwf_jp2.a"
+  fi
+
+  ORIG_LIBS="$LIBS"
+  LIBS="-L$with_jp2lura/library"
+
+  AC_CHECK_LIB(_lwf_jp2,JP2_Decompress_SetLicense,HAVE_JP2LURA="yes",,-lm)
+
+  if test "$HAVE_JP2LURA" = "no" ; then
+    AC_MSG_ERROR([JP2Lura support requested but library not found])
+  fi
+
+  LIBS="-L$with_jp2lura/library -l_lwf_jp2 -lm $ORIG_LIBS"
+fi
+
+AC_SUBST([JP2LURA_INCLUDE], [$JP2LURA_INCLUDE])
+
+if test "$HAVE_JP2LURA" != "no" ; then
+  OPT_GDAL_FORMATS="jp2lura $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Enable MSG format if EUMETSAT Wavelet Transform Software
+dnl available in the local tree
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([msg],
+	    AS_HELP_STRING([--with-msg[=ARG]],
+	       [Enable MSG driver (ARG=yes or no)]),,)
+
+HAVE_MSG=no
+HAVE_EUMETSATWT=no
+
+if test "x$with_msg" = "xyes" ; then
+    AC_MSG_CHECKING([for EUMETSAT Wavelet Transformation Software])
+
+    if test -d "frmts/msg/PublicDecompWT" -a \
+        -f "frmts/msg/PublicDecompWT/COMP/Inc/CImage.h"; then
+        HAVE_EUMETSATWT=yes
+    else
+        HAVE_EUMETSATWT=no
+    fi
+    AC_MSG_RESULT([$HAVE_EUMETSATWT])
+fi
+
+AC_MSG_CHECKING([for MSG])
+
+if test "x$with_msg" = "xyes" -o "x$with_msg" = "x" \
+    -a "x$HAVE_EUMETSATWT" = "xyes"; then
+    OPT_GDAL_FORMATS="msg $OPT_GDAL_FORMATS"
+    HAVE_MSG=yes
+    AC_MSG_RESULT([enabled])
+else
+    HAVE_MSG=no
+    AC_MSG_RESULT([not requested])
+fi
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check for GeoRaster in the local tree.
+dnl ---------------------------------------------------------------------------
+
+ORACLE_OCI_REQ_VERSION="10.0.1"
+AX_LIB_ORACLE_OCI($ORACLE_OCI_REQ_VERSION)
+
+if test "$HAVE_ORACLE_OCI" = "yes"; then
+    OPT_GDAL_FORMATS="georaster $OPT_GDAL_FORMATS"
+    HAVE_GEORASTER=yes
+else
+    HAVE_GEORASTER=no
+fi
+
+
+dnl ---------------------------------------------------------------------------
+
+AC_SUBST([OPT_GDAL_FORMATS], [$OPT_GDAL_FORMATS])
+
+dnl ---------------------------------------------------------------------------
+
+GNM_ENABLED=yes
+
+AC_ARG_WITH(gnm,[  --with-gnm            Build GNM into shared library],,)
+
+if test "$with_gnm" = "no" ; then
+  GNM_ENABLED=no
+  AC_MSG_RESULT([disabled by user])
+else
+  GNM_ENABLED=yes
+  AC_MSG_RESULT([enabled])
+fi
+AC_SUBST(GNM_ENABLED,$GNM_ENABLED)
+
+dnl ---------------------------------------------------------------------------
+dnl Select an MySQL Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+MYSQL_CONFIG=no
+
+AC_ARG_WITH(mysql,[  --with-mysql[=ARG]      Include MySQL (ARG=path to mysql_config) [[default=no]]],,)
+
+if test "$with_mysql" = "yes" ; then
+  AC_PATH_PROG(MYSQL_CONFIG, mysql_config, no)
+else
+    if test "x$with_mysql" != "x" ; then
+      MYSQL_CONFIG=$with_mysql
+    fi
+fi
+
+AC_MSG_CHECKING([for MySQL])
+
+if test "$MYSQL_CONFIG" = "no" ; then
+
+  HAVE_MYSQL=no
+  MYSQL_LIB=
+  MYSQL_INC=
+
+  AC_MSG_RESULT([no])
+
+else
+  if test -d $MYSQL_CONFIG ; then
+      AC_MSG_RESULT([no])
+      AC_MSG_ERROR([--with-mysql argument is a directory.  It should be the path to the mysql_config script, often somewhere like /usr/local/bin/mysql_config.])
+  fi
+
+  if test \! -x $MYSQL_CONFIG ; then
+      AC_MSG_RESULT([no])
+      AC_MSG_ERROR([--with-mysql argument is a not an executable file.  It should be the path to the mysql_config script, often somewhere like /usr/local/bin/mysql_config.])
+  fi
+
+  MYSQL_VERSION="`$MYSQL_CONFIG --version`"
+  MYSQL_MAJOR_VERSION=${MYSQL_VERSION%%'.'*}
+
+  if test $MYSQL_MAJOR_VERSION -le 3 ; then
+    HAVE_MYSQL=no
+    AC_MSG_RESULT([no, mysql is pre-4.x])
+  else
+      HAVE_MYSQL=yes
+      MYSQL_LIB="`$MYSQL_CONFIG --libs`"
+      STRIP_SYSTEM_LIBRARY_PATHS("${MYSQL_LIB}")
+      MYSQL_LIB="$STRIPPED_LIBRARY_NAME"
+      MYSQL_INC="`$MYSQL_CONFIG --include`"
+      AC_MSG_RESULT([yes])
+  fi
+fi
+
+AC_SUBST(HAVE_MYSQL,$HAVE_MYSQL)
+AC_SUBST(MYSQL_INC,$MYSQL_INC)
+AC_SUBST(MYSQL_LIB,$MYSQL_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for Xerces C++ Parser support.
+dnl ---------------------------------------------------------------------------
+
+XERCES_REQ_VERSION="3.1.0"
+AX_LIB_XERCES($XERCES_REQ_VERSION)
+
+if test "$HAVE_XERCES" = "yes"; then
+    LIBS="$XERCES_LDFLAGS $LIBS"
+
+m4_foreach_w([frmt],XERCES_DRIVERS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+    OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+  fi
+])
+
+fi
+
+AC_SUBST([HAVE_XERCES], $HAVE_XERCES)
+AC_SUBST([XERCES_INCLUDE], $XERCES_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for Expat configuration.
+dnl ---------------------------------------------------------------------------
+
+dnl Expat 1.95.0 released in 2000-09-28
+EXPAT_REQ_VERSION="1.95.0"
+AX_LIB_EXPAT($EXPAT_REQ_VERSION)
+
+if test "$HAVE_EXPAT" = "yes"; then
+    LIBS="$EXPAT_LDFLAGS $LIBS"
+
+m4_foreach_w([frmt],EXPAT_DRIVERS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+    OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+  fi
+])
+
+fi
+
+AC_SUBST([HAVE_EXPAT], $HAVE_EXPAT)
+AC_SUBST([EXPAT_INCLUDE], $EXPAT_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for Google libkml support.
+dnl ---------------------------------------------------------------------------
+
+LIBKML_REQ_VERSION="1.3.0"
+AX_LIB_LIBKML($LIBKML_REQ_VERSION)
+
+if test "$HAVE_LIBKML" = "yes"; then
+    LIBS="$LIBKML_LDFLAGS $LIBS"
+fi
+
+AC_SUBST([HAVE_LIBKML], $HAVE_LIBKML)
+AC_SUBST([LIBKML_INCLUDE], $LIBKML_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for ODBC support.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(odbc,[  --with-odbc[=ARG]       Include ODBC support (ARG=no or path)],,)
+
+if test "$with_odbc" = "no" ; then
+
+  ODBC_SETTING=no
+
+  echo "ODBC support disabled."
+
+elif test "$with_odbc" = "yes" -o "$with_odbc" = "" ; then
+  ODBC_SETTING=no
+
+  echo "check for unixODBC"
+  AC_CHECK_LIB(odbc,SQLConnect,[ODBC_LIBS="-lodbc -lodbcinst"])
+  AC_CHECK_LIB(odbcinst,SQLInstallDriverEx,ODBC_SETTING=yes)
+
+  if test "$ODBC_SETTING" = "no" ; then
+    echo "check for windows ODBC"
+    AC_CHECK_LIB(odbc32,main,[ODBC_LIBS="-lodbc32 -lodbccp32"])
+    AC_CHECK_LIB(odbccp32,SQLInstallDriverEx,ODBC_SETTING=yes)
+  fi
+
+  if test "$ODBC_SETTING" = "yes" ; then
+    AC_CHECK_HEADERS(sql.h,,[ODBC_SETTING=no],
+[#ifdef _WIN32
+# include <windows.h>
+#endif
+])
+    if test "$ODBC_SETTING" = "no" ; then
+      if test -f /usr/local/include/sql.h ; then
+        ODBC_SETTING=yes
+        echo "using sql.h from /usr/local/include"
+      elif test -f /usr/include/sql.h ; then
+        ODBC_SETTING=yes
+        echo "using sql.h from /usr/include"
+      else
+        echo "sql.h not found"
+      fi
+    fi
+  fi
+
+  if test "$ODBC_SETTING" = "yes"  ; then
+    LIBS="$ODBC_LIBS $LIBS"
+  fi
+
+else
+
+  ODBC_SETTING=yes
+  ODBC_LIBS=""
+  AC_CHECK_LIB(odbc,SQLConnect,ODBC_LIBS="-lodbc -lodbcinst")
+  AC_CHECK_LIB(odbc32,main,ODBC_LIBS="-lodbc32 -lodbccp32")
+  if test "$ODBC_LIBS" = ""; then
+    AC_MSG_ERROR([Cannot find ODBC libs])
+  fi
+  LIBS="-L$with_odbc -L$with_odbc/lib $ODBC_LIBS $LIBS"
+  EXTRA_INCLUDES="-I$with_odbc -I$with_odbc/include $EXTRA_INCLUDES"
+
+  echo "using odbc library from $with_odbc."
+fi
+
+if test "$ODBC_SETTING" = "yes"  ; then
+m4_foreach_w([frmt],ODBC_DRIVERS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+    OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+  fi
+])
+fi
+
+AC_SUBST(ODBC_SETTING,$ODBC_SETTING)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for SAP HANA support.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(hana, AS_HELP_STRING([--with-hana[=ARG]] Include SAP HANA (ARG=no(default), yes or path to odbc-cpp-wrapper)),,)
+
+AC_MSG_CHECKING([for SAP HANA])
+
+if test "x$with_hana" = "xno" -o "x$with_hana" = "x" ; then
+  HAVE_HANA=no
+  ODBCCPP_LIB=
+  ODBCCPP_INC=
+  AC_MSG_RESULT([no])
+else
+  if test "$ODBC_SETTING" = "no" ; then
+      AC_MSG_ERROR([SAP HANA driver requires odbc driver to be installed.])
+  fi
+
+  if test "$with_hana" = "yes" ; then
+      ODBCCPP_PATH=/usr/local
+  else
+      ODBCCPP_PATH=$with_hana
+  fi
+
+  if test -d ${ODBCCPP_PATH} ; then
+     AC_LANG_PUSH(C++)
+     LIBS="-lodbccpp $LIBS"
+     AC_CHECK_HEADER(odbc/PreparedStatement.h)
+     AC_LINK_IFELSE(
+       [AC_LANG_PROGRAM(
+           [#include <odbc/Environment.h>],
+           [
+              odbc::EnvironmentRef env = odbc::Environment::create();
+           ]
+         )],
+       [HAVE_HANA="yes"],
+       [AC_MSG_WARN([Cannot find odbccpp.])])
+     AC_LANG_POP(C++)
+
+     if test "${HAVE_HANA}" = "yes" ; then
+         ODBCCPP_LIB=-L"$ODBCCPP_PATH/lib"
+         ODBCCPP_INC=-I"$ODBCCPP_PATH/include"
+         AC_MSG_RESULT([yes])
+     else
+         AC_MSG_ERROR([--with-hana argument points to a directory which does not contain the odbc-cpp-wrapper library.])
+     fi
+  else
+      AC_MSG_RESULT([no])
+      AC_MSG_ERROR([--with-hana argument is not a directory. It should be the path to the odbc-cpp-wrapper library, often somewhere like /usr/local.])
+  fi
+fi
+
+AC_SUBST(HAVE_HANA,$HAVE_HANA)
+AC_SUBST(ODBCCPP_INC,$ODBCCPP_INC)
+AC_SUBST(ODBCCPP_LIB,$ODBCCPP_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for OCI support.
+dnl ---------------------------------------------------------------------------
+
+ORACLE_OCI_REQ_VERSION="8.1.7"
+AX_LIB_ORACLE_OCI($ORACLE_OCI_REQ_VERSION)
+
+if test "$HAVE_ORACLE_OCI" = "yes"; then
+    OCI_INCLUDE="$ORACLE_OCI_CFLAGS"
+    LIBS="$ORACLE_OCI_LDFLAGS $LIBS"
+fi
+
+AC_SUBST([HAVE_OCI], [$HAVE_ORACLE_OCI])
+AC_SUBST([OCI_INCLUDE], $[OCI_INCLUDE])
+
+dnl ---------------------------------------------------------------------------
+dnl Check for libxml2.
+dnl ---------------------------------------------------------------------------
+
+HAVE_LIBXML2=no
+LIBXML2_INC=
+LIBXML2_LIB=
+
+AC_ARG_WITH(xml2,
+    [  --with-xml2[=ARG]       Include libxml2 (ARG=yes/no)],,,)
+
+if test "x$with_xml2" = "xyes" -o "x$with_xml2" = "x" ; then
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES(LIBXML2,[libxml-2.0], [HAVE_LIBXML2=yes], [HAVE_LIBXML2=no])
+
+  if test "${HAVE_LIBXML2}" = "yes"; then
+    SAVED_LIBS="${LIBS}"
+    LIBS="${LIBXML2_LIBS}"
+    AC_CHECK_LIB(xml2,xmlParseDoc,HAVE_LIBXML2=yes,HAVE_LIBXML2=no)
+    LIBS="${SAVED_LIBS}"
+  fi
+
+  if test "${HAVE_LIBXML2}" = "yes"; then
+    LIBXML2_INC="${LIBXML2_CFLAGS}"
+    LIBXML2_LIB="${LIBXML2_LIBS}"
+  else
+    if test "x$with_xml2" = "xyes"; then
+      AC_MSG_ERROR([--with-xml2 was requested, but libxml2 is not available])
+    fi
+  fi
+elif test "x$with_xml2" != "xno"; then
+  AC_MSG_ERROR([Only --with-xml2=yes/no supported])
+fi
+
+AC_SUBST(HAVE_LIBXML2,$HAVE_LIBXML2)
+AC_SUBST(LIBXML2_INC, $LIBXML2_INC)
+AC_SUBST(LIBXML2_LIB, $LIBXML2_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for librasterlite2.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rasterlite2,
+    [  --with-rasterlite2=ARG Include RasterLite2 support (ARG=no(default), yes or path)],
+    ,,)
+
+HAVE_RASTERLITE2=no
+RASTERLITE2_CFLAGS=
+
+if test -z "$with_rasterlite2" -o "$with_rasterlite2" = "no"; then
+    AC_MSG_NOTICE([rasterlite2 support disabled])
+elif test "$with_rasterlite2" = "yes"; then
+    AC_CHECK_HEADERS(rasterlite2/rasterlite2.h)
+    if test "$ac_cv_header_rasterlite2_rasterlite2_h" = "yes"; then
+        AC_CHECK_LIB(rasterlite2,rl2_load_raw_tiles_into_dbms,HAVE_RASTERLITE2=yes,HAVE_RASTERLITE2=no,)
+        if test "$HAVE_RASTERLITE2" = "yes"; then
+            LIBS="$LIBS -lrasterlite2 -lsqlite3"
+        else
+            AC_MSG_ERROR([did not find rl2_load_raw_tiles_into_dbms])
+        fi
+    else
+        AC_MSG_ERROR([did not find rasterlite2.h])
+    fi
+else
+    AC_MSG_CHECKING([for include/rasterlite2/rasterlite2.h])
+    if test -f "$with_rasterlite2/include/rasterlite2/rasterlite2.h"; then
+        AC_MSG_RESULT([found])
+        AC_CHECK_LIB(rasterlite2,rl2_load_raw_tiles_into_dbms,HAVE_RASTERLITE2=yes,HAVE_RASTERLITE2=no,-L$with_rasterlite2/lib)
+        if test "$HAVE_RASTERLITE2" = "yes"; then
+            RASTERLITE2_CFLAGS="-I$with_rasterlite2/include"
+            LIBS="$LIBS -L$with_rasterlite2/lib -lrasterlite2 -lsqlite3"
+        else
+            AC_MSG_ERROR([did not find rl2_load_raw_tiles_into_dbms])
+        fi
+    else
+        AC_MSG_ERROR([did not find rasterlite2.h])
+    fi
+fi
+
+AC_SUBST([HAVE_RASTERLITE2], $HAVE_RASTERLITE2)
+AC_SUBST([RASTERLITE2_CFLAGS], $RASTERLITE2_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for PCRE2.
+dnl ---------------------------------------------------------------------------
+
+HAVE_PCRE2=no
+
+AC_ARG_WITH(pcre2,
+    [  --with-pcre2             Include libpcre2 support (REGEXP support for SQLite)],
+    ,,)
+
+if test "$with_pcre2" = "no"; then
+    AC_MSG_RESULT(disabled)
+    HAVE_PCRE2=no
+else
+    save_CPPFLAGS="$CPPFLAGS"
+    CPPFLAGS="$CPPFLAGS -DPCRE2_CODE_UNIT_WIDTH=8"
+    AC_CHECK_HEADERS([pcre2.h])
+    CPPFLAGS="$save_CPPFLAGS"
+    if test "$ac_cv_header_pcre2_h" = "no" ; then
+        if test "$with_pcre2" = "yes"; then
+            AC_MSG_ERROR([cannot find pcre2.h])
+        fi
+    else
+        AC_CHECK_LIB(pcre2-8,pcre2_compile_8,HAVE_PCRE2=yes,HAVE_PCRE2=no,)
+        if test "$HAVE_PCRE2" = "yes" ; then
+            HAVE_PCRE2=yes
+            LIBS="$LIBS -lpcre2-8"
+        else
+            if test "$with_pcre2" = "yes"; then
+                AC_MSG_ERROR([cannot find libpcre2])
+            fi
+        fi
+    fi
+fi
+
+AC_SUBST(HAVE_PCRE2)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for PCRE.
+dnl ---------------------------------------------------------------------------
+
+HAVE_PCRE=no
+
+AC_ARG_WITH(pcre,
+    [  --with-pcre             Include libpcre support (REGEXP support for SQLite)],
+    ,,)
+
+if test "$with_pcre" = "no"; then
+    AC_MSG_RESULT(disabled)
+    HAVE_PCRE=no
+elif test "$HAVE_PCRE2" = "no"; then
+    AC_CHECK_HEADERS([pcre.h])
+    if test "$ac_cv_header_pcre_h" = "no" ; then
+        if test "$with_pcre" = "yes"; then
+            AC_MSG_ERROR([cannot find pcre.h])
+        fi
+    else
+        AC_CHECK_LIB(pcre,pcre_compile,HAVE_PCRE=yes,HAVE_PCRE=no,)
+        if test "$HAVE_PCRE" = "yes" ; then
+            HAVE_PCRE=yes
+            LIBS="$LIBS -lpcre"
+        else
+            if test "$with_pcre" = "yes"; then
+                AC_MSG_ERROR([cannot find libpcre])
+            fi
+        fi
+    fi
+fi
+
+AC_SUBST(HAVE_PCRE)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for Teigha.
+dnl ---------------------------------------------------------------------------
+
+TEIGHA_DIR=
+TEIGHA_CPPFLAGS=
+
+AC_MSG_CHECKING(Checking for Teigha)
+AC_ARG_WITH(teigha,
+    [  --with-teigha[=path] Include Teigha DWG/DGN support],
+    ,,)
+
+if test -z "$with_teigha" -o "$with_teigha" = "no"; then
+    AC_MSG_RESULT(disabled)
+    HAVE_TEIGHA=no
+else
+    AC_MSG_RESULT(enabled)
+
+    AC_ARG_WITH(teigha-plt,
+      [  --with-teigha-plt[=platform] Teigha platform],
+      ,,)
+    if test "x$with_teigha_plt" != "x" ; then
+        TEIGHA_DIR=$with_teigha
+        HAVE_TEIGHA=yes
+        TEIGHA_PLT=$with_teigha_plt
+        LIBS="${LIBS} ${TEIGHA_DIR}/bin/${TEIGHA_PLT}/TG_Db.tx"
+        if test -f "${TEIGHA_DIR}/bin/${TEIGHA_PLT}/TD_DbEntities.tx"; then
+            LIBS="${LIBS} ${TEIGHA_DIR}/bin/${TEIGHA_PLT}/TD_DbEntities.tx"
+            LIBS="${LIBS} ${TEIGHA_DIR}/lib/${TEIGHA_PLT}/libTD_DrawingsExamplesCommon.a"
+        fi
+        LIBS="${LIBS} ${TEIGHA_DIR}/lib/${TEIGHA_PLT}/libTG_ExamplesCommon.a"
+        LIBS="${LIBS} ${TEIGHA_DIR}/lib/${TEIGHA_PLT}/libTD_ExamplesCommon.a"
+        LIBS="${LIBS} ${TEIGHA_DIR}/lib/${TEIGHA_PLT}/libTD_Key.a"
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_Db"
+        if test -f "${TEIGHA_DIR}/bin/${TEIGHA_PLT}/libTD_DbCore.*"; then
+            LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_DbCore"
+        fi
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_DbRoot"
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_Gi"
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_SpatialIndex"
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_Root"
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_Ge"
+        if test -f "${TEIGHA_DIR}/bin/${TEIGHA_PLT}/libTD_Zlib.*"; then
+            LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_Zlib"
+        fi
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_Alloc"
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -loless"
+        if test -f "${TEIGHA_DIR}/bin/${TEIGHA_PLT}/liblibcrypto.*"; then
+            LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -llibcrypto"
+        fi
+        if test -f "${TEIGHA_DIR}/bin/${TEIGHA_PLT}/libTD_Db.so"; then
+            TEIGHA_CPPFLAGS="-D_TOOLKIT_IN_DLL_"
+        fi
+    else
+        AC_MSG_ERROR([--with-teigha-plt not specified])
+    fi
+fi
+
+AC_SUBST(TEIGHA_DIR)
+AC_SUBST(HAVE_TEIGHA)
+AC_SUBST(TEIGHA_CPPFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Select Informix DataBlade support
+dnl ---------------------------------------------------------------------------
+
+HAVE_IDB=no
+
+AC_ARG_WITH(idb,[  --with-idb=DIR        Include Informix DataBlade support (DIR points to Informix root)],,)
+
+if test x"${with_idb}" = x"no" ; then
+  AC_MSG_NOTICE(["IBM Informix DataBlade support disabled."])
+else
+  if test x"${with_idb}" = x ; then
+    with_idb=$INFORMIXDIR
+  fi
+
+  if test -e "${with_idb}/incl/c++/it.h" ; then
+
+    LIBS_DIRS="-L${with_idb}/lib/ -L${with_idb}/lib/esql"
+    LIBS_ESQL="-lifsql -lifasf -lifgen -lifos -lifgls -lifglx ${with_idb}/lib/esql/checkapi.o"
+    LIBS_LIBMI="-L${with_idb}/lib/dmi -lifdmi"
+    LIBS_CPPIF="-L${with_idb}/lib/c++ -lifc++"
+
+    IDB_INC="-I${with_idb}/incl/ -I${with_idb}/incl/dmi -I${with_idb}/incl/c++"
+    IDB_LIB="${LIBS_CPPIF} ${LIBS_LIBMI} ${LIBS_DIRS} ${LIBS_ESQL}"
+
+    ax_save_LIBS="${LIBS}"
+    LIBS="${IDB_LIB} -ldl -lcrypt"
+    AC_CHECK_LIB(ifsql,ifx_srvinfo,HAVE_IDB=yes,HAVE_IDB=no,)
+    LIBS="${ax_save_LIBS}"
+
+  fi
+
+  if test "${HAVE_IDB}" = "yes" ; then
+    AC_MSG_NOTICE([using Informix C++ client library from $with_idb.])
+  else
+    AC_MSG_NOTICE([IBM Informix DataBlade not supported.])
+  fi
+
+fi
+
+AC_SUBST(HAVE_IDB,${HAVE_IDB})
+AC_SUBST(IDB_INC,${IDB_INC})
+AC_SUBST(IDB_LIB,${IDB_LIB})
+
+dnl ---------------------------------------------------------------------------
+dnl Check if webp library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(webp,[  --with-webp[=ARG]    Include WEBP support (ARG=no, yes or libwebp install root path)],,)
+
+WEBP_SETTING=no
+
+if test "$with_webp" = "yes" -o "$with_webp" = "" ; then
+
+  AC_CHECK_LIB(webp,WebPDecodeRGB,WEBP_SETTING=yes,WEBP_SETTING=no,)
+
+  if test "$WEBP_SETTING" = "yes" ; then
+    LIBS="-lwebp $LIBS"
+  else
+    echo "libwebp not found - WEBP support disabled"
+  fi
+
+elif test "$with_webp" != "no" -a "$with_webp" != ""; then
+
+  AC_CHECK_LIB(webp,WebPDecodeRGB,WEBP_SETTING=yes,WEBP_SETTING=no,-L$with_webp/lib -lwebp)
+
+  if test "$WEBP_SETTING" = "yes" ; then
+    LIBS="-L$with_webp/lib -lwebp $LIBS"
+    EXTRA_INCLUDES="-I$with_webp/include $EXTRA_INCLUDES"
+  else
+    echo "libwebp not found - WEBP support disabled"
+  fi
+
+fi
+
+AC_SUBST(WEBP_SETTING,$WEBP_SETTING)
+
+if test "$WEBP_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="webp $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if geos library is available.
+dnl ---------------------------------------------------------------------------
+
+GEOS_INIT(3.1.0)
+if test "${HAVE_GEOS}" = "yes" ; then
+  AC_MSG_NOTICE([Using C API from GEOS $GEOS_VERSION])
+  STRIP_SYSTEM_LIBRARY_PATHS("${GEOS_LIBS}")
+  GEOS_LIBS="$STRIPPED_LIBRARY_NAME"
+  LIBS="${GEOS_LIBS} ${LIBS}"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if SFCGAL library is available.
+dnl ---------------------------------------------------------------------------
+
+SFCGAL_INIT(1.2.2)
+if test "${HAVE_SFCGAL}" = "yes" ; then
+  AC_MSG_NOTICE([Using C API from SFCGAL $SFCGAL_VERSION])
+  STRIP_SYSTEM_LIBRARY_PATHS("${SFCGAL_LIBS}")
+  SFCGAL_LIBS="$STRIPPED_LIBRARY_NAME"
+  LIBS="${SFCGAL_LIBS} ${LIBS}"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if QHull library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(qhull,[  --with-qhull[=ARG]     Include QHull support (ARG=no, yes, internal)],,)
+
+QHULL_SETTING=no
+
+if test "$with_qhull" = "no" ; then
+
+  AC_MSG_NOTICE([QHull support disabled.])
+
+elif test "$with_qhull" = "yes" -o "$with_qhull" = "" ; then
+
+  AC_ARG_WITH(qhull_pkgname,[  --with-qhull-pkgname[=ARG]     pkg-config name of the reentrant qhull library, typically qhull_r (default) or qhullstatic_r],,)
+
+  if test "x$with_qhull_pkgname" = "x" ; then
+    with_qhull_pkgname=qhull_r
+  fi
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([QHULL],[$with_qhull_pkgname], [HAVE_QHULL=yes], [HAVE_QHULL=no])
+
+  dnl First try with pkg-config
+  if test "$HAVE_QHULL" = "yes" ; then
+    QHULL_SETTING=external
+    CFLAGS="$CFLAGS $QHULL_CFLAGS"
+    LIBS="$LIBS $QHULL_LIBS"
+  else
+    AC_CHECK_HEADERS([libqhull_r/libqhull_r.h])
+    if test "$ac_cv_header_libqhull_r_libqhull_r_h" = "yes"; then
+      AC_CHECK_LIB(qhull_r,qh_new_qhull,QHULL_SETTING=yes,QHULL_SETTING=no,)
+      if test "$QHULL_SETTING" = "yes"; then
+        QHULL_SETTING=external
+        LIBS="-lqhull_r $LIBS"
+      fi
+    fi
+
+    if test "$QHULL_SETTING" = "no" ; then
+      if test "$with_qhull" = "yes"; then
+        AC_MSG_ERROR([--with-qhull requested, but library not found!])
+      else
+        QHULL_SETTING=internal
+      fi
+    fi
+  fi
+else
+  QHULL_SETTING=internal
+fi
+
+AC_SUBST([QHULL_SETTING],$QHULL_SETTING)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if opencl library is available.
+dnl ---------------------------------------------------------------------------
+
+OPENCL_SETTING=no
+OPENCL_FLAGS=
+OPENCL_LIB=
+
+AC_ARG_WITH(opencl,
+    [  --with-opencl[=ARG]       Include OpenCL (GPU) support],,,)
+
+AC_MSG_CHECKING([for OpenCL support])
+
+if test "$with_opencl" = "yes" ; then
+
+  AC_ARG_WITH(opencl-include,
+      [  --with-opencl-include=ARG OpenCL Include directory (with a CL subdirectory)],,,)
+
+  OPENCL_SETTING=yes
+
+  if test "x$with_opencl_include" = "x" ; then
+    OPENCL_FLAGS=-DHAVE_OPENCL
+    if test -z "`uname | grep Darwin`" ; then
+        AC_CHECK_HEADERS([CL/opencl.h])
+        if test "$ac_cv_header_CL_opencl_h" = "no" ; then
+            AC_MSG_ERROR([cannot find CL/opencl.h])
+        fi
+    fi
+  else
+    OPENCL_FLAGS="-I$with_opencl_include -DHAVE_OPENCL"
+  fi
+
+  AC_ARG_WITH(opencl-lib,
+      [  --with-opencl-lib=ARG   OpenCL Link Flags (i.e. -L/xxx -lOpenCL)],,,)
+
+  if test "x$with_opencl_lib" = "x" ; then
+    if test ! -z "`uname | grep Darwin`" ; then
+      OPENCL_LIB="-framework OpenCL"
+    else
+      AC_CHECK_LIB(OpenCL,clGetPlatformIDs,OPENCL_LIB=-lOpenCL,OPENCL_LIB=missing)
+      if test "$OPENCL_LIB" = "missing"; then
+        AC_MSG_ERROR([--with-opencl requested, but libraries not found!])
+      fi
+    fi
+  else
+    OPENCL_LIB="$with_opencl_lib"
+  fi
+
+fi
+
+AC_MSG_RESULT([$OPENCL_SETTING])
+
+AC_SUBST(OPENCL_FLAGS,  $OPENCL_FLAGS)
+AC_SUBST(OPENCL_LIB,    $OPENCL_LIB)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if FreeXL library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(freexl,[  --with-freexl[=ARG]    Include freexl support (ARG=no, yes (default) or libfreexl install path)],,)
+
+AC_MSG_CHECKING([for FreeXL support])
+
+HAVE_FREEXL=no
+FREEXL_INCLUDE=
+
+if test "$with_freexl" = "" -o "$with_freexl" = "yes" ; then
+  AC_CHECK_HEADERS(freexl.h)
+  AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-lfreexl",FREEXL_LIBS=missing)
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-lfreexl -lm",FREEXL_LIBS=missing,-lm)
+  fi
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-lfreexl -liconv",FREEXL_LIBS=missing,-liconv)
+  fi
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-lfreexl -liconv -lm",FREEXL_LIBS=missing,-liconv -lm)
+  fi
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-lfreexl -liconv -lcharset",FREEXL_LIBS=missing,-liconv -lcharset)
+  fi
+
+  if test "$FREEXL_LIBS" != "missing" -a "$ac_cv_header_freexl_h" = "yes" ; then
+
+    # Check that freexl is recent enough
+    rm -f testrlist.*
+    echo '#include <freexl.h>' > testfreexl.c
+    echo 'int main(int argc, char** argv) { FreeXL_CellValue s; freexl_get_cell_value (0,0,0,&s); return 0; } ' >> testfreexl.c
+    if test -z "`${CC} ${CFLAGS} testfreexl.c -c 2>&1`" ; then
+        HAVE_FREEXL=yes
+        LIBS="$FREEXL_LIBS $LIBS"
+    else
+        HAVE_FREEXL=no
+        AC_MSG_RESULT([freexl too old. Needs freexl >= 1.0])
+    fi
+    rm -f testfreexl.*
+
+  else
+    HAVE_FREEXL=no
+    echo "libfreexl not found - FreeXL support disabled"
+  fi
+
+elif test "$with_freexl" != "no"; then
+
+  AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-L$with_freexl/lib -lfreexl",FREEXL_LIBS=missing,-L$with_freexl/lib)
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-L$with_freexl/lib -lfreexl -lm",FREEXL_LIBS=missing,-L$with_freexl/lib -lm)
+  fi
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-L$with_freexl/lib -lfreexl -liconv",FREEXL_LIBS=missing,-L$with_freexl/lib -liconv)
+  fi
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-L$with_freexl/lib -lfreexl -liconv -lm",FREEXL_LIBS=missing,-L$with_freexl/lib -liconv -lm)
+  fi
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-L$with_freexl/lib -lfreexl -liconv -lcharset",FREEXL_LIBS=missing,-L$with_freexl/lib -liconv -lcharset)
+  fi
+
+  if test "$FREEXL_LIBS" != "missing" -a -f "$with_freexl/include/freexl.h" ; then
+
+    # Check that freexl is recent enough
+    rm -f testrlist.*
+    echo '#include <freexl.h>' > testfreexl.c
+    echo 'int main(int argc, char** argv) { FreeXL_CellValue s; freexl_get_cell_value (0,0,0,&s); return 0; } ' >> testfreexl.c
+    if test -z "`${CC} ${CFLAGS} -I$with_freexl/include testfreexl.c -c 2>&1`" ; then
+        HAVE_FREEXL=yes
+        LIBS="$FREEXL_LIBS $LIBS"
+        FREEXL_INCLUDE="-I$with_freexl/include"
+    else
+        HAVE_FREEXL=no
+        AC_MSG_RESULT([freexl too old. Needs freexl >= 1.0])
+    fi
+    rm -f testfreexl.*
+
+  else
+    HAVE_FREEXL=no
+    echo "libfreexl not found - FreeXL support disabled"
+  fi
+
+fi
+
+AC_SUBST(HAVE_FREEXL,  $HAVE_FREEXL)
+AC_SUBST(FREEXL_INCLUDE,  $FREEXL_INCLUDE)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if libjson-c is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(libjson-c,[  --with-libjson-c[=ARG]       Include libjson-c support (ARG=internal or libjson-c directory)],,)
+
+if test "$with_libjson_c" = "external" -o "$with_libjson_c" = "" -o "$with_libjson_c" = "yes" ; then
+  AC_CHECK_LIB(json-c,json_object_set_serializer,LIBJSONC_SETTING=external,LIBJSONC_SETTING=internal,)
+elif test "$with_libjson_c" = "internal" ; then
+  LIBJSONC_SETTING=internal
+elif test "$with_libjson_c" != "no"; then
+  LIBS="-L$with_libjson_c/lib $LIBS"
+  AC_CHECK_LIB(json-c,json_object_set_serializer,LIBJSONC_SETTING=external,LIBJSONC_SETTING=internal,-L$with_libjson_c/lib)
+else
+  AC_MSG_ERROR([libjson-c (internal or external) is required])
+fi
+
+if test "$LIBJSONC_SETTING" = "external" ; then
+  AC_MSG_RESULT([using pre-installed libjson-c])
+  LIBS="-ljson-c $LIBS"
+  if test "$with_libjson_c" != "" -a "$with_libjson_c" != "yes" -a "$with_libjson_c" != "external" ; then
+    JSON_INCLUDE="-I$with_libjson_c/include/json-c"
+  elif test -f "/usr/include/json-c/json.h"; then
+    JSON_INCLUDE="-I/usr/include/json-c"
+  elif test -f "/usr/local/include/json-c/json.h"; then
+    JSON_INCLUDE="-I/usr/local/include/json-c"
+  else
+    AC_MSG_ERROR([could not find json-c/json.h])
+  fi
+else
+    JSON_INCLUDE="-I\$(GDAL_ROOT)/ogr/ogrsf_frmts/geojson/libjson"
+    AC_MSG_RESULT([using internal libjson-c code])
+fi
+
+AC_SUBST(LIBJSONC_SETTING,$LIBJSONC_SETTING)
+AC_SUBST(JSON_INCLUDE,$JSON_INCLUDE)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if we must enable PAM
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([whether to enable PAM])
+
+AC_ARG_WITH(pam,[  --without-pam         Disable PAM (.aux.xml) support],,)
+
+export PAM_SETTING=
+
+if test "x$with_pam" = "xno" ; then
+  AC_MSG_RESULT([no])
+else
+  AC_MSG_RESULT([yes])
+  PAM_SETTING=-DPAM_ENABLED
+fi
+
+AC_SUBST(PAM_SETTING, $PAM_SETTING)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if the PDF driver should be built as a plugin
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([whether to build PDF driver as a plugin])
+
+AC_ARG_ENABLE(pdf_plugin,
+              AS_HELP_STRING([--enable-pdf-plugin],
+                             [enable PDF driver as a plugin (included in libgdal by default)]),,)
+
+PDF_PLUGIN=no
+if test "x$enable_pdf_plugin" = "xyes" ; then
+
+  if test "$with_libtool" = "yes"; then
+    AC_MSG_ERROR([--enable-pdf-plugin not supported together --with-libtool])
+  fi
+
+  PDF_PLUGIN=yes
+
+  AC_MSG_RESULT([yes])
+else
+  AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(PDF_PLUGIN, $PDF_PLUGIN)
+if test "$PDF_PLUGIN" != "yes" ; then
+  if test "x$INTERNAL_FORMAT_pdf_ENABLED" = "xyes"; then
+    if test "$LIBZ_SETTING" != "no" ; then
+      GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED pdf"
+    fi
+  fi
+fi
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if libpoppler is available
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(poppler,[  --with-poppler[=ARG]    Include poppler(for PDF) support (ARG=no(default), yes or poppler install path)],,)
+
+HAVE_POPPLER=no
+POPPLER_MAJOR_VERSION=
+POPPLER_MINOR_VERSION=
+
+AC_MSG_CHECKING([for poppler])
+
+if test "$with_poppler" != "no" -a "$with_poppler" != ""; then
+
+    PKG_PROG_PKG_CONFIG([0.21])
+    PKG_CHECK_MODULES([POPPLER], [poppler >= 0.23.0],
+            [POPPLER_VERSION=`$PKG_CONFIG --modversion poppler`], [POPPLER_VERSION=])
+    if test "$POPPLER_VERSION" != ""; then
+        HAVE_POPPLER=yes
+        POPPLER_MAJOR_VERSION=`echo $POPPLER_VERSION | cut -d'.' -f1`
+        POPPLER_MINOR_VERSION=`echo $POPPLER_VERSION | cut -d'.' -f2 | sed -e 's/^0//'`
+        POPPLER_CFLAGS=`echo $POPPLER_CFLAGS $POPPLER_CFLAGS | sed "s/include\/poppler/include/"`
+    fi
+else
+    AC_MSG_RESULT([disabled])
+fi
+
+if test "$HAVE_POPPLER" = "yes" -a "$PDF_PLUGIN" = "no"; then
+    LIBS="${POPPLER_LIBS} ${LIBS}"
+fi
+
+AC_SUBST(HAVE_POPPLER, $HAVE_POPPLER)
+AC_SUBST(POPPLER_MAJOR_VERSION, $POPPLER_MAJOR_VERSION)
+AC_SUBST(POPPLER_MINOR_VERSION, $POPPLER_MINOR_VERSION)
+AC_SUBST(POPPLER_CFLAGS, $POPPLER_CFLAGS)
+AC_SUBST(POPPLER_PLUGIN_LIB, $POPPLER_LIBS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if libpodofo is available
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(podofo,[  --with-podofo[=ARG]    Include podofo(for PDF) support (ARG=no(default), yes or podofo install path)],,)
+
+HAVE_PODOFO=no
+
+AC_MSG_CHECKING([for podofo])
+
+if test "$with_podofo" != "no" -a "$with_podofo" != ""; then
+
+    AC_ARG_WITH(podofo-lib,
+      [  --with-podofo-lib=ARG   podofo Link Flags (i.e. -L/xxx -lpodofo ...). Mainly for static libpodofo],,,)
+
+    if test "$with_podofo" = "yes" ; then
+        TEST_PODOFO_INC="-I/usr/include/podofo"
+        PODOFO_LIB="-lpodofo"
+    else
+        TEST_PODOFO_INC="-I$with_podofo/include -I$with_podofo/include/podofo"
+        PODOFO_LIB="-L$with_podofo/lib -lpodofo"
+    fi
+
+    if test "x$with_podofo_lib" = "x" ; then
+        rm -f testpodofo.*
+        echo '#include <podofo.h>' > testpodofo.cpp
+        echo 'int main(int argc, char** argv) { PoDoFo::PdfError::EnableDebug( 0 ); return 0; } ' >> testpodofo.cpp
+        ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testpodofo.cpp -o testpodofo ${TEST_PODOFO_INC} ${PODOFO_LIB} 2>/dev/null
+        RETVAL=$?
+        if test $RETVAL -eq 0; then
+            HAVE_PODOFO=yes
+            if test "$PDF_PLUGIN" = "no"; then
+                LIBS="${PODOFO_LIB} ${LIBS}"
+            fi
+            PODOFO_INC=$TEST_PODOFO_INC
+            PODOFO_PLUGIN_LIB="${PODOFO_LIB}"
+            AC_MSG_RESULT([yes])
+        fi
+        rm -f testpodofo.*
+        rm -f testpodofo
+    fi
+
+    if test "$HAVE_PODOFO" = "no"; then
+        if test "x$with_podofo_lib" != "x" ; then
+            PODOFO_LIB="$with_podofo_lib"
+        else
+            # This may be a static libpodofo.a, so add dependent libraries.
+            PODOFO_LIB="$PODOFO_LIB -lfreetype -lfontconfig -lpthread"
+        fi
+
+        AC_ARG_WITH(podofo-extra-lib-for-test,
+          [  --with-podofo-extra-lib-for-test=ARG   Additional libraries to pass the detection test, but not used for libgdal linking (i.e. -ljpeg ...). Mainly for static libpodofo],,,)
+
+        if test "x$with_podofo_extra_lib_for_test" = "x" ; then
+            TEST_PODOFO_LIB="$PODOFO_LIB"
+        else
+            TEST_PODOFO_LIB="$PODOFO_LIB $with_podofo_extra_lib_for_test"
+        fi
+
+        rm -f testpodofo.*
+        echo '#include <podofo.h>' > testpodofo.cpp
+        echo 'int main(int argc, char** argv) { PoDoFo::PdfError::EnableDebug( 0 ); return 0; } ' >> testpodofo.cpp
+        ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testpodofo.cpp -o testpodofo ${TEST_PODOFO_INC} ${TEST_PODOFO_LIB} 2>/dev/null
+        RETVAL=$?
+        if test $RETVAL -eq 0; then
+            HAVE_PODOFO=yes
+            if test "$PDF_PLUGIN" = "no"; then
+                LIBS="${PODOFO_LIB} ${LIBS}"
+            fi
+            PODOFO_INC=$TEST_PODOFO_INC
+            PODOFO_PLUGIN_LIB="${PODOFO_LIB}"
+            AC_MSG_RESULT([yes])
+        else
+            AC_MSG_RESULT([no])
+        fi
+        rm -f testpodofo.*
+        rm -f testpodofo
+    fi
+else
+    AC_MSG_RESULT([disabled])
+fi
+
+AC_SUBST(HAVE_PODOFO, $HAVE_PODOFO)
+AC_SUBST(PODOFO_INC, $PODOFO_INC)
+AC_SUBST(PODOFO_PLUGIN_LIB, $PODOFO_PLUGIN_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if libpdfium is available
+dnl
+dnl Support for open-source PDFium library
+dnl
+dnl Copyright (C) 2015 Klokan Technologies GmbH (http://www.klokantech.com/)
+dnl Author: Martin Mikita <martin.mikita@klokantech.com>, xmikit00 @ FIT VUT Brno
+dnl Copyright 2019 Even Rouault
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(pdfium,[  --with-pdfium[=ARG]    Include pdfium (for PDF) support (ARG=no(default), yes or pdfium install path)],,)
+
+HAVE_PDFIUM=no
+
+AC_MSG_CHECKING([for pdfium])
+
+if test "$with_pdfium" != "no" -a "$with_pdfium" != ""; then
+
+    if test "$with_pdfium" = "yes" ; then
+        PDFIUM_INC="-I/usr/include/pdfium"
+        PDFIUM_LIB="-lpdfium"
+    else
+        PDFIUM_INC="-I$with_pdfium/include/pdfium"
+        PDFIUM_LIB="-L$with_pdfium/lib -lpdfium"
+    fi
+
+    PDFIUM_LIB="$PDFIUM_LIB -lopenjp2 -ljpeg -lpng -lz -llcms2 -lpthread -lm -lstdc++"
+
+    if test ! -z "`uname | grep Darwin`" ; then
+        PDFIUM_LIB="-stdlib=libstdc++ $PDFIUM_LIB"
+    fi
+
+    rm -f testpdfium.*
+    echo '#include "public/fpdfview.h"' > testpdfium.cpp
+    echo '#include "core/fpdfapi/page/cpdf_page.h"' >> testpdfium.cpp
+    echo '#include "constants/transparency.h"' >> testpdfium.cpp # specific to pdfium_build_gdal_3_2
+    echo 'int main(int argc, char** argv) { FPDF_InitLibrary(); FPDF_DestroyLibrary(); return 0; } ' >> testpdfium.cpp
+    TEST_CXX_FLAGS=""
+    if test ! -z "`uname | grep Darwin`" ; then
+        TEST_CXX_FLAGS="$TEST_CXX_FLAGS -stdlib=libstdc++"
+    fi
+    if ${CXX} ${CXXFLAGS} ${CPPFLAGS} $TEST_CXX_FLAGS -std=c++14 testpdfium.cpp -o testpdfium ${PDFIUM_INC} ${PDFIUM_LIB} >/dev/null 2>/dev/null; then
+        HAVE_PDFIUM=yes
+        CXXFLAGS="$TEST_CXX_FLAGS $CXXFLAGS"
+        if test "$PDF_PLUGIN" = "no"; then
+            LIBS="${PDFIUM_LIB} ${LIBS}"
+        fi
+        PDFIUM_PLUGIN_LIB="${PDFIUM_LIB}"
+        AC_MSG_RESULT([yes])
+    fi
+    rm -f testpdfium.*
+    rm -f testpdfium
+
+    if test "$HAVE_PDFIUM" = "no" -a "$with_pdfium" != ""; then
+        AC_MSG_ERROR([pdfium requested but not found. Must come from https://github.com/rouault/pdfium_build_gdal_3_4])
+    fi
+else
+    AC_MSG_RESULT([disabled])
+fi
+
+AC_SUBST(HAVE_PDFIUM, $HAVE_PDFIUM)
+AC_SUBST(PDFIUM_INC, $PDFIUM_INC)
+AC_SUBST(PDFIUM_PLUGIN_LIB, $PDFIUM_PLUGIN_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Get/override version.
+dnl ---------------------------------------------------------------------------
+
+
+AC_ARG_WITH(gdal-ver,[  --with-gdal-ver=ARG   Override GDAL version ],,)
+GDAL_VERSION_MAJOR=`grep "#*define.GDAL_VERSION_MAJOR.*" gcore/gdal_version.h.in | awk '{print $4}'`
+GDAL_VERSION_MINOR=`grep "#*define.GDAL_VERSION_MINOR.*" gcore/gdal_version.h.in | awk '{print $4}'`
+GDAL_VERSION_REV=`grep "#*define.GDAL_VERSION_REV.*" gcore/gdal_version.h.in | awk '{print $4}'`
+
+AC_MSG_RESULT([checking GDAL version information from gdal_version.h.in: $GDAL_VERSION_MAJOR.$GDAL_VERSION_MINOR.$GDAL_VERSION_REV])
+
+AC_SUBST(GDAL_VERSION_MAJOR,    "$GDAL_VERSION_MAJOR")
+AC_SUBST(GDAL_VERSION_MINOR,    "$GDAL_VERSION_MINOR")
+AC_SUBST(GDAL_VERSION_REV,    "$GDAL_VERSION_REV")
+
+if test "x$with_gdal_ver" != "x"; then
+
+  GDAL_VER=$with_gdal_ver
+  AC_MSG_RESULT([  overridden GDAL version: $GDAL_VER])
+else
+
+  GDAL_VER=$GDAL_VERSION_MAJOR.$GDAL_VERSION_MINOR.$GDAL_VERSION_REV
+
+fi
+
+AC_SUBST(GDAL_VER, $GDAL_VER)
+echo $GDAL_VER > VERSION
+
+dnl ---------------------------------------------------------------------------
+dnl MacOS X Framework Build
+
+if test ! -z "`uname | grep Darwin`" ; then
+
+  CXXFLAGS="$ARCHFLAGS $CXXFLAGS"
+  CFLAGS="$ARCHFLAGS $CFLAGS"
+  LIBS="$ARCHFLAGS $LIBS"
+
+  MACOSX_FRAMEWORK=no
+  AC_ARG_WITH(macosx-framework,[  --with-macosx-framework         Build and install GDAL as a Mac OS X Framework],,)
+  AC_MSG_CHECKING([for Mac OS X Framework build])
+  if test "$with_macosx_framework" = yes ; then
+    MACOSX_FRAMEWORK=yes
+    AC_MSG_RESULT([enabled])
+    AC_DEFINE_UNQUOTED(MACOSX_FRAMEWORK,1, [Define for Mac OSX Framework build])
+    prefix="/Library/Frameworks/GDAL.framework/Versions/${GDAL_VERSION_MAJOR}.${GDAL_VERSION_MINOR}"
+    exec_prefix='${prefix}'
+    includedir='${prefix}/Headers'
+    datadir='${prefix}/Resources/gdal'
+    libdir='${exec_prefix}'
+    bindir='${exec_prefix}/Programs'
+    docdir='${prefix}/Resources/doc'
+    mandir='${prefix}/Resources/man'
+  else
+    AC_MSG_RESULT([disabled])
+  fi
+  AC_SUBST(MACOSX_FRAMEWORK, $MACOSX_FRAMEWORK)
+fi
+
+AC_SUBST(EXTRA_INCLUDES,$EXTRA_INCLUDES)
+
+dnl ---------------------------------------------------------------------------
+dnl Check whether we need to add specific suffix for executables (.EXE when
+dnl building for Windows). This test should work for the case of
+dnl cross-compilation too.
+dnl ---------------------------------------------------------------------------
+case "${host_os}" in
+    cygwin* | mingw* | pw32*)
+      EXE_EXT=.exe
+      SO_EXT=dll
+      ;;
+    *)
+      EXE_EXT=
+      ;;
+esac
+
+AC_SUBST(EXE_EXT)
+AC_SUBST(SO_EXT)
+
+dnl ---------------------------------------------------------------------------
+dnl Which "true" program should we use?
+dnl ---------------------------------------------------------------------------
+BINTRUE=/bin/true
+
+if test -f /bin/true.exe ; then
+  BINTRUE=/bin/true.exe
+fi
+if test -f /usr/bin/true ; then
+  BINTRUE=/usr/bin/true
+fi
+
+export BINTRUE
+
+AC_SUBST(BINTRUE,$BINTRUE)
+
+dnl ---------------------------------------------------------------------------
+dnl Capture GDAL_PREFIX for the cpl_config.h include file.
+dnl ---------------------------------------------------------------------------
+
+if test "$prefix" = "NONE" ; then
+  GDAL_PREFIX=/usr/local
+else
+  GDAL_PREFIX=${prefix}
+fi
+
+export GDAL_PREFIX
+AC_DEFINE_UNQUOTED(GDAL_PREFIX,["]$GDAL_PREFIX["], [--prefix directory for GDAL install])
+
+dnl ---------------------------------------------------------------------------
+dnl NG Python bindings.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(python,[  --with-python=ARG   Enable python bindings (ARG=yes, no, or path to python binary)],,)
+
+AC_MSG_CHECKING([for python bindings])
+if test "$with_python" = "yes" ; then
+  dnl
+  dnl Check for Python executable in PATH
+  dnl
+  AC_CHECK_PROGS([PYTHON], [python python3 python2])
+  if test "x$PYTHON" = "x"; then
+    AC_MSG_ERROR([--with-python requested, but Python not found!])
+  fi
+elif test "x$with_python" != "x" -a "$with_python" != "no" ; then
+  PYTHON="$with_python"
+  if test "`$PYTHON -c 'print(1)'`" != "1"; then
+    AC_MSG_ERROR([--with-python requested, but Python not found!])
+  fi
+  AC_MSG_RESULT([enabled])
+else
+  PYTHON=""
+  AC_MSG_RESULT([disabled])
+fi
+
+if test "x$PYTHON" != "x"; then
+  BINDINGS="python $BINDINGS"
+
+  AC_MSG_CHECKING([for python setuptools])
+  SETUPTEST='try:
+  import setuptools
+  print(1)
+except ImportError:
+  pass'
+  PY_HAVE_SETUPTOOLS=`$PYTHON -c "$SETUPTEST"`
+  if test "$PY_HAVE_SETUPTOOLS" = "1"; then
+    AC_MSG_RESULT([found])
+  else
+    AC_MSG_RESULT([not found])
+  fi
+fi
+
+AC_SUBST([PY_HAVE_SETUPTOOLS])
+AC_SUBST([BINDINGS])
+
+dnl ---------------------------------------------------------------------------
+dnl Java support
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(java,[  --with-java       Include Java support (ARG=yes, no or JDK home path)  [[default=no]]],,)
+
+AC_MSG_CHECKING([whether we should include Java support])
+
+JAVA_HOME=""
+JAVA_INC=""
+mac_java_fw=""
+
+if test "x$with_java" = "xyes"; then
+
+dnl Ubuntu
+    JAVA_6_TEST_DIR=
+    JAVA_7_TEST_DIR=
+    JAVA_8_TEST_DIR=
+    JAVA_MAC_TEST_DIR=
+    case "$host_cpu" in
+        i*86*)
+            JAVA_6_TEST_DIR=/usr/lib/jvm/java-6-openjdk-i386
+            JAVA_7_TEST_DIR=/usr/lib/jvm/java-7-openjdk-i386
+            JAVA_8_TEST_DIR=/usr/lib/jvm/java-8-openjdk-i386
+            ;;
+        x86_64*)
+            JAVA_6_TEST_DIR=/usr/lib/jvm/java-6-openjdk-amd64
+            JAVA_7_TEST_DIR=/usr/lib/jvm/java-7-openjdk-amd64
+            JAVA_8_TEST_DIR=/usr/lib/jvm/java-8-openjdk-amd64
+            ;;
+        *)
+            ;;
+    esac
+    case "${host_os}" in
+      darwin*)
+        JAVA_MAC_TEST_DIR=$(/usr/libexec/java_home)
+        ;;
+    esac
+
+    if test "x$JAVA_8_TEST_DIR" != "x" -a -d "$JAVA_8_TEST_DIR/include"; then
+        with_java="$JAVA_8_TEST_DIR"
+
+    elif test "x$JAVA_7_TEST_DIR" != "x" -a -d "$JAVA_7_TEST_DIR/include"; then
+        with_java="$JAVA_7_TEST_DIR"
+
+    elif test "x$JAVA_6_TEST_DIR" != "x" -a -d "$JAVA_6_TEST_DIR/include"; then
+        with_java="$JAVA_6_TEST_DIR"
+
+    elif test -d /usr/lib/jvm/java-6-openjdk; then
+        with_java="/usr/lib/jvm/java-6-openjdk"
+
+dnl RHEL6
+    elif test -d /usr/lib/jvm/java-openjdk; then
+        with_java="/usr/lib/jvm/java-openjdk"
+
+
+dnl OpenSolaris
+    elif test -d /usr/java; then
+        with_java="/usr/java"
+
+dnl Mac OS X
+    elif test "x$JAVA_MAC_TEST_DIR" != "x"; then
+        if test -d "$JAVA_MAC_TEST_DIR/bundle"; then
+            # Mac default 1.6.0_x framework
+            # test for ./bundle first, since older installs also have ./include
+            with_java="$JAVA_MAC_TEST_DIR"
+            mac_java_fw="JavaVM"
+        elif test -d "$JAVA_MAC_TEST_DIR/include"; then
+            # Oracle Java install
+            with_java="$JAVA_MAC_TEST_DIR"
+        fi
+    else
+        AC_MSG_ERROR("cannot find JDK root directory.")
+    fi
+
+    if test \! -d "$with_java/include" && test \! -d "$with_java/bundle"; then
+        AC_MSG_ERROR("$with_java is not a valid JDK.")
+    fi
+fi
+
+if test "x$JAVA_INC" != "x"; then
+    AC_MSG_RESULT([yes])
+elif test "x$with_java" != "x" -a "x$with_java" != "xno"; then
+
+    if test -d "$with_java/bundle" && test -d "/System/Library/Frameworks/JavaVM.framework/Headers"; then
+        # Mac default 1.6.0_x framework
+        # test for ./bundle first, since older installs also have ./include
+        JAVA_HOME="$with_java"
+        JAVA_INC="-I/System/Library/Frameworks/JavaVM.framework/Headers"
+        mac_java_fw="JavaVM"
+        AC_MSG_RESULT([yes])
+    elif test -d "$with_java/include"; then
+        if test -d "$with_java/include/linux"; then
+            JAVA_HOME="$with_java"
+            JAVA_INC="-I$JAVA_HOME/include -I$JAVA_HOME/include/linux"
+            AC_MSG_RESULT([yes])
+        elif test -d "$with_java/include/solaris"; then
+            JAVA_HOME="$with_java"
+            JAVA_INC="-I$JAVA_HOME/include -I$JAVA_HOME/include/solaris"
+            AC_MSG_RESULT([yes])
+        elif test -d "$with_java/include/freebsd"; then
+            JAVA_HOME="$with_java"
+            JAVA_INC="-I$JAVA_HOME/include -I$JAVA_HOME/include/freebsd"
+            AC_MSG_RESULT([yes])
+        elif test -d "$with_java/include/darwin"; then
+            # Oracle Java install, use instead of Mac default 1.6.0_x
+            JAVA_HOME="$with_java"
+            JAVA_INC="-I$JAVA_HOME/include -I$JAVA_HOME/include/darwin"
+            AC_MSG_RESULT([yes])
+        else
+            AC_MSG_ERROR("Cannot find $with_java/include/linux or solaris or freebsd or darwin directory.")
+        fi
+    else
+        AC_MSG_ERROR("Cannot find $with_java/include or <mac_java_framework>/Headers directory.")
+    fi
+
+else
+    AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(JAVA_HOME,$JAVA_HOME)
+AC_SUBST(JAVA_INC,$JAVA_INC)
+
+dnl ---------------------------------------------------------------------------
+dnl HDFS support
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(hdfs,[  --with-hdfs[=ARG]        Include HDFS support (ARG=Path or no)],,)
+
+HDFS_ENABLED=no
+
+if test -z "$with_hdfs" -o "$with_hdfs" = "no" ; then
+     AC_MSG_RESULT([HDFS support not requested.])
+else
+     if test "$JAVA_HOME"; then
+          JNI_LIB="-L$(find $JAVA_HOME | grep libjvm | head -1 | sed "s/[[^/]]*$//") -ljvm"
+     else
+          AC_MSG_ERROR([HDFS support requires java support (--with-java). $JAVA_HOME])
+     fi
+     if echo $JNI_LIB | grep $JAVA_HOME; then
+          AC_MSG_CHECKING([for HDFS in $with_hdfs])
+          AC_CHECK_LIB(hdfs,hdfsConnect,HAVE_HDFS_LIB=yes,HAVE_HDFS_LIB=no,$JNI_LIB -L$with_hdfs/lib/native)
+          AC_CHECK_FILE($with_hdfs/include/hdfs.h,HAVE_HDFS_HEADER=yes,HAVE_HDFS_HEADER=no)
+          if test "$HAVE_HDFS_LIB" = "yes" -a "$HAVE_HDFS_HEADER" = "yes"; then
+               AC_MSG_RESULT([HDFS support enabled.])
+               HDFS_ENABLED=yes
+               HDFS_LIB="-L$with_hdfs/lib/native -lhdfs"
+               HDFS_INC="-I$with_hdfs/include"
+          else
+               AC_MSG_ERROR([HDFS support not enabled.])
+          fi
+     else
+          AC_MSG_ERROR([Unable to find libjvm.])
+     fi
+fi
+
+AC_SUBST(HDFS_ENABLED,$HDFS_ENABLED)
+AC_SUBST(HDFS_LIB,$HDFS_LIB)
+AC_SUBST(HDFS_INC,$HDFS_INC)
+AC_SUBST(JNI_LIB,$JNI_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl TileDB support
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(tiledb,[  --with-tiledb[=ARG]    Include TileDB support (ARG=no, yes or tiledb install root path)],,)
+
+TILEDB_SETTING=no
+TILEDB_CFLAGS=
+
+if test "$with_tiledb" = "yes" -o "$with_tiledb" = "" ; then
+
+  AC_CHECK_LIB(tiledb,tiledb_coords,TILEDB_SETTING=yes,TILEDB_SETTING=no,)
+
+  if test "$TILEDB_SETTING" = "yes" ; then
+    LIBS="-ltiledb $LIBS"
+  else
+    echo "libtiledb not found - TileDB support disabled"
+  fi
+
+elif test "$with_tiledb" != "no" -a "$with_tiledb" != ""; then
+
+  AC_CHECK_LIB(tiledb,tiledb_coords,TILEDB_SETTING=yes,TILEDB_SETTING=no,-L$with_tiledb/lib -ltiledb)
+
+  if test "$TILEDB_SETTING" = "yes" ; then
+    LIBS="-L$with_tiledb/lib -ltiledb $LIBS"
+    TILEDB_CFLAGS="-I$with_tiledb/include"
+  else
+    echo "libtiledb not found - TileDB support disabled"
+  fi
+fi
+
+if test "$TILEDB_SETTING" != "no" ; then
+
+  AC_LANG_PUSH([C++])
+  SAVED_CXXFLAGS=$CXXFLAGS
+  CXXFLAGS="$CXXFLAGS $TILEDB_CFLAGS"
+  AC_MSG_CHECKING([if tiledb/tiledb can be included without additional flags])
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+    [[#include "tiledb/tiledb"]])],
+    [TILEDB_CAN_BE_INCLUDED="yes"]
+    [AC_MSG_RESULT([yes])],
+    [TILEDB_CAN_BE_INCLUDED="no"]
+    [AC_MSG_RESULT([no])])
+  CXXFLAGS=$SAVED_CXXFLAGS
+  AC_LANG_POP([C++])
+
+  if test "$TILEDB_CAN_BE_INCLUDED" = "no"; then
+    AC_LANG_PUSH([C++])
+    SAVED_CXXFLAGS=$CXXFLAGS
+    CXXFLAGS="$CXXFLAGS $TILEDB_CFLAGS -std=c++17"
+    AC_MSG_CHECKING([if tiledb/tiledb can be included with -std=c++17])
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+      [[#include "tiledb/tiledb"]])],
+      [TILEDB_CAN_BE_INCLUDED="yes"]
+      [AC_MSG_RESULT([yes])],
+      [TILEDB_CAN_BE_INCLUDED="no"]
+      [AC_MSG_RESULT([no])])
+    CXXFLAGS=$SAVED_CXXFLAGS
+    AC_LANG_POP([C++])
+
+    if test "$TILEDB_CAN_BE_INCLUDED" = "yes"; then
+      TILEDB_CFLAGS="$TILEDB_CFLAGS -std=c++17"
+    fi
+  fi
+
+  OPT_GDAL_FORMATS="tiledb $OPT_GDAL_FORMATS"
+fi
+
+AC_SUBST(TILEDB_SETTING,$TILEDB_SETTING)
+AC_SUBST(TILEDB_CFLAGS,$TILEDB_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Select Rasdaman or disable driver.
+dnl ---------------------------------------------------------------------------
+
+RASDAMAN_ENABLED=no
+
+AS_MESSAGE([checking whether we should include rasdaman support...])
+AC_ARG_WITH(rasdaman,
+[  --with-rasdaman[=DIR]        Include rasdaman support (DIR is rasdaman's install dir).],,)
+
+if test "$with_rasdaman" = "yes" ; then
+
+  AC_CHECK_LIB(raslib,main,RASDAMAN_ENABLED=yes,,,)
+
+  if test -n "$RASDAMAN_ENABLED" ; then
+      RASDAMAN_LIB="-lrasodmg -lclientcomm -lcompression -lnetwork -lraslib"
+      OPT_GDAL_FORMATS="rasdaman $OPT_GDAL_FORMATS"
+      AC_MSG_RESULT([        using rasdaman from system libs.])
+  else
+      AC_MSG_WARN([        rasdaman not found in system libs... use --with-rasdaman=DIR.])
+  fi
+
+elif test -n "$with_rasdaman" -a "$with_rasdaman" != "no" ; then
+
+  RASDAMAN_DIR=$with_rasdaman
+
+  if test -f $RASDAMAN_DIR/include/rasdaman.hh -a -d$RASDAMAN_DIR/lib ; then
+      RASDAMAN_INC=-I$RASDAMAN_DIR/include
+      RASDAMAN_LIB="-L$RASDAMAN_DIR/lib -lrasodmg -lclientcomm -lcompression -lnetwork -lraslib"
+  else
+      AC_MSG_ERROR("Could not find rasdaman.hh or libraslib.a in $RASDAMAN_DIR.")
+  fi
+
+  RASDAMAN_ENABLED=yes
+  OPT_GDAL_FORMATS="rasdaman $OPT_GDAL_FORMATS"
+  AC_MSG_RESULT([        using rasdaman from $RASDAMAN_DIR.])
+
+else
+
+  AC_MSG_RESULT([        rasdaman support not requested.])
+fi
+
+AC_SUBST(RASDAMAN_ENABLED,$RASDAMAN_ENABLED)
+AC_SUBST(RASDAMAN_INC,    $RASDAMAN_INC)
+AC_SUBST(RASDAMAN_LIB,    $RASDAMAN_LIB)
+
+
+dnl ---------------------------------------------------------------------------
+dnl brunsli support
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(brunsli,[  --with-brunsli    Include brunsli support via libbrunsli library],,)
+
+BRUNSLI_ENABLED=no
+
+if test "$with_brunsli" != "" -a "$with_brunsli" != "no" ; then
+  BRUNSLI_ENABLED="yes"
+  AC_SUBST(BRUNSLI_ENABLED, $BRUNSLI_ENABLED)
+  AC_SUBST(BRUNSLI_INCLUDE, -I$prefix/include)
+  AC_SUBST(BRUNSLI_LIB, "-lbrunslienc-c -lbrunslidec-c")
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl RDB support
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rdb,[  --with-rdb[=ARG]    Include RDB support (ARG=no, yes or RDB SDK root path)],,)
+
+RDB_SETTING=no
+
+if test "$with_rdb" = "yes" -o "$with_rdb" = "" ; then
+
+  AC_CHECK_LIB(rdb,rdb_library_name,RDB_SETTING=yes,RDB_SETTING=no,)
+
+  if test "$RDB_SETTING" = "yes" ; then
+    LIBS="-lrdb $LIBS"
+  else
+    echo "librdb not found - RDB support disabled"
+  fi
+
+elif test "$with_rdb" != "no" -a "$with_rdb" != ""; then
+
+  AC_CHECK_LIB(rdb,rdb_library_name,RDB_SETTING=yes,RDB_SETTING=no,-L$with_rdb/library -lrdb)
+
+  if test "$RDB_SETTING" = "yes" ; then
+    LIBS="-L$with_rdb/library -lrdb $LIBS"
+    EXTRA_INCLUDES="-I$with_rdb/interface/cpp/ -I$with_rdb/interface/c/ $EXTRA_INCLUDES"
+  else
+    echo "librdb not found - RDB support disabled"
+  fi
+
+fi
+
+AC_SUBST(RDB_SETTING,$RDB_SETTING)
+
+if test "$RDB_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="rdb $OPT_GDAL_FORMATS"
+fi
+
+
+dnl ---------------------------------------------------------------------------
+dnl Armadillo support
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(armadillo,[  --with-armadillo=ARG       Include Armadillo support for faster TPS transform computation (ARG=yes/no/path to armadillo install root) [[default=no]]],,)
+
+AC_MSG_CHECKING([whether we should include Armadillo support])
+
+HAVE_ARMADILLO=no
+
+if test "$with_armadillo" = "yes" ; then
+    rm -f testarmadillo.*
+    rm -f testarmadillo
+    echo '#include <armadillo>' > testarmadillo.cpp
+    echo 'int main(int argc, char** argv) { arma::mat matInput(2,2); const arma::mat& matInv = arma::inv(matInput); return 0; } ' >> testarmadillo.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testarmadillo.cpp -o testarmadillo -larmadillo 2>&1`" ; then
+        HAVE_ARMADILLO=yes
+        LIBS="-larmadillo ${LIBS}"
+        AC_MSG_RESULT([yes])
+    else
+        dnl Try adding -llapack (#4923)
+        if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testarmadillo.cpp -o testarmadillo -larmadillo -llapack 2>&1`" ; then
+            HAVE_ARMADILLO=yes
+            LIBS="-larmadillo -llapack ${LIBS}"
+            AC_MSG_RESULT([yes])
+        else
+            # clang 3.4 needs linking against libstdc++ (ubuntu 14.04)
+            if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testarmadillo.cpp -o testarmadillo -larmadillo -lstdc++ 2>&1`" ; then
+                HAVE_ARMADILLO=yes
+                LIBS="-larmadillo -lstdc++ ${LIBS}"
+                AC_MSG_RESULT([yes])
+            else
+                AC_MSG_RESULT([no])
+            fi
+        fi
+    fi
+    rm -f testarmadillo.*
+    rm -f testarmadillo
+
+elif test -n "$with_armadillo" -a "$with_armadillo" != "no" ; then
+
+    rm -f testarmadillo.*
+    rm -f testarmadillo
+    echo '#include <armadillo>' > testarmadillo.cpp
+    echo 'int main(int argc, char** argv) { arma::mat matInput(2,2); const arma::mat& matInv = arma::inv(matInput); return 0; } ' >> testarmadillo.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -I$with_armadillo/include testarmadillo.cpp -o testarmadillo -L$with_armadillo/lib -larmadillo 2>&1`" ; then
+        HAVE_ARMADILLO=yes
+        LIBS="-L$with_armadillo/lib -larmadillo ${LIBS}"
+        EXTRA_INCLUDES="-I$with_armadillo/include $EXTRA_INCLUDES"
+        AC_MSG_RESULT([yes])
+    else
+        dnl Try adding -llapack (#4923)
+        if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -I$with_armadillo/include testarmadillo.cpp -o testarmadillo -L$with_armadillo/lib -larmadillo -llapack 2>&1`" ; then
+            HAVE_ARMADILLO=yes
+            LIBS="-L$with_armadillo/lib -larmadillo -llapack ${LIBS}"
+            EXTRA_INCLUDES="-I$with_armadillo/include $EXTRA_INCLUDES"
+            AC_MSG_RESULT([yes])
+        else
+            AC_MSG_RESULT([no])
+        fi
+    fi
+    rm -f testarmadillo.*
+    rm -f testarmadillo
+
+else
+    AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(HAVE_ARMADILLO,$HAVE_ARMADILLO)
+
+dnl ---------------------------------------------------------------------------
+dnl libcryptopp
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(cryptopp,[  --with-cryptopp[=ARG]       Include cryptopp support (ARG=yes, no or path)],,)
+
+HAVE_CRYPTOPP=no
+USE_ONLY_CRYPTODLL_ALG=yes
+
+AC_MSG_CHECKING([for cryptopp])
+
+if test "$with_cryptopp" = "no" ; then
+
+  AC_MSG_RESULT([disabled])
+
+elif test "$with_cryptopp" = "yes" -o "$with_cryptopp" = "" ; then
+
+    rm -f testcryptopp.*
+    echo '#include <cryptopp/aes.h>' > testcryptopp.cpp
+    # Catch issue with clang++ (https://groups.google.com/forum/#!topic/cryptopp-users/DfWHy3bT0KI)
+    echo '#include <cryptopp/osrng.h>' >> testcryptopp.cpp
+    echo 'int main(int argc, char** argv) { CryptoPP::AES::Encryption oEnc; return 0; } ' >> testcryptopp.cpp
+    ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testcryptopp.cpp -o testcryptopp -lcryptopp 2>/dev/null
+    RETVAL=$?
+    if test $RETVAL -eq 0; then
+        HAVE_CRYPTOPP=yes
+        LIBS="-lcryptopp ${LIBS}"
+        AC_MSG_RESULT([yes])
+    else
+        AC_MSG_RESULT([no])
+        if test "$with_cryptopp" = "yes"; then
+            AC_MSG_ERROR([--with-cryptopp was requested, but not available])
+        fi
+    fi
+    rm -f testcryptopp.*
+    rm -f testcryptopp
+
+    if test "$HAVE_CRYPTOPP" = "yes"; then
+
+        AC_MSG_CHECKING([if cryptopp has all cipher methods builtin])
+        rm -f testcryptopp.*
+        echo '#include <cryptopp/blowfish.h>' > testcryptopp.cpp
+        echo 'int main(int argc, char** argv) { CryptoPP::Blowfish::Encryption oEnc; return 0; } ' >> testcryptopp.cpp
+        ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testcryptopp.cpp -o testcryptopp -lcryptopp 2>/dev/null
+        RETVAL=$?
+        if test $RETVAL -eq 0; then
+            USE_ONLY_CRYPTODLL_ALG=no
+            AC_MSG_RESULT([yes])
+        else
+            USE_ONLY_CRYPTODLL_ALG=yes
+            AC_MSG_RESULT([no])
+        fi
+        rm -f testcryptopp.*
+        rm -f testcryptopp
+    fi
+
+else
+
+    rm -f testcryptopp.*
+    echo '#include <cryptopp/aes.h>' > testcryptopp.cpp
+    # Catch issue with clang++ (https://groups.google.com/forum/#!topic/cryptopp-users/DfWHy3bT0KI)
+    echo '#include <cryptopp/osrng.h>' >> testcryptopp.cpp
+    echo 'int main(int argc, char** argv) { CryptoPP::AES::Encryption oEnc; return 0; } ' >> testcryptopp.cpp
+    ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testcryptopp.cpp -I$with_cryptopp/include -o testcryptopp -L$with_cryptopp/lib -lcryptopp 2>/dev/null
+    RETVAL=$?
+    if test $RETVAL -eq 0; then
+        HAVE_CRYPTOPP=yes
+        LIBS="-L$with_cryptopp/lib -lcryptopp ${LIBS}"
+        EXTRA_INCLUDES="-I$with_cryptopp/include $EXTRA_INCLUDES"
+        AC_MSG_RESULT([yes])
+    else
+        AC_MSG_RESULT([no])
+    fi
+    rm -f testcryptopp.*
+    rm -f testcryptopp
+
+    if test "$HAVE_CRYPTOPP" = "yes"; then
+
+        AC_MSG_CHECKING([if cryptopp has all cipher methods builtin])
+        rm -f testcryptopp.*
+        echo '#include <cryptopp/blowfish.h>' > testcryptopp.cpp
+        echo 'int main(int argc, char** argv) { CryptoPP::Blowfish::Encryption oEnc; return 0; } ' >> testcryptopp.cpp
+        ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testcryptopp.cpp -I$with_cryptopp/include -o testcryptopp -L$with_cryptopp/lib -lcryptopp 2>/dev/null
+        RETVAL=$?
+        if test $RETVAL -eq 0; then
+            USE_ONLY_CRYPTODLL_ALG=no
+            AC_MSG_RESULT([yes])
+        else
+            USE_ONLY_CRYPTODLL_ALG=yes
+            AC_MSG_RESULT([no])
+        fi
+        rm -f testcryptopp.*
+        rm -f testcryptopp
+    fi
+
+fi
+
+AC_SUBST(HAVE_CRYPTOPP,$HAVE_CRYPTOPP)
+AC_SUBST(USE_ONLY_CRYPTODLL_ALG,$USE_ONLY_CRYPTODLL_ALG)
+
+dnl ---------------------------------------------------------------------------
+dnl crypto
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(crypto,[  --with-crypto[=ARG]       Include crypto (from openssl) support (ARG=yes, no or path)],,)
+
+HAVE_OPENSSL_CRYPTO=no
+
+AC_MSG_CHECKING([for crypto])
+
+if test "$with_crypto" = "no" ; then
+
+  AC_MSG_RESULT([disabled])
+
+elif test "$with_crypto" = "yes" -o \( "$with_crypto" = "" -a "$HAVE_CRYPTOPP" = "no" \) ; then
+
+    AC_CHECK_LIB(crypto,EVP_sha256,HAVE_OPENSSL_CRYPTO=yes)
+    if test "$HAVE_OPENSSL_CRYPTO" = "yes"; then
+        AC_CHECK_HEADERS([openssl/bio.h])
+        if test "$ac_cv_header_openssl_bio_h" = "no"; then
+            HAVE_OPENSSL_CRYPTO=no
+        else
+            LIBS="-lcrypto $LIBS"
+        fi
+    fi
+fi
+
+AC_SUBST(HAVE_OPENSSL_CRYPTO,$HAVE_OPENSSL_CRYPTO)
+
+dnl ---------------------------------------------------------------------------
+dnl Whether to include LERC in the build
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(lerc,
+    [  --with-lerc[=ARG]         Include libLerc support(ARG=yes/no/internal/path). Used by internal libtiff and MRF.],,,)
+
+HAVE_LERC=no
+AC_MSG_CHECKING([for LERC])
+if test "$with_lerc" = "internal"; then
+    if test "$ac_cv_c_bigendian" = "yes"; then
+        AC_MSG_RESULT([disabled on big-endian])
+    else
+        HAVE_LERC=internal
+        AC_MSG_RESULT([enabled, internal])
+    fi
+elif test "$with_lerc" = "no"; then
+    HAVE_LERC=no
+    AC_MSG_RESULT([disabled by user])
+elif test "$with_lerc" = "yes" -o "x$with_lerc" = "x" ; then
+  lerc_lib_name="LercLib"
+  AC_CHECK_LIB("$lerc_lib_name", lerc_decode, [lerc_lib=yes], [lerc_lib=no],)
+  if test "$lerc_lib" = "no" ; then
+    lerc_lib_name="Lerc"
+    AC_CHECK_LIB("$lerc_lib_name", lerc_decode, [lerc_lib=yes], [lerc_lib=no],)
+  fi
+  if test "$lerc_lib" = "no" -a "$with_lerc" = "yes"; then
+    AC_MSG_ERROR([lerc library not found])
+  fi
+
+  AC_CHECK_HEADER(Lerc_c_api.h, [lerc_c_api_h=yes], [lerc_c_api_h=no])
+  if test "$lerc_c_api_h" = "no" -a "$with_lerc" = "yes"; then
+    AC_MSG_ERROR([Liblerc headers not found])
+  fi
+
+  if test "$lerc_lib" = "yes" -a "$lerc_c_api_h" = "yes"; then
+    HAVE_LERC=external
+    LIBS="$LIBS -l$lerc_lib_name"
+  else
+    if test "$ac_cv_c_bigendian" = "yes"; then
+        AC_MSG_RESULT([disabled on big-endian])
+    else
+        HAVE_LERC=internal
+        AC_MSG_RESULT([enabled, internal])
+    fi
+  fi
+else
+
+  ORIG_LIBS="$LIBS"
+  LIBS="-L$with_lerc/lib $LIBS"
+  lerc_lib_name="LercLib"
+  AC_CHECK_LIB("$lerc_lib_name", lerc_decode, [lerc_lib=yes], [lerc_lib=no],)
+  if test "$lerc_lib" = "no" ; then
+    lerc_lib_name="Lerc"
+    AC_CHECK_LIB("$lerc_lib_name", lerc_decode, [lerc_lib=yes], [lerc_lib=no],)
+  fi
+  if test "$lerc_lib" = "no"; then
+    AC_MSG_ERROR([lerc library not found])
+  fi
+
+  LIBS="-L$with_lerc/lib -l$lerc_lib_name $ORIG_LIBS"
+
+  if ! test -f "$with_lerc/include/Lerc_c_api.h"; then
+    AC_MSG_ERROR([Liblerc headers not found])
+  fi
+
+  HAVE_LERC=external
+  LERC_INCLUDE="-I$with_lerc/include"
+fi
+
+AC_SUBST(HAVE_LERC,$HAVE_LERC)
+AC_SUBST(LERC_INCLUDE,$LERC_INCLUDE)
+
+dnl ---------------------------------------------------------------------------
+dnl Whether to include NULL driver in the build
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([null],
+	    AS_HELP_STRING([--with-null],
+	       [Enable NULL driver (only useful for development purposes]),,)
+
+AC_MSG_CHECKING([for NULL])
+if test "$with_null" = "yes" ; then
+    OPT_GDAL_FORMATS="null $OPT_GDAL_FORMATS"
+    AC_MSG_RESULT([enabled])
+else
+    AC_MSG_RESULT([disabled])
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Detect OpenEXR
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(exr,[  --with-exr            Include EXR support via OpenEXR library],,)
+
+HAVE_EXR=no
+EXR_CFLAGS=""
+
+if test "$with_exr" = "no" ; then
+
+  AC_MSG_NOTICE([EXR support disabled.])
+
+else
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([EXR], [OpenEXR >= 2.2], [HAVE_EXR=yes], [HAVE_EXR=no])
+
+  if test -n "$EXR_CFLAGS"; then
+
+    # Test that the package found is for the right architecture
+    saved_LIBS="$LIBS"
+    LIBS="$EXR_LIBS"
+    AC_CHECK_LIB(IlmImf,ImfTiledInputReadTile, [HAVE_EXR=yes], [HAVE_EXR=no])
+    if test "$HAVE_EXR" = "no"; then
+      dnl Try with OpenEXR >= 3 name
+      AC_CHECK_LIB(OpenEXR,ImfTiledInputReadTile, [HAVE_EXR=yes], [HAVE_EXR=no])
+    fi
+    LIBS="$saved_LIBS"
+
+    if test "$HAVE_EXR" = "yes"; then
+        OPT_GDAL_FORMATS="exr $OPT_GDAL_FORMATS"
+        LIBS="$EXR_LIBS $LIBS"
+    else
+        EXR_CFLAGS=""
+    fi
+  fi
+fi
+
+AC_SUBST(EXR_CFLAGS,$EXR_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Detect libheif
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(heif,[  --with-heif            Include HEIF support via libheif library],,)
+
+HAVE_HEIF=no
+HEIF_CFLAGS=""
+
+if test "$with_heif" = "no" ; then
+
+  AC_MSG_NOTICE([HEIF support disabled.])
+
+else
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([HEIF], [libheif >= 1.1], [], [HAVE_HEIF=no])
+
+  if test -n "$HEIF_LIBS"; then
+
+    # Test that the package found is for the right architecture
+    saved_LIBS="$LIBS"
+    LIBS="$HEIF_LIBS"
+    AC_CHECK_LIB(heif,heif_context_get_list_of_top_level_image_IDs, [HAVE_HEIF=yes], [HAVE_HEIF=no])
+    LIBS="$saved_LIBS"
+
+    if test "$HAVE_HEIF" = "yes"; then
+        OPT_GDAL_FORMATS="heif $OPT_GDAL_FORMATS"
+        LIBS="$HEIF_LIBS $LIBS"
+    else
+        HEIF_CFLAGS=""
+    fi
+  fi
+fi
+
+AC_SUBST(HEIF_CFLAGS,$HEIF_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Detect libjxl
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(jxl,[  --with-jxl            Include JPEG-XL support via libjxl library, requires an internal libtiff.],,)
+
+HAVE_JXL=no
+
+if test "$TIFF_SETTING" != "internal" -o  "$with_jxl" = "no" ; then
+
+  AC_MSG_NOTICE([JXL support disabled.])
+
+else
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([JXL], [libjxl], [], [HAVE_JXL=no])
+
+  if test -n "$JXL_LIBS" ; then
+
+    # Test that the package found is for the right architecture
+    saved_LIBS="$LIBS"
+    LIBS="$JXL_LIBS"
+    AC_CHECK_LIB(jxl,JxlEncoderOptionsCreate, [HAVE_JXL=yes], [HAVE_JXL=no])
+    LIBS="$saved_LIBS"
+
+    if test "$HAVE_JXL" = "yes"; then
+        LIBS="$JXL_LIBS $LIBS"
+
+        AC_CHECK_LIB(jxl,JxlEncoderFrameSettingsSetOption, [HAVE_JxlEncoderFrameSettingsSetOption=yes], [HAVE_JxlEncoderFrameSettingsSetOption=no])
+        if test "$HAVE_JxlEncoderFrameSettingsSetOption" = "yes"; then
+            JXL_CFLAGS="$JXL_CFLAGS -DHAVE_JxlEncoderFrameSettingsSetOption"
+        fi
+    fi
+  fi
+fi
+
+AC_SUBST(HAVE_JXL,$HAVE_JXL)
+AC_SUBST(JXL_CFLAGS,$JXL_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Test if sprintf can be overloaded with _XOPEN_SOURCE being defined or other,
+dnl includes being included before, which mingw64 4.8 doesn't like (#6390)
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([if sprintf can be overloaded for GDAL compilation])
+echo '#define _XOPEN_SOURCE' > testdeprecated.cpp
+echo '#include <vector>' >> testdeprecated.cpp
+echo '#include <stdio.h>' >> testdeprecated.cpp
+echo 'extern "C"' >> testdeprecated.cpp
+echo '{' >> testdeprecated.cpp
+echo 'int sprintf(char *str, const char* fmt, ...);' >> testdeprecated.cpp
+echo '}' >> testdeprecated.cpp
+${CXX} ${CXXFLAGS} ${CPPFLAGS} testdeprecated.cpp -c 2>/dev/null
+RETVAL=$?
+if test $RETVAL -eq 0; then
+    AC_MSG_RESULT([yes])
+else
+    CPPFLAGS="$CPPFLAGS -DDONT_DEPRECATE_SPRINTF"
+    AC_MSG_RESULT([no])
+fi
+rm -f testdeprecated.*
+rm -f testdeprecated
+
+dnl Use -municode for mingw
+case "${host_os}" in
+    mingw32*)
+        AC_MSG_CHECKING([if mingw supports wmain])
+        rm -f testwmain*
+        echo '#include <wchar.h>' > testwmain.cpp
+        echo '#include <stdlib.h>' >> testwmain.cpp
+        echo 'extern "C" int wmain( int argc, wchar_t ** argv_w );' >> testwmain.cpp
+        echo 'extern "C" int wmain( int , wchar_t **  ) { return 0; } ' >> testwmain.cpp
+        ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testwmain.cpp -o testwmain.exe -municode 2>/dev/null
+        RETVAL=$?
+        rm -f testwmain*
+        if test $RETVAL -eq 0; then
+            AC_MSG_RESULT([yes])
+            CPPFLAGS="$CPPFLAGS -DSUPPORTS_WMAIN"
+            LDFLAGS="$LDFLAGS -municode"
+        else
+            AC_MSG_RESULT([no])
+        fi
+        ;;
+    *)
+        ;;
+esac
+
+AC_CONFIG_FILES([GDALmake.opt])
+AC_OUTPUT
+
+dnl ---------------------------------------------------------------------------
+dnl Display configuration status
+dnl ---------------------------------------------------------------------------
+
+LOC_MSG()
+LOC_MSG([GDAL is now configured for ${host}])
+LOC_MSG()
+LOC_MSG([  Installation directory:    ${prefix}])
+LOC_MSG([  C compiler:                ${CC} ${CFLAGS}])
+LOC_MSG([  C++ compiler:              ${CXX} ${CXXFLAGS}])
+LOC_MSG([  C++14 support:             ${CXX14_SUPPORT}])
+LOC_MSG()
+LOC_MSG([  LIBTOOL support:           ${with_libtool}])
+LOC_MSG()
+LOC_MSG([  Armadillo support:         ${HAVE_ARMADILLO}])
+LOC_MSG([  Blosc support:             ${HAVE_BLOSC}])
+LOC_MSG([  CFITSIO support:           ${FITS_SETTING}])
+LOC_MSG([  crypto/openssl support:    ${HAVE_OPENSSL_CRYPTO}])
+LOC_MSG([  cryptopp support:          ${HAVE_CRYPTOPP}])
+LOC_MSG([  cURL support (wms/wcs/...):${CURL_SETTING}])
+LOC_MSG([  DDS support:               ${DDS_SETTING}])
+LOC_MSG([  ECW support:               ${ECW_SETTING}])
+LOC_MSG([  Expat support:             ${HAVE_EXPAT}])
+LOC_MSG([  EXR support:               ${HAVE_EXR}])
+LOC_MSG([  FGDB support:              ${FGDB_ENABLED}])
+LOC_MSG([  FreeXL support:            ${HAVE_FREEXL}])
+LOC_MSG([  GEORASTER support:         ${HAVE_GEORASTER}])
+LOC_MSG([  GEOS support:              ${HAVE_GEOS}])
+LOC_MSG([  Google libkml support:     ${HAVE_LIBKML}])
+LOC_MSG([  GTA support:               ${GTA_SETTING}])
+LOC_MSG([  HDF4 support:              ${HAVE_HDF4}])
+LOC_MSG([  HDF5 support:              ${HAVE_HDF5}])
+LOC_MSG([  JXL support:               ${HAVE_JXL}])
+LOC_MSG([  HDFS support:              ${HDFS_ENABLED}])
+LOC_MSG([  HEIF support:              ${HAVE_HEIF}])
+LOC_MSG([  INFORMIX DataBlade support:${HAVE_IDB}])
+LOC_MSG([  JP2Lura support:           ${HAVE_JP2LURA}])
+LOC_MSG([  JPEG 12 bit:               ${JPEG12_ENABLED}])
+LOC_MSG([  JPEG-in-TIFF 12 bit:       ${TIFF_JPEG12_ENABLED}])
+LOC_MSG([  Kakadu support:            ${HAVE_KAKADU}])
+LOC_MSG([  Kea support:               ${HAVE_KEA}])
+LOC_MSG([  LERC support:              ${HAVE_LERC}])
+LOC_MSG([  libbrunsli support:        ${BRUNSLI_ENABLED}])
+LOC_MSG([  libdeflate support:        ${LIBDEFLATE_SETTING}])
+LOC_MSG([  LIBGEOTIFF support:        ${GEOTIFF_SETTING}])
+LOC_MSG([  LIBGIF support:            ${GIF_SETTING}])
+LOC_MSG([  LIBJPEG support:           ${JPEG_SETTING}])
+LOC_MSG([  LIBLZMA support:           ${LIBLZMA_SETTING}])
+LOC_MSG([  LIBPNG support:            ${PNG_SETTING}])
+LOC_MSG([  LIBTIFF support:           ${TIFF_SETTING} (BigTIFF=${HAVE_BIGTIFF})])
+LOC_MSG([  libxml2 support:           ${HAVE_LIBXML2}])
+LOC_MSG([  LIBZ support:              ${LIBZ_SETTING}])
+LOC_MSG([  LZ4 support:               ${HAVE_LZ4}])
+LOC_MSG([  MongoCXX v3 support:       ${MONGOCXXV3_ENABLED}])
+LOC_MSG([  MrSID support:             ${HAVE_MRSID}])
+LOC_MSG([  MSG support:               ${HAVE_MSG}])
+LOC_MSG([  MySQL support:             ${HAVE_MYSQL}])
+if test "$NETCDF_SETTING" = "yes" ; then
+  LOC_MSG([  NetCDF has netcdf_mem.h:   ${NETCDF_MEM}])
+fi
+LOC_MSG([  NetCDF support:            ${NETCDF_SETTING}])
+LOC_MSG([  OCI support:               ${HAVE_OCI}])
+LOC_MSG([  ODBC support:              ${ODBC_SETTING}])
+LOC_MSG([  OGDI support:              ${HAVE_OGDI}])
+LOC_MSG([  OpenCL support:            ${OPENCL_SETTING}])
+LOC_MSG([  OpenJPEG support:          ${HAVE_OPENJPEG}])
+LOC_MSG([  PCIDSK support:            ${PCIDSK_SETTING}])
+LOC_MSG([  PCRaster support:          ${PCRASTER_SETTING}])
+LOC_MSG([  PCRE support:              ${HAVE_PCRE}])
+LOC_MSG([  PCRE2 support:             ${HAVE_PCRE2}])
+LOC_MSG([  PDFium support:            ${HAVE_PDFIUM}])
+LOC_MSG([  Podofo support:            ${HAVE_PODOFO}])
+LOC_MSG([  Poppler support:           ${HAVE_POPPLER}])
+LOC_MSG([  PostgreSQL support:        ${HAVE_PG}])
+LOC_MSG([  QHull support:             ${QHULL_SETTING}])
+LOC_MSG([  Rasdaman support:          ${RASDAMAN_ENABLED}])
+LOC_MSG([  RasterLite2 support:       ${HAVE_RASTERLITE2}])
+LOC_MSG([  RDB support:               ${RDB_SETTING}])
+LOC_MSG([  SAP HANA support:          ${HAVE_HANA}])
+LOC_MSG([  SFCGAL support:            ${HAVE_SFCGAL}])
+LOC_MSG([  SOSI support:              ${SOSI_ENABLED}])
+LOC_MSG([  SpatiaLite support:        ${HAVE_SPATIALITE}])
+if test "x$SPATIALITE_SONAME" != "x"; then
+  LOC_MSG([  SpatiaLite shared obj name:${SPATIALITE_SONAME}])
+fi
+LOC_MSG([  SQLite support:            ${HAVE_SQLITE}])
+LOC_MSG([  Teigha (DWG and DGNv8):    ${HAVE_TEIGHA}])
+LOC_MSG([  TileDB support:            ${TILEDB_SETTING}])
+LOC_MSG([  userfaultfd support:       ${ENABLE_UFFD}])
+LOC_MSG([  WebP support:              ${WEBP_SETTING}])
+LOC_MSG([  Xerces-C support:          ${HAVE_XERCES}])
+LOC_MSG([  ZSTD support:              ${ZSTD_SETTING}])
+
+LOC_MSG()
+if test ! -z "`uname | grep Darwin`" ; then
+  LOC_MSG([  Mac OS X Framework :       ${MACOSX_FRAMEWORK}])
+fi
+LOC_MSG()
+if test -z "$BINDINGS"; then
+    WHAT_BINDINGS="no"
+else
+    WHAT_BINDINGS="$BINDINGS"
+fi
+LOC_MSG([  misc. gdal formats:       ${GDALFORMATS_ENABLED}])
+LOC_MSG([  misc. ogr formats:        ${OGRFORMATS_ENABLED}])
+LOC_MSG()
+LOC_MSG([  disabled gdal formats:    ${GDALFORMATS_DISABLED}])
+LOC_MSG([  disabled ogr formats:     ${OGRFORMATS_DISABLED}])
+LOC_MSG()
+LOC_MSG([  SWIG Bindings:             ${WHAT_BINDINGS}])
+LOC_MSG()
+LOC_MSG([  PROJ >= 6:                 yes])
+LOC_MSG([  enable GNM building:       ${GNM_ENABLED}])
+LOC_MSG([  enable pthread support:    ${PTHREAD_ENABLED}])
+LOC_MSG([  enable POSIX iconv support:${am_cv_func_iconv}])
+LOC_MSG([  hide internal symbols:     ${HAVE_HIDE_INTERNAL_SYMBOLS}])
+LOC_MSG()
+
+if test "$HAVE_PODOFO" = "yes" -a "$HAVE_POPPLER" = "yes"  -a "$HAVE_PDFIUM" = "yes"; then
+    AC_MSG_WARN([--with-podofo, --with-poppler and --with-pdfium available. This is unusual setup, but will work. Pdfium will be used by default...])
+elif test "$HAVE_PODOFO" = "yes" -a "$HAVE_POPPLER" = "yes" ; then
+    AC_MSG_WARN([--with-podofo and --with-poppler are both available. This is unusual setup, but will work. Poppler will be used by default...])
+elif test "$HAVE_POPPLER" = "yes" -a "$HAVE_PDFIUM" = "yes" ; then
+    AC_MSG_WARN([--with-poppler and --with-pdfium are both available. This is unusual setup, but will work. Pdfium will be used by default...])
+elif test "$HAVE_PODOFO" = "yes" -a "$HAVE_PDFIUM" = "yes" ; then
+    AC_MSG_WARN([--with-podofo and --with-pdfium are both available. This is unusual setup, but will work. Pdfium will be used by default...])
+fi
+
+if test "$HAVE_LIBXML2" = "yes" -a "$FGDB_ENABLED" = "yes"; then
+    AC_MSG_WARN([--with-libxml2 and --with-fgdb are both available. There might be some incompatibility between system libxml2 and the embedded copy within libFileGDBAPI])
+fi
+
+if test "$HAVE_CRYPTOPP" = "yes" -a "$HAVE_OPENSSL_CRYPTO" = "yes"; then
+    AC_MSG_WARN([--with-crypto and --with-cryptopp available. This is unusual setup, but will work.])
+fi
+
+if test "$HAVE_TEIGHA" = "yes" -a "$ECW_54" = "yes"; then
+    AC_MSG_WARN([Both Teigha SDK and ECW SDK >= 5.4 found. This was found to cause crashes in ECW driver.])
+fi
+
+AC_MSG_NOTICE([])
+AC_MSG_NOTICE([])
+AC_MSG_WARN([Starting with GDAL 3.5, the autoconf build system is deprecated in favor of the CMake build system. The autoconf build system will be completely removed in GDAL 3.6])
diff -Nru gdal-3.5.0-orig/configure.ac.orig gdal-3.5.0-patched/configure.ac.orig
--- gdal-3.5.0-orig/configure.ac.orig	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.5.0-patched/configure.ac.orig	2022-09-14 04:26:13.036347492 -0400
@@ -0,0 +1,5778 @@
+dnl ***************************************************************************
+dnl $Id$
+dnl
+dnl Project:  GDAL
+dnl Purpose:  Configure source file.
+dnl Author:   Frank Warmerdam, warmerdam@pobox.com
+dnl
+dnl ***************************************************************************
+dnl Copyright (c) 2000, Frank Warmerdam
+dnl
+dnl Permission is hereby granted, free of charge, to any person obtaining a
+dnl copy of this software and associated documentation files (the "Software"),
+dnl to deal in the Software without restriction, including without limitation
+dnl the rights to use, copy, modify, merge, publish, distribute, sublicense,
+dnl and/or sell copies of the Software, and to permit persons to whom the
+dnl Software is furnished to do so, subject to the following conditions:
+dnl
+dnl The above copyright notice and this permission notice shall be included
+dnl in all copies or substantial portions of the Software.
+dnl
+dnl THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+dnl OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+dnl FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+dnl THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+dnl LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+dnl FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+dnl DEALINGS IN THE SOFTWARE.
+dnl ***************************************************************************
+
+dnl Disable configure caching ... it causes lots of hassles.
+define([AC_CACHE_LOAD], )
+define([AC_CACHE_SAVE], )
+
+dnl Process this file with autoconf to produce a configure script.
+AC_INIT
+AC_CONFIG_SRCDIR([GDALmake.opt.in])
+AC_SUBST(PACKAGE, gdal)
+AC_CONFIG_MACRO_DIR(m4)
+AC_CONFIG_HEADERS([generated_headers/cpl_config.h:port/cpl_config.h.in])
+AH_TOP([#ifndef CPL_CONFIG_H])
+AH_TOP([#define CPL_CONFIG_H])
+AH_BOTTOM([#include "cpl_config_extras.h"])
+AH_BOTTOM([#endif])
+
+AC_PREREQ([2.69])
+
+dnl Compute the canonical host-system (the system we are building for)
+dnl type variable $host
+AC_CANONICAL_HOST
+
+dnl Enable as much warnings as possible
+AC_LANG_PUSH([C])
+AX_COMPILER_VENDOR
+AC_LANG_POP([C])
+AX_CFLAGS_WARN_ALL(C_WFLAGS)
+AC_LANG_PUSH([C++])
+AX_COMPILER_VENDOR
+AC_LANG_POP([C++])
+AX_CXXFLAGS_WARN_ALL(CXX_WFLAGS)
+
+dnl Remove -Wdeclaration-after-statement that is no longer appropriate in C99
+C_WFLAGS=`echo "$C_WFLAGS " | sed "s/-Wdeclaration-after-statement //"`
+
+dnl For ICC: it needs -we10006 instead of -Werror to turn unknown options to errors
+dnl Some gcc/clang versions might succeed on this test, so also include -Werror in ERROR_ON_UNKNOWN_OPTIONS
+AX_CHECK_COMPILE_FLAG([-Werror -we10006],[ERROR_ON_UNKNOWN_OPTIONS="-Werror -we10006"],[ERROR_ON_UNKNOWN_OPTIONS="-Werror"])
+
+dnl A few ICC warnings to turn off
+dnl warning #188: enumerated type mixed with another type  (needed on libcsf)
+dnl warning #1684: conversion from pointer to same-sized integral type (potential portability problem)  (needed on frmts/mrf)
+dnl warning #2259: non-pointer conversion from "size_t={unsigned long}" to "int" may lose significant bits
+dnl warning #2304: non-explicit constructor with single argument may cause implicit type conversion
+dnl warning #3280: declaration hides member
+dnl remark #11074: Inlining inhibited by limit max-size
+dnl remark #11076: To get full report use -qopt-report=4 -qopt-report-phase ipo
+AX_CHECK_COMPILE_FLAG([-diag-disable 188,1684,2259,2304,3280,11074,11076],[C_WFLAGS="$C_WFLAGS -diag-disable 188,1684,2259,2304,3280,11074,11076" CXX_WFLAGS="$CXX_WFLAGS -diag-disable 188,1684,2259,2304,3280,11074,11076"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+AX_CHECK_COMPILE_FLAG([-Wextra],[C_WFLAGS="$C_WFLAGS -Wextra" CXX_WFLAGS="$CXX_WFLAGS -Wextra"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Winit-self],[C_WFLAGS="$C_WFLAGS -Winit-self" CXX_WFLAGS="$CXX_WFLAGS -Winit-self"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wunused-parameter], [C_WFLAGS="$C_WFLAGS -Wunused-parameter" CXX_WFLAGS="$CXX_WFLAGS -Wunused-parameter" NO_UNUSED_PARAMETER_FLAG="-Wno-unused-parameter"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wmissing-prototypes], [C_WFLAGS="$C_WFLAGS -Wmissing-prototypes"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wmissing-declarations], [C_WFLAGS="$C_WFLAGS -Wmissing-declarations"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wformat], [C_WFLAGS="$C_WFLAGS -Wformat" CXX_WFLAGS="$CXX_WFLAGS -Wformat"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wformat -Werror=format-security -Wno-format-nonliteral], [C_WFLAGS="$C_WFLAGS -Werror=format-security -Wno-format-nonliteral" CXX_WFLAGS="$CXX_WFLAGS -Werror=format-security -Wno-format-nonliteral"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wshorten-64-to-32], [C_WFLAGS="$C_WFLAGS -Wshorten-64-to-32" CXX_WFLAGS="$CXX_WFLAGS -Wshorten-64-to-32"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wlogical-op], [C_WFLAGS="$C_WFLAGS -Wlogical-op" CXX_WFLAGS="$CXX_WFLAGS -Wlogical-op" NO_LOGICAL_OP_FLAG="-Wno-logical-op"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wshadow], [C_WFLAGS="$C_WFLAGS -Wshadow" CXX_WFLAGS="$CXX_WFLAGS -Wshadow"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wmissing-include-dirs], [C_WFLAGS="$C_WFLAGS -Wmissing-include-dirs" CXX_WFLAGS="$CXX_WFLAGS -Wmissing-include-dirs"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl Error out on things that will fail with MSVC
+AX_CHECK_COMPILE_FLAG([-Werror=vla], [C_WFLAGS="$C_WFLAGS -Werror=vla" CXX_WFLAGS="$CXX_WFLAGS -Werror=vla"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl -Wclobbered is not reliable on most gcc versions
+dnl AX_CHECK_COMPILE_FLAG([-Wno-clobbered], [C_WFLAGS="$C_WFLAGS -Wno-clobbered" CXX_WFLAGS="$CXX_WFLAGS -Wno-clobbered"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl Warn when macros __TIME__, __DATE__ or __TIMESTAMP__ are encountered as they might prevent bit-wise-identical reproducible compilations.
+AX_CHECK_COMPILE_FLAG([-Wdate-time], [C_WFLAGS="$C_WFLAGS -Wdate-time" CXX_WFLAGS="$CXX_WFLAGS -Wdate-time"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl GCC 6 warnings
+AX_CHECK_COMPILE_FLAG([-Wnull-dereference], [C_WFLAGS="$C_WFLAGS -Wnull-dereference" CXX_WFLAGS="$CXX_WFLAGS -Wnull-dereference"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wduplicated-cond], [C_WFLAGS="$C_WFLAGS -Wduplicated-cond" CXX_WFLAGS="$CXX_WFLAGS -Wduplicated-cond"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl GCC 7 warnings
+dnl Do not enable yet. Causes warning in alg/gdalthinplate.cpp due to armadillo templates
+dnl AX_CHECK_COMPILE_FLAG([-Wduplicated-branches], [C_WFLAGS="$C_WFLAGS -Wduplicated-branches" CXX_WFLAGS="$CXX_WFLAGS -Wduplicated-branches"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl GCC 8 warnings
+AC_LANG_PUSH([C++])
+AX_CHECK_COMPILE_FLAG([-Wextra-semi], [CXX_WFLAGS="$CXX_WFLAGS -Wextra-semi"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AC_LANG_POP([C++])
+
+dnl clang >= 3.9
+AX_CHECK_COMPILE_FLAG([-Wcomma], [C_WFLAGS="$C_WFLAGS -Wcomma" CXX_WFLAGS="$CXX_WFLAGS -Wcomma"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl clang and gcc 5
+AX_CHECK_COMPILE_FLAG([-Wfloat-conversion], [C_WFLAGS="$C_WFLAGS -Wfloat-conversion" CXX_WFLAGS="$CXX_WFLAGS -Wfloat-conversion"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl clang >= 3.2
+AX_CHECK_COMPILE_FLAG([-Wdocumentation -Wno-documentation-deprecated-sync], [C_WFLAGS="$C_WFLAGS -Wdocumentation -Wno-documentation-deprecated-sync" CXX_WFLAGS="$CXX_WFLAGS -Wdocumentation -Wno-documentation-deprecated-sync"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl C++ specific stuff
+
+AC_LANG_PUSH([C++])
+AX_CHECK_COMPILE_FLAG([-Wunused-private-field], [CXX_WFLAGS="$CXX_WFLAGS -Wunused-private-field"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wmissing-declarations], [CXX_WFLAGS="$CXX_WFLAGS -Wmissing-declarations"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wnon-virtual-dtor], [CXX_WFLAGS="$CXX_WFLAGS -Wnon-virtual-dtor" NO_NON_VIRTUAL_DTOR_FLAG="-Wno-non-virtual-dtor"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Wold-style-cast], [WARN_OLD_STYLE_CAST="-Wold-style-cast"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AX_CHECK_COMPILE_FLAG([-Weffc++], [WARN_EFFCPLUSPLUS="-Weffc++"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl g++-4.8 complain a bit too much with -Weffc++
+if test "$WARN_EFFCPLUSPLUS" != ""; then
+    SAVED_CXXFLAGS=$CXXFLAGS
+    CXXFLAGS="$CXXFLAGS $WARN_EFFCPLUSPLUS -Werror"
+    AC_MSG_CHECKING([if -Weffc++ should be enabled])
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+    [[
+    class Base {};
+    class A: public Base {};
+    ]])],
+    [AC_MSG_RESULT([yes])],
+    [WARN_EFFCPLUSPLUS=""]
+    [AC_MSG_RESULT([no])])
+    CXXFLAGS=$SAVED_CXXFLAGS
+fi
+
+dnl Clang enables -Woverloaded-virtual if -Wall is defined, but not GCC
+AX_CHECK_COMPILE_FLAG([-Woverloaded-virtual], [CXX_WFLAGS="$CXX_WFLAGS -Woverloaded-virtual"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+dnl Forbid use of 'or', 'and', ... alias operators
+AX_CHECK_COMPILE_FLAG([-fno-operator-names], [CXX_WFLAGS="$CXX_WFLAGS -fno-operator-names"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+
+HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT=no
+AX_CHECK_COMPILE_FLAG([-Wzero-as-null-pointer-constant], [CXX_WFLAGS="$CXX_WFLAGS -Wzero-as-null-pointer-constant" HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT=yes],,[$ERROR_ON_UNKNOWN_OPTIONS])
+if test "$HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT" = "yes"; then
+AC_DEFINE_UNQUOTED(HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT, 1,
+          [Define to 1 if the compiler supports -Wzero-as-null-pointer-constant])
+fi
+
+AC_LANG_POP([C++])
+
+CXX14_SUPPORT=no
+AC_ARG_WITH([cpp14],
+	    AS_HELP_STRING([--with-cpp14],
+	       [Enable C++14 compiler options]),,)
+
+AC_MSG_CHECKING([if use C++14 compiler options])
+if test "$with_cpp14" = "yes"; then
+    dnl Check C++ compiler compatibility with C++14
+    AC_MSG_CHECKING([C++ compiler compatibility with C++14])
+    AX_CXX_COMPILE_STDCXX([14],[noext],[optional])
+
+    if [test "$HAVE_CXX14" = "1"]; then
+        CXX14_SUPPORT=yes
+    fi
+    AC_MSG_RESULT([enabled])
+else
+    AC_MSG_RESULT([disabled by user])
+fi
+AC_SUBST(CXX14_SUPPORT,$CXX14_SUPPORT)
+
+if [test "$CXX14_SUPPORT" = "no"]; then
+    AX_CXX_COMPILE_STDCXX_11([noext],[mandatory])
+fi
+
+dnl Available in GCC 5.1
+AC_LANG_PUSH([C++])
+    AX_CHECK_COMPILE_FLAG([-Wsuggest-override], [CXX_WFLAGS="$CXX_WFLAGS -Wsuggest-override"],,[$ERROR_ON_UNKNOWN_OPTIONS])
+AC_LANG_POP([C++])
+
+dnl Enable -Wimplicit-fallthrough only if C++11 is enabled since CPL_FALLTHROUGH is only active then
+AC_LANG_PUSH([C++])
+SAVED_CXXFLAGS=$CXXFLAGS
+CXXFLAGS="$CXXFLAGS $ERROR_ON_UNKNOWN_OPTIONS -Wimplicit-fallthrough"
+AC_MSG_CHECKING([if -Wimplicit-fallthrough can be enabled])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+  [[#if !(__cplusplus >= 201103L && ( (defined(__clang__) && (__clang_major__ > 3 || (__clang_major__ == 3 && __clang_minor__ >=7))) || ((defined(__GNUC__) && __GNUC__ >= 7)) ) )
+    #error "not (C++11 and (clang >= 3.7 or gcc >= 7))"
+    #endif]])],
+  [CXX_WFLAGS="$CXX_WFLAGS -Wimplicit-fallthrough"]
+  [AC_MSG_RESULT([yes])],
+  [AC_MSG_RESULT([no])])
+CXXFLAGS=$SAVED_CXXFLAGS
+AC_LANG_POP([C++])
+
+AC_SUBST(CXX_WFLAGS,$CXX_WFLAGS)
+AC_SUBST(C_WFLAGS,$C_WFLAGS)
+AC_SUBST(NO_UNUSED_PARAMETER_FLAG,$NO_UNUSED_PARAMETER_FLAG)
+AC_SUBST(NO_SIGN_COMPARE,$NO_SIGN_COMPARE)
+AC_SUBST(NO_NON_VIRTUAL_DTOR_FLAG,$NO_NON_VIRTUAL_DTOR_FLAG)
+AC_SUBST(NO_LOGICAL_OP_FLAG,$NO_LOGICAL_OP_FLAG)
+AC_SUBST(WARN_OLD_STYLE_CAST,$WARN_OLD_STYLE_CAST)
+AC_SUBST(WARN_EFFCPLUSPLUS,$WARN_EFFCPLUSPLUS)
+
+dnl Checks for programs.
+
+dnl AC_PROG_CC_C99 is deprecated since autoconf 2.70
+m4_if(m4_version_compare(m4_defn([AC_AUTOCONF_VERSION]), [2.70]),
+     [-1], [AC_PROG_CC_C99], [AC_PROG_CC])
+
+AC_PROG_CXX
+LT_INIT([win32-dll])
+
+dnl Check that CXX is really a working compiler
+AC_LANG_PUSH([C++])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+  [[#ifndef __cplusplus
+    #error "broken C++"
+    #endif]])],,
+  [CXX=;])
+AC_LANG_POP([C++])
+
+if test "x$CXX" = x ; then
+  AC_MSG_ERROR("You don't have a working C++ compiler.")
+fi
+
+AC_MSG_CHECKING([for std::isnan])
+AC_LANG_PUSH([C++])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+  [[#include <cmath>
+    int CPLIsNan(float f) { return std::isnan(f); }]])],
+  [
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_STD_IS_NAN, 1,
+          [Define to 1 if you have the `std::isnan' function.])
+  ], [
+    AC_MSG_RESULT([no])
+  ])
+AC_LANG_POP([C++])
+
+dnl switch between libtool and native build system
+AC_ARG_WITH(libtool, [  --without-libtool     Don't use libtool to build the library],,)
+
+if test "$with_libtool" = "no"; then
+AC_PROG_RANLIB
+
+dnl AC_COMPILER_PIC as expanded by autoconf-2.68 doesn't work for the C++ part with clang++ 3.0 that doesn't like compiling .c programs
+dnl so we inline the expanded code and fix it at hand.
+dnl AC_COMPILER_PIC
+	echo 'void f(){}' > conftest.c
+	if test -z "`${CC-cc} $CFLAGS -fPIC -c conftest.c 2>&1`"; then
+	  CFLAGS="$CFLAGS -fPIC"
+	fi
+	echo 'void f(){}' > conftest.cpp
+	if test -z "`${CXX-g++} $CXXFLAGS -fPIC -c conftest.cpp 2>&1`"; then
+	  CXXFLAGS="$CXXFLAGS -fPIC"
+	fi
+	rm -f conftest*
+
+dnl Trick so that LD_SHARED test works with sanitizer flags with clang
+SAVED_CFLAGS=$CFLAGS
+CFLAGS=`echo "$CFLAGS " | sed "s/-fsanitize=undefined //" | sed "s/-fsanitize=address //" | sed "s/-fsanitize=unsigned-integer-overflow //"`
+AC_LD_SHARED
+CFLAGS=$SAVED_CFLAGS
+else
+with_libtool=yes
+fi
+AC_SUBST(HAVE_LIBTOOL,$with_libtool)
+
+dnl Checks for libraries.
+AC_CHECK_LIB(dl,dlopen,,,)
+
+dnl Needed on Solaris.
+AC_CHECK_LIB(rt,nanosleep,,,)
+
+dnl We don't need to add math library to all targets
+case "${host_os}" in
+    cygwin* | mingw32* | pw32* | beos* | darwin*)
+        ;;
+    *)
+	AC_CHECK_LIB(m,sin,,,)
+        ;;
+esac
+
+dnl Checks for header files.
+AC_CHECK_HEADERS(fcntl.h unistd.h dlfcn.h locale.h direct.h)
+
+dnl Check for userfaultfd support
+AC_CHECK_HEADERS([linux/userfaultfd.h], [ENABLE_UFFD="yes"], [ENABLE_UFFD="no"], [])
+AC_SUBST(ENABLE_UFFD,$ENABLE_UFFD)
+
+dnl cpl_vsil_unix_stdio_64.h requires linux/fs.h on Linux, and this isn't
+dnl installed by default on Alpine
+case "${host_os}" in
+    linux*)
+        AC_CHECK_HEADERS([linux/fs.h], [], [AC_MSG_ERROR([Unable to find linux/fs.h header])])
+        ;;
+    *)
+        ;;
+esac
+
+AC_C_BIGENDIAN
+
+dnl Check for 64 bit file API
+AC_UNIX_STDIO_64
+
+AC_CHECK_SIZEOF(int)
+AC_CHECK_SIZEOF(unsigned long)
+AC_CHECK_SIZEOF(void*)
+
+dnl Checks for library functions.
+AC_CHECK_FUNCS(vsnprintf)
+AC_CHECK_FUNCS(getcwd)
+AC_CHECK_FUNCS(readlink)
+AC_CHECK_FUNCS(lstat)
+AC_CHECK_FUNCS(posix_spawnp)
+AC_CHECK_FUNCS(posix_memalign)
+AC_CHECK_FUNCS(vfork)
+AC_CHECK_FUNCS(mmap)
+AC_CHECK_FUNCS(sigaction)
+AC_CHECK_FUNCS(statvfs)
+AC_CHECK_FUNCS(statvfs64)
+AC_CHECK_FUNCS(getrlimit)
+
+AC_MSG_CHECKING([for RLIMIT_AS])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <sys/time.h>
+#include <sys/resource.h>
+  ]], [[
+    return RLIMIT_AS;
+  ]])],[
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_RLIMIT_AS, 1,
+          [Define to 1 if you have the `RLIMIT_AS' constant.])
+  ],[
+    AC_MSG_RESULT([no])
+])
+
+
+dnl Make sure at least these are checked under C++.  Prototypes missing on
+dnl some platforms.
+
+AC_LANG_PUSH(C++)
+AC_CHECK_FUNC_CUSTOM(gmtime_r,[#include <time.h>],[time_t t; struct tm ltime; t = time(0); gmtime_r( &t, &ltime );])
+AC_CHECK_FUNC_CUSTOM(localtime_r,[#include <time.h>],[time_t t; struct tm ltime; t = time(0); localtime_r( &t, &ltime );])
+AC_LANG_POP(C++)
+
+AC_CHECK_HEADERS([xlocale.h],[HAVE_XLOCALE_H=1])
+if test "$HAVE_XLOCALE_H" = "1"; then
+  AC_DEFINE_UNQUOTED(HAVE_XLOCALE_H, 1,
+            [Define if you have the <xlocale.h> header file.])
+fi
+
+AC_MSG_CHECKING([for uselocale])
+AC_LANG_PUSH(C++)
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define _XOPEN_SOURCE 700
+#include <locale.h>
+  ]], [[
+    locale_t alocale = newlocale (LC_NUMERIC_MASK, "C", 0);
+    locale_t oldlocale = uselocale(alocale);
+    uselocale(oldlocale);
+    freelocale(alocale);
+    return 0;
+  ]])],[
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_USELOCALE, 1,
+          [Define to 1 if you have the `uselocale' function.])
+  ],[
+    AC_MSG_RESULT([no])
+])
+AC_LANG_POP(C++)
+
+
+OPT_GDAL_FORMATS=
+EXTRA_INCLUDES=
+
+dnl ---------------------------------------------------------------------------
+dnl Check for --enable-debug
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([to enable debug build])
+
+AC_ARG_ENABLE(debug,
+	      AS_HELP_STRING([--enable-debug],
+			     [enable debugging (disabled by default)]),
+	      [HAVE_DEBUG=$enableval], [HAVE_DEBUG=yes])
+
+CFLAGS_NOFTRAPV="$CFLAGS"
+CXXFLAGS_NOFTRAPV="$CXXFLAGS"
+
+if test "x$enable_debug" = "xyes" ; then
+
+  dnl Try to strip out optimization.
+
+  CXXFLAGS=`echo "$CXXFLAGS " | sed "s/-O2 //"`
+  CFLAGS=`echo "$CFLAGS " | sed "s/-O2 //"`
+  CXXFLAGS=`echo "$CXXFLAGS" | sed "s/-O //"`
+  CFLAGS=`echo "$CFLAGS" | sed "s/-O //"`
+
+  dnl remove existing -g to avoid duplicates.
+
+  CXXFLAGS=`echo "$CXXFLAGS" | sed "s/-g //"`
+  CFLAGS=`echo "$CFLAGS" | sed "s/-g //"`
+
+  dnl add -g and -DDEBUG
+
+  CXXFLAGS="$CXXFLAGS -g -DDEBUG"
+  CFLAGS="$CFLAGS -g -DDEBUG"
+
+  CFLAGS_NOFTRAPV="$CFLAGS"
+  CXXFLAGS_NOFTRAPV="$CXXFLAGS"
+
+  AC_MSG_RESULT([yes, modified CFLAGS="$CFLAGS"])
+
+  # Some clang version on 32 bits have linking error with 64bit operations (undefined reference to `__mulodi4')
+  AC_MSG_CHECKING([whether -ftrapv can be used])
+  rm -f testftrapv.c
+  echo 'int main(int argc, char** argv) { return (long long)argc * argc; } ' > testftrapv.c
+  if test -z "`${CC} ${CFLAGS} -ftrapv testftrapv.c -o testftrapv 2>&1`" ; then
+    AC_MSG_RESULT([yes])
+    CFLAGS="$CFLAGS -ftrapv"
+    CXXFLAGS="$CXXFLAGS -ftrapv"
+  else
+    AC_MSG_RESULT([no])
+  fi
+  rm -f testftrapv.* testftrapv
+
+else
+  AC_MSG_RESULT([no, CFLAGS="$CFLAGS"])
+fi
+
+AC_SUBST(CFLAGS_NOFTRAPV,$CFLAGS_NOFTRAPV)
+AC_SUBST(CXXFLAGS_NOFTRAPV,$CXXFLAGS_NOFTRAPV)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if GCC 4.1 atomic builtins are really available
+dnl (some GCC versions are broken w.r.t this on some exotic architectures...)
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([whether GCC 4.1 atomic builtins are available])
+
+rm -f atomicbuiltins.c
+echo 'int main(int argc, char** argv) { int i; __sync_add_and_fetch(&i, 1); __sync_sub_and_fetch(&i, 1); __sync_bool_compare_and_swap(&i, 0, 1); return 0; } ' > atomicbuiltins.c
+if test -z "`${CC} ${CFLAGS} atomicbuiltins.c -o atomicbuiltins 2>&1`" ; then
+    HAVE_GCC_ATOMIC_BUILTINS=yes
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_GCC_ATOMIC_BUILTINS,1, [Define to 1 if GCC atomic builtins are available])
+else
+    HAVE_GCC_ATOMIC_BUILTINS=no
+    AC_MSG_RESULT([no])
+fi
+rm -rf atomicbuiltins.* atomicbuiltins
+
+AC_SUBST(HAVE_GCC_ATOMIC_BUILTINS,$HAVE_GCC_ATOMIC_BUILTINS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if GCC bswap builtins are available
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([whether GCC bswap builtins are available])
+
+rm -f bswapbuiltins.c
+echo 'int main(int argc, char** argv) { (void)__builtin_bswap32(0); (void)__builtin_bswap64(0); return 0; } ' >> bswapbuiltins.c
+if test -z "`${CC} ${CFLAGS} bswapbuiltins.c -o bswapbuiltins 2>&1`" ; then
+    HAVE_GCC_BSWAP=yes
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_GCC_BSWAP,1, [Define to 1 if GCC bswap builtins are available])
+else
+    HAVE_GCC_BSWAP=no
+    AC_MSG_RESULT([no])
+fi
+rm -rf bswapbuiltins.* bswapbuiltins
+
+AC_SUBST(HAVE_GCC_BSWAP,$HAVE_GCC_BSWAP)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if __uint128_t is available and usable
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([for __uint128_t])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+  ]], [[
+      unsigned long long v1 = 1024ULL;
+      unsigned long long v2 = 0x8000000000000000ULL;
+      __uint128_t u = ((__uint128_t)v1)*((__uint128_t)v2);
+      return u == 0;
+  ]])],[
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_UINT128_T, 1,
+          [Define to 1 if the system has the type __uint128_t])
+  ],[
+    AC_MSG_RESULT([no])
+])
+
+dnl ---------------------------------------------------------------------------
+dnl Check SSE availability
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(sse,
+[  --with-sse[=ARG]        Detect SSE availability for some optimized routines (ARG=yes(default), no)],,)
+
+AC_MSG_CHECKING([whether SSE is available at compile time])
+
+if test "$with_sse" = "yes" -o "$with_sse" = ""; then
+
+    rm -f detectsse.cpp
+    echo '#ifdef __SSE__' > detectsse.cpp
+    echo '#include <xmmintrin.h>' >> detectsse.cpp
+    echo 'void foo() { float fEpsilon = 0.0000000000001f; __m128 xmm_small = _mm_load1_ps(&fEpsilon); }  int main() { return 0; }' >> detectsse.cpp
+    echo '#else' >> detectsse.cpp
+    echo 'some_error' >> detectsse.cpp
+    echo '#endif' >> detectsse.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -o detectsse detectsse.cpp 2>&1`" ; then
+        AC_MSG_RESULT([yes])
+        SSEFLAGS=""
+        HAVE_SSE_AT_COMPILE_TIME=yes
+    else
+        if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -msse -o detectsse detectsse.cpp 2>&1`" ; then
+            AC_MSG_RESULT([yes])
+            SSEFLAGS="-msse"
+            HAVE_SSE_AT_COMPILE_TIME=yes
+        else
+            AC_MSG_RESULT([no])
+            if test "$with_sse" = "yes"; then
+                AC_MSG_ERROR([--with-sse was requested, but SSE is not available])
+            fi
+        fi
+    fi
+
+    dnl On Solaris, the presence of SSE instructions is flagged in the binary
+    dnl and prevent it to run on non SSE hardware even if the instructions are
+    dnl not executed. So if the user did not explicitly requires SSE, test that
+    dnl we can run SSE binaries
+    if test "$HAVE_SSE_AT_COMPILE_TIME" = "yes"; then
+       case $host_os in
+         solaris*)
+           AC_MSG_CHECKING([whether SSE is available and needed at runtime])
+           if ./detectsse; then
+             AC_MSG_RESULT([yes])
+           else
+             AC_MSG_RESULT([no])
+             if test "$with_sse" = "yes"; then
+               echo "Caution: the generated binaries will not run on this system."
+             else
+               echo "Disabling SSE as it is not explicitly required"
+               HAVE_SSE_AT_COMPILE_TIME=""
+               SSEFLAGS=""
+             fi
+           fi
+           ;;
+       esac
+    fi
+
+    if test "$HAVE_SSE_AT_COMPILE_TIME" = "yes"; then
+        CFLAGS="-DHAVE_SSE_AT_COMPILE_TIME $CFLAGS"
+        CXXFLAGS="-DHAVE_SSE_AT_COMPILE_TIME $CXXFLAGS"
+    fi
+
+    rm -rf detectsse*
+else
+    AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(SSEFLAGS,$SSEFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check SSSE3 availability
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(ssse3,
+[  --with-ssse3[=ARG]        Detect SSSE3 availability for some optimized routines (ARG=yes(default), no)],,)
+
+AC_MSG_CHECKING([whether SSSE3 is available at compile time])
+
+if test "$with_ssse3" = "yes" -o "$with_ssse3" = ""; then
+
+    rm -f detectssse3.cpp
+    echo '#ifdef __SSSE3__' > detectssse3.cpp
+    echo '#include <tmmintrin.h>' >> detectssse3.cpp
+    echo 'void foo() { __m128i xmm_i = _mm_set1_epi16(0); xmm_i = _mm_shuffle_epi8(xmm_i, xmm_i); }  int main() { return 0; }' >> detectssse3.cpp
+    echo '#else' >> detectssse3.cpp
+    echo 'some_error' >> detectssse3.cpp
+    echo '#endif' >> detectssse3.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -o detectssse3 detectssse3.cpp 2>&1`" ; then
+        AC_MSG_RESULT([yes])
+        SSSE3FLAGS=""
+        HAVE_SSSE3_AT_COMPILE_TIME=yes
+    else
+        if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -mssse3 -o detectssse3 detectssse3.cpp 2>&1`" ; then
+            AC_MSG_RESULT([yes])
+            SSSE3FLAGS="-mssse3"
+            HAVE_SSSE3_AT_COMPILE_TIME=yes
+        else
+            AC_MSG_RESULT([no])
+            if test "$with_ssse3" = "yes"; then
+                AC_MSG_ERROR([--with-ssse3 was requested, but SSSE3 is not available])
+            fi
+        fi
+    fi
+
+    dnl On Solaris, the presence of SSSE3 instructions is flagged in the binary
+    dnl and prevent it to run on non SSSE3 hardware even if the instructions are
+    dnl not executed. So if the user did not explicitly requires SSSE3, test that
+    dnl we can run SSSE3 binaries
+    if test "$HAVE_SSSE3_AT_COMPILE_TIME" = "yes"; then
+       case $host_os in
+         solaris*)
+           AC_MSG_CHECKING([whether SSSE3 is available and needed at runtime])
+           if ./detectssse3; then
+             AC_MSG_RESULT([yes])
+           else
+             AC_MSG_RESULT([no])
+             if test "$with_ssse3" = "yes"; then
+               echo "Caution: the generated binaries will not run on this system."
+             else
+               echo "Disabling SSSE3 as it is not explicitly required"
+               HAVE_SSSE3_AT_COMPILE_TIME=""
+               SSSE3FLAGS=""
+             fi
+           fi
+           ;;
+       esac
+    fi
+
+    if test "$HAVE_SSSE3_AT_COMPILE_TIME" = "yes"; then
+        CFLAGS="-DHAVE_SSSE3_AT_COMPILE_TIME $CFLAGS"
+        CXXFLAGS="-DHAVE_SSSE3_AT_COMPILE_TIME $CXXFLAGS"
+    fi
+
+    rm -rf detectssse3*
+else
+    AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(SSSE3FLAGS,$SSSE3FLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check AVX availability
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(avx,
+[  --with-avx[=ARG]        Detect AVX availability for some optimized routines (ARG=yes(default), no)],,)
+
+AC_MSG_CHECKING([whether AVX is available at compile time])
+
+if test "$with_avx" = "yes" -o "$with_avx" = ""; then
+
+    rm -f detectavx.cpp
+    echo '#ifdef __AVX__' > detectavx.cpp
+    echo '#include <immintrin.h>' >> detectavx.cpp
+    echo 'int foo() { unsigned int nXCRLow, nXCRHigh;' >> detectavx.cpp
+    echo '__asm__ ("xgetbv" : "=a" (nXCRLow), "=d" (nXCRHigh) : "c" (0));' >> detectavx.cpp
+    echo 'float fEpsilon = 0.0000000000001f;' >> detectavx.cpp
+    echo '__m256 ymm_small = _mm256_set_ps(fEpsilon,fEpsilon,fEpsilon,fEpsilon,fEpsilon,fEpsilon,fEpsilon,fEpsilon);' >> detectavx.cpp
+    echo 'return (int)nXCRLow + _mm256_movemask_ps(ymm_small); }' >> detectavx.cpp
+    echo 'int main(int argc, char**) { if( argc == 0 ) return foo(); return 0; }' >> detectavx.cpp
+    echo '#else' >> detectavx.cpp
+    echo 'some_error' >> detectavx.cpp
+    echo '#endif' >> detectavx.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -o detectavx detectavx.cpp 2>&1`" ; then
+        AC_MSG_RESULT([yes])
+        AVXFLAGS=""
+        HAVE_AVX_AT_COMPILE_TIME=yes
+    else
+        if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -mavx -o detectavx detectavx.cpp 2>&1`" ; then
+            AC_MSG_RESULT([yes])
+            AVXFLAGS="-mavx"
+            HAVE_AVX_AT_COMPILE_TIME=yes
+        else
+            AC_MSG_RESULT([no])
+            if test "$with_avx" = "yes"; then
+                AC_MSG_ERROR([--with-avx was requested, but AVX is not available])
+            fi
+        fi
+    fi
+
+    dnl On Solaris, the presence of AVX instructions is flagged in the binary
+    dnl and prevent it to run on non AVX hardware even if the instructions are
+    dnl not executed. So if the user did not explicitly requires AVX, test that
+    dnl we can run AVX binaries
+    if test "$HAVE_AVX_AT_COMPILE_TIME" = "yes"; then
+       case $host_os in
+         solaris*)
+           AC_MSG_CHECKING([whether AVX is available and needed at runtime])
+           if ./detectavx; then
+             AC_MSG_RESULT([yes])
+           else
+             AC_MSG_RESULT([no])
+             if test "$with_avx" = "yes"; then
+               echo "Caution: the generated binaries will not run on this system."
+             else
+               echo "Disabling AVX as it is not explicitly required"
+               AVXFLAGS=""
+               HAVE_AVX_AT_COMPILE_TIME=""
+             fi
+           fi
+           ;;
+       esac
+    fi
+
+    if test "$HAVE_AVX_AT_COMPILE_TIME" = "yes"; then
+        CFLAGS="-DHAVE_AVX_AT_COMPILE_TIME $CFLAGS"
+        CXXFLAGS="-DHAVE_AVX_AT_COMPILE_TIME $CXXFLAGS"
+    fi
+
+    rm -rf detectavx*
+else
+    AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(AVXFLAGS,$AVXFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for --enable-lto
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([to enable LTO (link time optimization) build])
+
+AC_ARG_ENABLE(lto,
+              AS_HELP_STRING([--enable-lto],
+                             [enable LTO(link time optimization) (disabled by default)]))
+
+CXXFLAGS_NO_LTO_IF_AVX_NONDEFAULT="$CXXFLAGS"
+CXXFLAGS_NO_LTO_IF_SSSE3_NONDEFAULT="$CXXFLAGS"
+
+if test "x$enable_lto" = "xyes" ; then
+
+  dnl remove existing -g.
+
+  CXXFLAGS=`echo "$CXXFLAGS" | sed "s/-g //"`
+  CFLAGS=`echo "$CFLAGS" | sed "s/-g //"`
+
+  dnl add -flto
+
+  CXXFLAGS="$CXXFLAGS -flto"
+  CFLAGS="$CFLAGS -flto"
+  LDFLAGS="$LDFLAGS -flto"
+
+  dnl in case we have avx available by default, then we can compile everything
+  dnl with -flto
+  if test "$HAVE_AVX_AT_COMPILE_TIME" = "yes"; then
+    if test "$AVXFLAGS" = ""; then
+        CXXFLAGS_NO_LTO_IF_AVX_NONDEFAULT="$CXXFLAGS"
+    fi
+  fi
+  if test "$HAVE_SSSE3_AT_COMPILE_TIME" = "yes"; then
+    if test "$SSSE3FLAGS" = ""; then
+        CXXFLAGS_NO_LTO_IF_SSSE3_NONDEFAULT="$CXXFLAGS"
+    fi
+  fi
+
+  AC_MSG_RESULT([yes])
+else
+  AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(CXXFLAGS_NO_LTO_IF_AVX_NONDEFAULT,$CXXFLAGS_NO_LTO_IF_AVX_NONDEFAULT)
+AC_SUBST(CXXFLAGS_NO_LTO_IF_SSSE3_NONDEFAULT,$CXXFLAGS_NO_LTO_IF_SSSE3_NONDEFAULT)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if we need -lws2_32 (mingw)
+dnl ---------------------------------------------------------------------------
+
+echo "#include <winsock2.h>" > test_ws2_32.c
+echo "#include <ws2tcpip.h>" >> test_ws2_32.c
+echo "void foo() {}" >> test_ws2_32.c
+
+if test -z "`${CC} -c test_ws2_32.c 2>&1`" ; then
+  LIBS="$LIBS -lws2_32"
+fi
+rm -f test_ws2_32*
+
+dnl ---------------------------------------------------------------------------
+dnl Check if we need -lpsapi (mingw)
+dnl ---------------------------------------------------------------------------
+
+echo "#include <windows.h>" > test_psapi.c
+echo "#include <psapi.h>" >> test_psapi.c
+echo "void foo() {}" >> test_psapi.c
+
+if test -z "`${CC} -c test_psapi.c 2>&1`" ; then
+  LIBS="$LIBS -lpsapi"
+fi
+rm -f test_psapi*
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if we have getaddrinfo
+dnl ---------------------------------------------------------------------------
+
+echo "#include <sys/types.h>" > test_getaddrinfo.c
+echo "#include <sys/socket.h>" >> test_getaddrinfo.c
+echo "#include <netdb.h>" >> test_getaddrinfo.c
+echo "void test() { getaddrinfo(0,0,0,0); }"  >> test_getaddrinfo.c
+
+HAVE_GETADDRINFO=NO
+if test -z "`${CC} -c test_getaddrinfo.c 2>&1`" ; then
+  AC_DEFINE_UNQUOTED(HAVE_GETADDRINFO,1, [Define to 1 if you have the `getaddrinfo' function.])
+fi
+rm -f test_getaddrinfo*
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests hiding internal symbols
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(hide_internal_symbols,[  --with-hide-internal-symbols[=ARG] Try to hide internal symbols (ARG=yes/no)],,)
+
+HAVE_HIDE_INTERNAL_SYMBOLS=no
+
+if test "$with_hide_internal_symbols" = "yes"; then
+
+    AC_MSG_CHECKING([whether we should hide internal symbols])
+
+    rm -f hiddensymbols.c
+    echo 'int visible() { return 0; } __attribute__ ((visibility("default")))' >> hiddensymbols.c
+    echo 'int hidden() { return 0; }' >> hiddensymbols.c
+    if test -z "`${CC} -fvisibility=hidden -c hiddensymbols.c 2>&1`" ; then
+      HAVE_HIDE_INTERNAL_SYMBOLS=yes
+    else
+      HAVE_HIDE_INTERNAL_SYMBOLS=no
+    fi
+    if test "$HAVE_HIDE_INTERNAL_SYMBOLS" = "yes"; then
+        AC_MSG_RESULT([yes])
+        CFLAGS="$CFLAGS -fvisibility=hidden"
+        CXXFLAGS="$CXXFLAGS -fvisibility=hidden"
+        CFLAGS_NOFTRAPV="$CFLAGS_NOFTRAPV -fvisibility=hidden"
+        CXXFLAGS_NOFTRAPV="$CXXFLAGS_NOFTRAPV -fvisibility=hidden"
+        CXXFLAGS_NO_LTO_IF_AVX_NONDEFAULT="$CXXFLAGS_NO_LTO_IF_AVX_NONDEFAULT -fvisibility=hidden"
+        CXXFLAGS_NO_LTO_IF_SSSE3_NONDEFAULT="$CXXFLAGS_NO_LTO_IF_SSSE3_NONDEFAULT -fvisibility=hidden"
+    else
+        AC_MSG_RESULT([no])
+    fi
+    rm -f hiddensymbols.*
+else
+  AC_MSG_CHECKING([whether we should hide internal symbols])
+  AC_MSG_RESULT([no])
+fi
+
+if test "$HAVE_HIDE_INTERNAL_SYMBOLS" = "yes" ; then
+  AC_DEFINE_UNQUOTED(USE_GCC_VISIBILITY_FLAG,1, [Define to 1 if you want to use the -fvisibility GCC flag])
+fi
+
+AC_SUBST(HAVE_HIDE_INTERNAL_SYMBOLS,$HAVE_HIDE_INTERNAL_SYMBOLS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests renaming internal libtiff symbols
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rename_internal_libtiff_symbols,[  --with-rename-internal-libtiff-symbols[=ARG] Prefix internal libtiff symbols with gdal_ (ARG=yes/no)],,)
+
+RENAME_INTERNAL_LIBTIFF_SYMBOLS=no
+if test "x$with_rename_internal_libtiff_symbols" = "xyes" -o "x$with_rename_internal_libtiff_symbols" = "x"; then
+  RENAME_INTERNAL_LIBTIFF_SYMBOLS=yes
+fi
+
+AC_SUBST(RENAME_INTERNAL_LIBTIFF_SYMBOLS,$RENAME_INTERNAL_LIBTIFF_SYMBOLS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests renaming internal libgeotiff symbols
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rename_internal_libgeotiff_symbols,[  --with-rename-internal-libgeotiff-symbols[=ARG] Prefix internal libgeotiff symbols with gdal_ (ARG=yes/no)],,)
+
+RENAME_INTERNAL_LIBGEOTIFF_SYMBOLS=no
+if test "x$with_rename_internal_libgeotiff_symbols" = "xyes" -o "x$with_rename_internal_libgeotiff_symbols" = "x"; then
+   RENAME_INTERNAL_LIBGEOTIFF_SYMBOLS=yes
+fi
+
+AC_SUBST(RENAME_INTERNAL_LIBGEOTIFF_SYMBOLS,$RENAME_INTERNAL_LIBGEOTIFF_SYMBOLS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests renaming internal shapelib symbols
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rename_internal_shapelib_symbols,[  --with-rename-internal-shapelib-symbols[=ARG] Prefix internal shapelib symbols with gdal_ (ARG=yes/no)],,)
+
+RENAME_INTERNAL_SHAPELIB_SYMBOLS=no
+if test "x$with_rename_internal_shapelib_symbols" = "xyes" -o "x$with_rename_internal_shapelib_symbols" = "x"; then
+    RENAME_INTERNAL_SHAPELIB_SYMBOLS=yes
+fi
+AC_SUBST(RENAME_INTERNAL_SHAPELIB_SYMBOLS,$RENAME_INTERNAL_SHAPELIB_SYMBOLS)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests /usr/local to be included.
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([for local include/lib path])
+
+AC_ARG_WITH(local,[  --with-local[=dir]      Include /usr/local or other local tree for INCLUDE/LIBS],,)
+
+if test "$with_local" != "no" -a "$with_local" != "" ; then
+
+  if test "$with_local" = "yes" ; then
+    ADD_PREFIX=/usr/local
+  else
+    ADD_PREFIX=$with_local
+  fi
+
+  AC_MSG_RESULT(adding $ADD_PREFIX)
+
+  LIBS="$LIBS -L$ADD_PREFIX/lib"
+  CPPFLAGS="$CPPFLAGS -I$ADD_PREFIX/include"
+else
+  AC_MSG_RESULT([none])
+fi
+
+dnl ---------------------------------------------------------------------
+dnl ENABLE THREADS ONLY IF REQUESTED.
+dnl ---------------------------------------------------------------------
+
+THREAD_LIB=""
+THREAD_FLAG=""
+PTHREAD_ENABLED="no"
+
+AC_ARG_WITH(threads,
+[  --with-threads[=ARG]    Include thread safe support (ARG=yes(default), no or linkopt)],,)
+
+if test "$with_threads" = "yes" -o "$with_threads" = "" ; then
+
+  AC_CHECK_LIB(pthread,pthread_create,THREAD_FLAG=CPL_MULTIPROC_PTHREAD,,,)
+
+  if test -n "$THREAD_FLAG" ; then
+      THREAD_LIB="-lpthread"
+  else
+    # For Android, pthread_create is in Bionic libc
+    unset ac_cv_lib_pthread_pthread_create
+    AC_CHECK_LIB(c,pthread_create,THREAD_FLAG=CPL_MULTIPROC_PTHREAD,,,)
+  fi
+
+  AC_MSG_CHECKING([for PTHREAD_MUTEX_RECURSIVE])
+
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define _GNU_SOURCE
+#include <pthread.h>
+  ]], [[
+    return (PTHREAD_MUTEX_RECURSIVE);
+  ]])],[
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_PTHREAD_MUTEX_RECURSIVE, 1,
+          [Define to 1 if you have the `PTHREAD_MUTEX_RECURSIVE' constant.])
+  ],[
+    AC_MSG_RESULT([no])
+  ])
+
+
+
+  AC_MSG_CHECKING([for PTHREAD_MUTEX_ADAPTIVE_NP])
+
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define _GNU_SOURCE
+#include <pthread.h>
+  ]], [[
+    return PTHREAD_MUTEX_ADAPTIVE_NP;
+  ]])],[
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_PTHREAD_MUTEX_ADAPTIVE_NP, 1,
+          [Define to 1 if you have the `PTHREAD_MUTEX_ADAPTIVE_NP' constant.])
+  ],[
+    AC_MSG_RESULT([no])
+  ])
+
+  AC_MSG_CHECKING([for pthread_spinlock_t])
+
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define _GNU_SOURCE
+#include <pthread.h>
+  ]], [[
+    pthread_spinlock_t spin;
+    return 1;
+  ]])],[
+    AC_MSG_RESULT([yes])
+    AC_DEFINE_UNQUOTED(HAVE_PTHREAD_SPINLOCK, 1,
+          [Define to 1 if you have the `pthread_spinlock_t' type.])
+  ],[
+    AC_MSG_RESULT([no])
+  ])
+
+elif test "$with_threads" != "no" ; then
+
+  THREAD_FLAG=CPL_MULTIPROC_PTHREAD
+  THREAD_LIB="$with_threads"
+
+  AS_MESSAGE([checking whether we should include thread/mutex support......])
+  AC_MSG_RESULT([        using threads with link options "$THREAD_LIB".])
+
+else
+  AS_MESSAGE([checking whether we should include thread/mutex support......])
+  AC_MSG_RESULT([        thread safe support disabled.])
+fi
+
+if test "$THREAD_FLAG" = "CPL_MULTIPROC_PTHREAD" ; then
+  AC_DEFINE_UNQUOTED(CPL_MULTIPROC_PTHREAD,1, [Define if you want to use pthreads based multiprocessing support])
+  PTHREAD_ENABLED="yes"
+fi
+
+LIBS="$THREAD_LIB $LIBS"
+
+dnl ---------------------------------------------------------------------------
+dnl Check if mremap() with 5 args is available
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([for 5 args mremap()])
+
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define _GNU_SOURCE
+#include <sys/mman.h>
+]], [[
+return (mremap(0,0,0,0,0));
+]])],[
+AC_MSG_RESULT([yes])
+AC_DEFINE_UNQUOTED(HAVE_5ARGS_MREMAP, 1,
+        [Define to 1 if you have the 5 args `mremap' function.])
+],[
+AC_MSG_RESULT([no])
+])
+
+dnl ---------------------------------------------------------------------------
+dnl Check if _SC_PHYS_PAGES is available
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([for _SC_PHYS_PAGES])
+
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <unistd.h>
+]], [[
+return (sysconf(_SC_PHYS_PAGES));
+]])],[
+AC_MSG_RESULT([yes])
+AC_DEFINE_UNQUOTED(HAVE_SC_PHYS_PAGES, 1,
+        [Define to 1 if you have the _SC_PHYS_PAGES' constant.])
+],[
+AC_MSG_RESULT([no])
+])
+
+dnl '---------------------------------------------------------------------------
+dnl Remove possible system library paths from a *_LIB variable to prevent other, perhaps unrelated, system libraries
+dnl from shadowing custom libraries of the same name the user might have installed e.g. under /usr/local.
+dnl System library paths are things like /lib, /usr/lib, /lib64, /usr/lib64, and /usr/lib/x86_64-linux-gnu.
+dnl There may be others as well, that will need be addressed as they arise. We avoid wildcards such as
+dnl /usr/lib/* to avoid potential cases such as /usr/lib/mysql/lib, which might not have an /etc/ld.so.conf.d
+dnl entry and would not shadow any possible custom installs anyway:
+
+AC_DEFUN([STRIP_SYSTEM_LIBRARY_PATHS],[
+    if echo "x" | sed -E "s/x/y/" >/dev/null 2>/dev/null; then
+        STRIPPED_LIBRARY_NAME="$(echo [$1] | sed -E 's:-L/(usr/)?(lib(64)?|lib/x86_64-linux-gnu)/*[[[:space:]]]+::')"
+    elif echo "x" | sed -r "s/x/y/" >/dev/null 2>/dev/null; then
+        dnl Compatibility with older GNU sed that doesn't support -E
+        STRIPPED_LIBRARY_NAME="$(echo [$1] | sed -r 's:-L/(usr/)?(lib(64)?|lib/x86_64-linux-gnu)/*[[[:space:]]]+::')"
+    else
+        STRIPPED_LIBRARY_NAME="$(echo [$1])"
+    fi
+])
+
+dnl ---------------------------------------------------------------------------
+dnl Check if libz is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(libz,[  --with-libz[=ARG]       Include libz support (ARG=internal or libz directory)],,)
+
+if test "$with_libz" = "external" -o "$with_libz" = "" -o "$with_libz" = "yes" ; then
+
+  AC_CHECK_LIB(z,deflateInit_,LIBZ_SETTING=external,LIBZ_SETTING=internal,)
+
+  if test "$LIBZ_SETTING" = "external" ; then
+    AC_CHECK_LIB(z,inflateCopy,LIBZ_SETTING=external,LIBZ_SETTING=internal,)
+    if test "$LIBZ_SETTING" = "external" ; then
+        AC_MSG_RESULT([using pre-installed libz])
+    else
+        AC_MSG_RESULT([using internal libz code as inflateCopy is missing])
+    fi
+  else
+    AC_MSG_RESULT([using internal libz code as deflateInit_ is missing])
+  fi
+
+elif test "$with_libz" != "no" -a "$with_libz" != "internal" ; then
+
+  LIBS="-L$with_libz -L$with_libz/lib $LIBS"
+
+  AC_CHECK_LIB(z,deflateInit_,LIBZ_SETTING=external,LIBZ_SETTING=internal,-L$with_libz -L$with_libz/lib -lz)
+  if test "$LIBZ_SETTING" = "external" ; then
+    AC_CHECK_LIB(z,inflateCopy,LIBZ_SETTING=external,LIBZ_SETTING=internal,-L$with_libz -L$with_libz/lib -lz)
+     if test "$LIBZ_SETTING" = "external" ; then
+        AC_MSG_RESULT([using libz library from $with_libz])
+    else
+        AC_MSG_RESULT([using internal libz code as inflateCopy from $with_libz is missing])
+    fi
+  else
+    AC_MSG_RESULT([using internal libz code as deflateInit_ from $with_libz is missing])
+  fi
+
+fi
+
+if test "$LIBZ_SETTING" = "external" ; then
+  LIBS="-lz $LIBS"
+  if test "$with_libz" != "" -a "$with_libz" != "yes" -a "$with_libz" != "external" ; then
+    EXTRA_INCLUDES="-I$with_libz -I$with_libz/include $EXTRA_INCLUDES"
+  fi
+elif test "$with_libz" = "no" ; then
+  LIBZ_SETTING=no
+  AC_MSG_RESULT([not using libz at all.])
+else
+  LIBZ_SETTING=internal
+  OPT_GDAL_FORMATS="zlib $OPT_GDAL_FORMATS"
+  AC_MSG_RESULT([using internal libz code.])
+fi
+
+AC_SUBST(LIBZ_SETTING,$LIBZ_SETTING)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for libdeflate.
+dnl ---------------------------------------------------------------------------
+
+LIBDEFLATE_SETTING=no
+
+AC_ARG_WITH(libdeflate,
+            AS_HELP_STRING([--with-libdeflate],
+                            [enable libdeflate usage (optional for faster Deflate support (still requires zlib) (ARG=yes/no/prefix), enabled by default)]),,)
+
+if test "$with_libdeflate" != "no" ; then
+
+  if test "$with_libdeflate" != "" -a "$with_libdeflate" != "yes"; then
+    AC_CHECK_LIB(deflate, libdeflate_zlib_decompress, [libdeflate_lib=yes], [libdeflate_lib=no],-L$with_libdeflate/lib)
+  else
+    AC_CHECK_LIB(deflate, libdeflate_zlib_decompress, [libdeflate_lib=yes], [libdeflate_lib=no])
+  fi
+
+  if test "$libdeflate_lib" = "no" -a "$with_libdeflate" = "yes"; then
+    AC_MSG_ERROR([libdeflate library not found])
+  fi
+
+  if test "$with_libdeflate" != "" -a "$with_libdeflate" != "yes"; then
+    if test -r "$with_libdeflate/include/libdeflate.h" ; then
+      libdeflate_h=yes
+    else
+      libdeflate_h=no
+    fi
+  else
+    AC_CHECK_HEADER(libdeflate.h, [libdeflate_h=yes], [libdeflate_h=no])
+  fi
+  if test "$libdeflate_h" = "no" -a "$with_libdeflate" = "yes"; then
+    AC_MSG_ERROR([libdeflate headers not found])
+  fi
+
+  if test "$libdeflate_lib" = "yes" -a "$libdeflate_h" = "yes" ; then
+    LIBDEFLATE_SETTING=yes
+  fi
+
+fi
+
+if test "$LIBDEFLATE_SETTING" = "yes" ; then
+  if test "$with_libdeflate" != "" -a "$with_libdeflate" != "yes"; then
+    EXTRA_INCLUDES="-I$with_libdeflate/include $EXTRA_INCLUDES"
+    LIBS="-L$with_libdeflate/lib -ldeflate $LIBS"
+  else
+    LIBS="-ldeflate $LIBS"
+  fi
+fi
+
+AC_SUBST(LIBDEFLATE_SETTING,$LIBDEFLATE_SETTING)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for iconv/libiconv.
+dnl A rationale for this macro is described in "GNU `gettext' utilities"
+dnl manual at
+dnl http://www.gnu.org/software/gettext/manual/html_node/AM_005fICONV.html
+dnl ---------------------------------------------------------------------------
+AM_ICONV
+
+dnl Extra test needed for GCC 4.5 on Solaris 11, where there is
+dnl a different behavior if the tests are compiled with gcc or g++.
+dnl So we introduce a ICONV_CPP_CONST that must be used instead of
+dnl ICONV_CONST when used from .cpp files.
+if test "$am_func_iconv" = "yes"; then
+    rm -f testiconv.*
+    echo '#include <iconv.h>' > testiconv.cpp
+    echo 'int main(int argc, char** argv) { iconv_t cd = 0; return iconv (cd, (const char **) 0, 0, 0, 0); } ' >> testiconv.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testiconv.cpp -c 2>&1`" ; then
+        AC_MSG_RESULT([using ICONV_CPP_CONST="const"])
+        ICONV_CPP_CONST="const"
+    else
+        AC_MSG_RESULT([using ICONV_CPP_CONST=""])
+        ICONV_CPP_CONST=""
+    fi
+    rm -f testiconv.*
+
+    AC_DEFINE_UNQUOTED(ICONV_CPP_CONST,$ICONV_CPP_CONST, [For.cpp files, define as const if the declaration of iconv() needs const.])
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Bash completions
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([bash-completion],
+  AS_HELP_STRING([--with-bash-completion[=ARG]],
+    [Install Bash completions (ARG=yes or path)]),,)
+
+if test "x$with_bash_completion" = "xno" -o "x$with_bash_completion" = "x"; then
+  AC_MSG_NOTICE([Bash completions not requested])
+elif test "x$with_bash_completion" = "xyes"; then
+  PKG_CHECK_VAR(bashcompdir, [bash-completion], [completionsdir], ,
+    bashcompdir="${sysconfdir}/bash_completion.d")
+  AC_SUBST(bashcompdir)
+else
+  AC_SUBST(bashcompdir, $with_bash_completion)
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select a JPEG Library to use, or disable driver.
+dnl libtiff could depend on it so it must appear before.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(jpeg,[  --with-jpeg[=ARG]       Include JPEG support (ARG=internal, no or path)],,)
+
+if test "$with_jpeg" = "no" ; then
+
+  JPEG_SETTING=no
+
+  echo "jpeg support disabled."
+
+elif test "$with_jpeg" = "yes" -o "$with_jpeg" = "" ; then
+
+  AC_CHECK_LIB(jpeg,jpeg_read_scanlines,JPEG_SETTING=external,JPEG_SETTING=internal,)
+  AC_CHECK_HEADERS(jpeglib.h)
+
+  if test "$JPEG_SETTING" = "external" -a "$ac_cv_header_jpeglib_h" = "no" ; then
+    JPEG_SETTING=internal
+  fi
+
+  if test "$JPEG_SETTING" = "external" -a "$TIFF_SETTING" = "internal" ; then
+    AC_MSG_CHECKING([for width_in_blocks in jpeglib.h])
+
+    rm -f conftest.c
+    echo '#include <stdio.h>' >> conftest.c
+    echo '#include "jpeglib.h"' >> conftest.c
+    echo 'int main() { jpeg_component_info *comptr=0; int i; i = comptr->width_in_blocks; }' >> conftest.c
+    if test -z "`${CC} ${CPPFLAGS} ${CFLAGS} -c conftest.c 2>&1`" ; then
+      AC_MSG_RESULT([yes])
+    else
+      AC_MSG_RESULT([no])
+      JPEG_SETTING=internal
+    fi
+    rm -f conftest*
+  fi
+
+  if test "$JPEG_SETTING" = "external" ; then
+    LIBS="-ljpeg $LIBS"
+    echo "using pre-installed libjpeg."
+  else
+    echo "using internal jpeg code."
+  fi
+
+elif test "$with_jpeg" = "internal" ; then
+
+  JPEG_SETTING=internal
+
+  echo "using internal jpeg code."
+
+else
+
+  JPEG_SETTING=external
+  LIBS="-L$with_jpeg -L$with_jpeg/lib -ljpeg $LIBS"
+  EXTRA_INCLUDES="-I$with_jpeg -I$with_jpeg/include $EXTRA_INCLUDES"
+
+  echo "using libjpeg from $with_jpeg."
+
+fi
+
+AC_SUBST(JPEG_SETTING,$JPEG_SETTING)
+
+if test "$JPEG_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="jpeg $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests renaming internal libjpeg symbols
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rename_internal_libjpeg_symbols,[  --with-rename-internal-libjpeg-symbols[=ARG] Prefix internal libjpeg symbols with gdal_ (ARG=yes/no)],,)
+
+RENAME_INTERNAL_LIBJPEG_SYMBOLS=no
+if test "x$with_rename_internal_libjpeg_symbols" = "xyes" -o "x$with_rename_internal_libjpeg_symbols" = "x"; then
+    RENAME_INTERNAL_LIBJPEG_SYMBOLS=yes
+fi
+
+AC_SUBST(RENAME_INTERNAL_LIBJPEG_SYMBOLS,$RENAME_INTERNAL_LIBJPEG_SYMBOLS)
+
+dnl ---------------------------------------------------------------------------
+dnl Select a libtiff library to use.
+dnl Proj depends on it so it must appear before.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(libtiff,[  --with-libtiff=ARG    Libtiff library to use (ARG=internal, yes or path)],,)
+
+AC_MSG_CHECKING([for libtiff])
+
+if test "x${with_libtiff}" = "xyes" -o "x${with_libtiff}" = "x" ; then
+
+  dnl Only automatically pick up the external libtiff if it is >= 4.0.
+  AC_CHECK_LIB(tiff,TIFFScanlineSize64,TIFF_SETTING=external HAVE_BIGTIFF=yes,TIFF_SETTING=internal HAVE_BIGTIFF=yes,)
+
+  if test "$TIFF_SETTING" = "external" ; then
+    LIBS="-ltiff $LIBS"
+    AC_MSG_RESULT([using pre-installed libtiff.])
+  else
+    AC_MSG_RESULT([using internal TIFF code.])
+  fi
+
+elif test "x${with_libtiff}" = "xno" ; then
+
+  AC_MSG_ERROR([libtiff is a required dependency])
+
+elif test "x${with_libtiff}" = "xinternal" ; then
+
+  TIFF_SETTING=internal
+  HAVE_BIGTIFF=yes
+
+  AC_MSG_RESULT([using internal TIFF code.])
+
+else
+
+  TIFF_SETTING=external
+  if test -r "$with_libtiff/tiff.h" ; then
+    LIBS="-L$with_libtiff -ltiff $LIBS"
+    EXTRA_INCLUDES="-I$with_libtiff $EXTRA_INCLUDES"
+  else
+    LIBS="-L$with_libtiff/lib -ltiff $LIBS"
+    EXTRA_INCLUDES="-I$with_libtiff/include $EXTRA_INCLUDES"
+  fi
+
+  AC_MSG_RESULT([using libtiff from ${with_libtiff}.])
+
+  dnl Check for the BigTIFF enabled library (libtiff >= 4.0)
+  AC_CHECK_LIB(tiff,TIFFScanlineSize64,HAVE_BIGTIFF=yes,HAVE_BIGTIFF=no,)
+
+fi
+
+if test "${HAVE_BIGTIFF}" != "yes" ; then
+  AC_MSG_ERROR([libtiff >= 4.0 is required.])
+fi
+
+AC_SUBST(TIFF_SETTING,${TIFF_SETTING})
+
+dnl ---------------------------------------------------------------------------
+dnl Check for curl (i.e. for wcs).
+dnl Proj depends on it so it must appear before.
+dnl ---------------------------------------------------------------------------
+CURL_SETTING=no
+CURL_INC=
+CURL_LIB=
+
+AC_ARG_WITH(curl,
+    [  --with-curl[=ARG]       Include curl (ARG=path to curl-config.)],,,)
+
+dnl Clear some cache variables
+unset ac_cv_path_LIBCURL
+
+if test "`basename xx/$with_curl`" = "curl-config" ; then
+  LIBCURL_CONFIG="$with_curl"
+elif test "$with_curl" = "no" ; then
+  LIBCURL_CONFIG=no
+else
+  AC_PATH_PROG(LIBCURL_CONFIG, curl-config, no)
+fi
+
+if test "$LIBCURL_CONFIG" != "no" ; then
+
+  CURL_VERNUM=`$LIBCURL_CONFIG --vernum`
+  CURL_VER=`$LIBCURL_CONFIG --version | awk '{print $2}'`
+
+  AC_MSG_RESULT([        found libcurl version $CURL_VER])
+
+  AC_CHECK_LIB(curl,curl_global_init,CURL_SETTING=yes,CURL_SETTING=no,`$LIBCURL_CONFIG --libs`)
+
+fi
+
+AC_SUBST(CURL_SETTING,$CURL_SETTING)
+AC_SUBST(CURL_INC,    $CURL_INC)
+AC_SUBST(CURL_LIB,    $CURL_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for SQLite
+dnl Proj depends on it so it must appear before.
+dnl ---------------------------------------------------------------------------
+
+SQLITE3_REQ_VERSION="3.0.0"
+AX_LIB_SQLITE3($SQLITE3_REQ_VERSION)
+
+if test "$HAVE_SQLITE3" = "yes"; then
+    LIBS="$SQLITE3_LDFLAGS $LIBS"
+    AC_CHECK_LIB(sqlite3,sqlite3_column_table_name,SQLITE_HAS_COLUMN_METADATA=yes,SQLITE_HAS_COLUMN_METADATA=no,$LIBS)
+fi
+
+AC_SUBST([SQLITE_INC], $SQLITE3_CFLAGS)
+AC_SUBST([HAVE_SQLITE], $HAVE_SQLITE3)
+AC_SUBST([SQLITE_HAS_COLUMN_METADATA], $SQLITE_HAS_COLUMN_METADATA)
+HAVE_SQLITE=$HAVE_SQLITE3
+
+dnl ---------------------------------------------------------------------------
+dnl PROJ.6 related stuff
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([for PROJ >= 6 library])
+
+AC_ARG_WITH(proj,[  --with-proj=ARG Compile with PROJ.x (ARG=yes or path)],,)
+
+AC_ARG_WITH(proj-extra-lib-for-test,
+    [  --with-proj-extra-lib-for-test=ARG   Additional libraries to pass the detection test, but not used for libgdal linking (i.e. -lcurl -ltiff ...). Mainly for static libproj],,,)
+
+PROJ_INCLUDE=""
+if test "x$with_proj" = "xno" ; then
+
+  AC_MSG_ERROR([PROJ >= 6 is a required dependency.])
+
+else
+
+  if test "x$with_proj" = "xyes" -o "x$with_proj" = "x"; then
+    ORIG_LIBS="$LIBS"
+    LIBS="-lproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+    AC_LANG_PUSH([C++])
+    AC_CHECK_LIB(proj,proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+    AC_LANG_POP([C++])
+    if test "$PROJ_FOUND" = "no"; then
+        AC_LANG_PUSH([C++])
+        AC_CHECK_LIB(proj,internal_proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+        AC_LANG_POP([C++])
+        if test "$PROJ_FOUND" = "yes"; then
+            PROJ_INCLUDE="-DPROJ_RENAME_SYMBOLS"
+        fi
+    fi
+    if test "$PROJ_FOUND" = "no"; then
+        LIBS="-linternalproj $ORIG_LIBS"
+        AC_LANG_PUSH([C++])
+        AC_CHECK_LIB(internalproj,internal_proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+        AC_LANG_POP([C++])
+        if test "$PROJ_FOUND" = "yes"; then
+            PROJ_INCLUDE="-DPROJ_RENAME_SYMBOLS"
+        fi
+    fi
+    if test "$PROJ_FOUND" = "no"; then
+        AC_MSG_ERROR([PROJ 6 symbols not found])
+    fi
+    AC_CHECK_HEADERS([proj.h])
+    if test "$ac_cv_header_proj_h" = "yes" ; then
+        AC_MSG_NOTICE([proj.h found])
+    else
+        AC_MSG_ERROR([proj.h not found])
+    fi
+  else
+    ORIG_LIBS="$LIBS"
+    LIBS="-L$with_proj/lib -lproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+    AC_LANG_PUSH([C++])
+    AC_CHECK_LIB(proj,proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+    AC_LANG_POP([C++])
+    if test "$PROJ_FOUND" = "no"; then
+        LIBS="-L$with_proj/lib -lproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+        unset ac_cv_lib_proj_proj_create_from_wkt
+        AC_LANG_PUSH([C++])
+        AC_CHECK_LIB(proj,proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+        AC_LANG_POP([C++])
+    fi
+    if test "$PROJ_FOUND" = "no"; then
+        LIBS="-L$with_proj/lib64 -lproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+        unset ac_cv_lib_proj_proj_create_from_wkt
+        AC_LANG_PUSH([C++])
+        AC_CHECK_LIB(proj,proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+        AC_LANG_POP([C++])
+    fi
+    if test "$PROJ_FOUND" = "no"; then
+        LIBS="-L$with_proj/lib -lproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+        AC_LANG_PUSH([C++])
+        AC_CHECK_LIB(proj,internal_proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+        AC_LANG_POP([C++])
+        if test "$PROJ_FOUND" = "no"; then
+            LIBS="-L$with_proj/lib -lproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+            unset ac_cv_lib_proj_internal_proj_create_from_wkt
+            AC_LANG_PUSH([C++])
+            AC_CHECK_LIB(proj,internal_proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+            AC_LANG_POP([C++])
+        fi
+        if test "$PROJ_FOUND" = "yes"; then
+            PROJ_INCLUDE="-DPROJ_RENAME_SYMBOLS"
+        fi
+    fi
+    if test "$PROJ_FOUND" = "no"; then
+        LIBS="-L$with_proj/lib -linternalproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+        AC_LANG_PUSH([C++])
+        AC_CHECK_LIB(internalproj,internal_proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+        AC_LANG_POP([C++])
+        if test "$PROJ_FOUND" = "no"; then
+            LIBS="-L$with_proj/lib -linternalproj $with_proj_extra_lib_for_test $ORIG_LIBS"
+            unset ac_cv_lib_internal_proj_internal_proj_create_from_wkt
+            AC_LANG_PUSH([C++])
+            AC_CHECK_LIB(internalproj,internal_proj_create_from_wkt,PROJ_FOUND=yes,PROJ_FOUND=no,)
+            AC_LANG_POP([C++])
+        fi
+        if test "$PROJ_FOUND" = "yes"; then
+            PROJ_INCLUDE="-DPROJ_RENAME_SYMBOLS"
+        fi
+    fi
+    if test "$PROJ_FOUND" = "no"; then
+        AC_MSG_ERROR([PROJ 6 symbols not found])
+    fi
+    if test -r "$with_proj/include/proj.h" ; then
+        PROJ_INCLUDE="$PROJ_INCLUDE -I$with_proj/include"
+        AC_MSG_NOTICE([proj.h found])
+    else
+        AC_MSG_ERROR([proj.h not found])
+    fi
+  fi
+fi
+
+AC_SUBST(PROJ_INCLUDE)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for SpatiaLite.
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING(for spatialite)
+
+AC_ARG_WITH(spatialite,
+    [  --with-spatialite=ARG Include SpatiaLite support (ARG=no(default), yes, dlopen (only supported for Spatialite >= 4.1.2) or path)],
+    ,,)
+
+AC_ARG_WITH(spatialite-soname,
+    [  --with-spatialite-soname=ARG Spatialite shared object name (e.g. libspatialite.so), only used if --with-spatialite=dlopen],
+    ,,)
+
+HAVE_SPATIALITE=no
+
+if test -z "$with_spatialite" -o "$with_spatialite" = "no"; then
+    AC_MSG_RESULT(disabled)
+elif test "$with_spatialite" = "yes"; then
+    AC_CHECK_HEADERS(sqlite3.h)
+    if test "$ac_cv_header_sqlite3_h" = "yes"; then
+        AC_MSG_CHECKING([for spatialite.h in /usr/include or /usr/local/include])
+        if test -f "/usr/include/spatialite.h" -o -f "/usr/local/include/spatialite.h"; then
+            AC_MSG_RESULT(found)
+            AC_CHECK_LIB(spatialite,spatialite_init,SPATIALITE_INIT_FOUND=yes,SPATIALITE_INIT_FOUND=no,-lsqlite3)
+            if test "$SPATIALITE_INIT_FOUND" = "yes"; then
+                HAVE_SPATIALITE=yes
+                SPATIALITE_LIBS="-lspatialite -lsqlite3"
+                LIBS="$LIBS $SPATIALITE_LIBS"
+                HAVE_SQLITE3=yes
+            fi
+        else
+            AC_MSG_RESULT(not found : spatialite support disabled)
+        fi
+    fi
+elif test "$with_spatialite" = "dlopen"; then
+  HAVE_SPATIALITE=dlopen
+  AC_MSG_RESULT(dlopen)
+
+  if test "$with_spatialite_soname" != ""; then
+      SPATIALITE_SONAME="$with_spatialite_soname"
+  else
+      SPATIALITE_SONAME="spatialite.so"
+  fi
+else
+    AC_CHECK_LIB(spatialite,spatialite_init,SPATIALITE_INIT_FOUND=yes,SPATIALITE_INIT_FOUND=no,-L$with_spatialite/lib -lspatialite)
+
+    if test -f "$with_spatialite/include/spatialite.h" -a \
+        "$SPATIALITE_INIT_FOUND" = "yes"; then
+
+        if test "$HAVE_SQLITE3" = "yes"; then
+            SPATIALITE_INC="-I$with_spatialite/include"
+            HAVE_SPATIALITE=yes
+            SPATIALITE_LIBS="-L$with_spatialite/lib -lspatialite"
+            LIBS="$SQLITE3_LDFLAGS $LIBS $SPATIALITE_LIBS"
+            AC_MSG_RESULT(spatialite enabled)
+        else
+            AC_MSG_RESULT(spatialite disabled)
+        fi
+    else
+        AC_MSG_RESULT(disabled)
+    fi
+fi
+
+if test "$HAVE_SPATIALITE" = "yes"; then
+    AC_CHECK_LIB(spatialite,spatialite_target_cpu,SPATIALITE_412_OR_LATER=yes,SPATIALITE_412_OR_LATER=no)
+fi
+
+AC_SUBST([HAVE_SPATIALITE], $HAVE_SPATIALITE)
+AC_SUBST([SPATIALITE_SONAME], $SPATIALITE_SONAME)
+AC_SUBST([SPATIALITE_INC], $SPATIALITE_INC)
+AC_SUBST([SPATIALITE_412_OR_LATER], $SPATIALITE_412_OR_LATER)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if liblzma is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(liblzma,[  --with-liblzma[=ARG]       Include liblzma support (ARG=yes/no)],,)
+
+if test "$with_liblzma" = "yes" ; then
+  AC_CHECK_LIB(lzma,lzma_code,LIBLZMA_SETTING=yes,LIBLZMA_SETTING=no,)
+  AC_CHECK_HEADERS(lzma.h)
+
+  if test "$LIBLZMA_SETTING" = "yes" -a "$ac_cv_header_lzma_h" = "yes" ; then
+    LIBS="-llzma $LIBS"
+  else
+    LIBLZMA_SETTING=no
+  fi
+else
+    LIBLZMA_SETTING=no
+fi
+
+AC_SUBST(LIBLZMA_SETTING,$LIBLZMA_SETTING)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if zstd is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(zstd,[  --with-zstd[=ARG]       Include zstd support (ARG=yes/no/installation_prefix)],,)
+
+if test "$with_zstd" = "" -o "$with_zstd" = "yes" ; then
+  AC_CHECK_LIB(zstd,ZSTD_decompressStream,ZSTD_SETTING=yes,ZSTD_SETTING=no,)
+
+  if test "$ZSTD_SETTING" = "yes" ; then
+    LIBS="-lzstd $LIBS"
+  else
+    if test "$with_zstd" = "yes" ; then
+      AC_MSG_ERROR([libzstd not found])
+    else
+      echo "libzstd not found - ZSTD support disabled"
+    fi
+  fi
+elif test "$with_zstd" != "" -a "$with_zstd" != "no"; then
+
+  AC_CHECK_LIB(zstd,ZSTD_decompressStream,ZSTD_SETTING=yes,ZSTD_SETTING=no,-L$with_zstd/lib)
+
+  if test "$ZSTD_SETTING" = "yes" -a -f "$with_zstd/include/zstd.h" ; then
+    LIBS="-L$with_zstd/lib -lzstd $LIBS"
+    EXTRA_INCLUDES="-I$with_zstd/include $EXTRA_INCLUDES"
+  else
+    AC_MSG_ERROR([libzstd not found])
+  fi
+
+else
+    ZSTD_SETTING=no
+fi
+
+AC_SUBST(ZSTD_SETTING,$ZSTD_SETTING)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if blosc is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(blosc,[  --with-blosc[=ARG]       Include blosc support (ARG=yes/no/installation_prefix)],,)
+
+if test "$with_blosc" = "" -o "$with_blosc" = "yes" ; then
+  AC_CHECK_LIB(blosc,blosc_cbuffer_validate,HAVE_BLOSC=yes,HAVE_BLOSC=no,)
+
+  if test "$HAVE_BLOSC" = "yes" ; then
+    LIBS="-lblosc $LIBS"
+  else
+    if test "$with_blosc" = "yes" ; then
+      AC_MSG_ERROR([libblosc not found])
+    else
+      echo "libblosc not found - BLOSC support disabled"
+    fi
+  fi
+elif test "$with_blosc" != "" -a "$with_blosc" != "no"; then
+
+  AC_CHECK_LIB(blosc,blosc_cbuffer_validate,HAVE_BLOSC=yes,HAVE_BLOSC=no,-L$with_blosc/lib)
+
+  if test "$HAVE_BLOSC" = "yes" -a -f "$with_blosc/include/blosc.h" ; then
+    LIBS="-L$with_blosc/lib -lblosc $LIBS"
+    EXTRA_INCLUDES="-I$with_blosc/include $EXTRA_INCLUDES"
+  else
+    AC_MSG_ERROR([libblosc not found])
+  fi
+
+else
+    HAVE_BLOSC=no
+fi
+
+AC_SUBST(HAVE_BLOSC,$HAVE_BLOSC)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if lz4 is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(lz4,[  --with-lz4[=ARG]       Include lz4 support (ARG=yes/no/installation_prefix)],,)
+
+if test "$with_lz4" = "" -o "$with_lz4" = "yes" ; then
+  AC_CHECK_LIB(lz4,LZ4_decompress_safe,HAVE_LZ4=yes,HAVE_LZ4=no,)
+
+  if test "$HAVE_LZ4" = "yes" ; then
+    LIBS="-llz4 $LIBS"
+  else
+    if test "$with_lz4" = "yes" ; then
+      AC_MSG_ERROR([liblz4 not found])
+    else
+      echo "liblz4 not found - LZ4 support disabled"
+    fi
+  fi
+elif test "$with_lz4" != "" -a "$with_lz4" != "no"; then
+
+  AC_CHECK_LIB(lz4,LZ4_decompress_safe,HAVE_LZ4=yes,HAVE_LZ4=no,-L$with_lz4/lib)
+
+  if test "$HAVE_LZ4" = "yes" -a -f "$with_lz4/include/lz4.h" ; then
+    LIBS="-L$with_lz4/lib -llz4 $LIBS"
+    EXTRA_INCLUDES="-I$with_lz4/include $EXTRA_INCLUDES"
+  else
+    AC_MSG_ERROR([liblz4 not found])
+  fi
+
+else
+    HAVE_LZ4=no
+fi
+
+AC_SUBST(HAVE_LZ4,$HAVE_LZ4)
+
+dnl ---------------------------------------------------------------------------
+dnl Set up drivers and formats
+dnl ---------------------------------------------------------------------------
+
+GDALFORMATS_ENABLED=
+GDALFORMATS_DISABLED=
+OGRFORMATS_ENABLED=
+OGRFORMATS_ENABLED_CFLAGS=
+OGRFORMATS_DISABLED=
+
+AC_DEFUN([INTERNAL_FORMATS],[aaigrid adrg aigrid airsar arg blx bmp bsb cals ceos ceos2 coasp cosar ctg dimap dted elas envisat ers esric fit gff gsg gxf hf2 idrisi ilwis iris iso8211 jaxapalsar jdem kmlsuperoverlay l1b leveller map mrf msgn ngsgeoid nitf northwood pds prf r raw rmf rs2 safe saga sdts sentinel2 sgi sigdem srtmhgt stacit stacta terragen tga til tsx usgsdem xpm xyz zarr zmap])
+AC_DEFUN([INTERNAL_OPT_FORMATS],[grib ozi pdf rik])
+AC_DEFUN([INTERNAL_DRIVERS],[avc cad csv dgn dxf edigeo flatgeobuf geoconcept georss gml gmt gpsbabel gpx jml mapml mvt ntf openfilegdb pgdump s57 selafin shape svg sxf tiger vdv wasp])dnl
+AC_DEFUN([CURL_FORMATS],[eeda plmosaic wcs wms wmts daas ogcapi])dnl
+AC_DEFUN([CURL_DRIVERS],[amigocloud carto csw elastic ngw plscenes wfs])dnl
+AC_DEFUN([SQLITE_FORMATS],[rasterlite mbtiles])dnl
+AC_DEFUN([SQLITE_DRIVERS],[gpkg vfk osm])dnl
+AC_DEFUN([EXPAT_DRIVERS],[ods xlsx lvbag])dnl
+AC_DEFUN([XERCES_DRIVERS],[nas ili gmlas])dnl
+AC_DEFUN([ODBC_DRIVERS],[odbc pgeo mssqlspatial])dnl
+
+AC_ARG_ENABLE(all-optional-drivers, AS_HELP_STRING([--disable-all-optional-drivers], [disable all non-mandatory internal drivers. Individual drivers can be added with --enable-driver-XXX]))
+if test "x$enable_all_optional_drivers" = "xno"; then :
+  all_drivers_disabled=yes
+else
+  all_drivers_disabled=no
+fi
+
+m4_define([ARG_DRIVER_ENABLED],[dnl
+cur_driver_enabled=yes
+requested=m4_join([_],[$enable_driver],$1)
+if test "$all_drivers_disabled" = "yes"; then :
+  if test "x$requested" = "xyes"; then :
+    cur_driver_enabled=yes
+  else
+    cur_driver_enabled=no
+  fi
+else
+  if test "x$requested" != "xno"; then :
+    cur_driver_enabled=yes
+  else
+    cur_driver_enabled=no
+  fi
+fi
+])
+
+
+
+m4_foreach_w([frmt], INTERNAL_FORMATS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  GDALFORMATS_DISABLED="$GDALFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],INTERNAL_OPT_FORMATS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt format support (enabled by default, requires dependency)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  GDALFORMATS_DISABLED="$GDALFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_define([_OGRDEFINE],[m4_join([],[-D],m4_toupper([$1]),[_ENABLED])])
+
+m4_foreach_w([frmt],INTERNAL_DRIVERS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+  OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+AC_DEFUN([INTERNAL_DRIVERS_WITH_SAME_NAME_AS_FORMAT],[idrisi pds sdts])dnl
+m4_foreach_w([frmt],INTERNAL_DRIVERS_WITH_SAME_NAME_AS_FORMAT,
+[
+driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+if test "x$driver_enabled" != "xno"; then :
+  OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+  OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+fi
+])
+
+m4_foreach_w([frmt],CURL_FORMATS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt format support (enabled by default, requires curl)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  GDALFORMATS_DISABLED="$GDALFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],CURL_DRIVERS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default, requires curl)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],SQLITE_FORMATS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt format support (enabled by default, requires sqlite3)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  GDALFORMATS_DISABLED="$GDALFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],SQLITE_DRIVERS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default, requires sqlite3)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],EXPAT_DRIVERS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default, requires expat)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],XERCES_DRIVERS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default, requires xerces-c)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+m4_foreach_w([frmt],ODBC_DRIVERS,
+[
+AC_ARG_ENABLE(driver-frmt, AS_HELP_STRING([--disable-driver-frmt], [disable frmt driver support (enabled by default, requires odbc)]))dnl
+ARG_DRIVER_ENABLED(frmt)
+if test "$cur_driver_enabled" = "yes"; then :
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=yes
+else
+  OGRFORMATS_DISABLED="$OGRFORMATS_DISABLED frmt"
+  m4_join([_],[INTERNAL_FORMAT],frmt,[ENABLED])=no
+fi
+])
+
+AC_SUBST(OGRFORMATS_ENABLED,$OGRFORMATS_ENABLED)
+AC_SUBST(OGRFORMATS_ENABLED_CFLAGS,$OGRFORMATS_ENABLED_CFLAGS)
+AC_SUBST(GDALFORMATS_ENABLED,$GDALFORMATS_ENABLED)
+
+if test "$LIBZ_SETTING" != "no" ; then
+  if test "x$INTERNAL_FORMAT_rik_ENABLED" = "xyes"; then
+      GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED rik"
+  fi
+  if test "x$INTERNAL_FORMAT_ozi_ENABLED" = "xyes"; then
+      GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED ozi"
+  fi
+fi
+
+if test "$CURL_SETTING" = "yes" ; then
+
+  CURL_INC=`$LIBCURL_CONFIG --cflags`
+  CURL_LIB=`$LIBCURL_CONFIG --libs`
+m4_foreach_w([frmt],CURL_FORMATS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED frmt"
+  fi
+])
+m4_foreach_w([frmt],CURL_DRIVERS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+    OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+  fi
+])
+
+fi
+
+if test "$HAVE_SQLITE3" = "yes"; then
+m4_foreach_w([frmt],SQLITE_FORMATS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED frmt"
+  fi
+])
+
+m4_foreach_w([frmt],SQLITE_DRIVERS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+    OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+  fi
+])
+
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select an PostgreSQL Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+PG_CONFIG=no
+
+AC_ARG_WITH(pg,
+	    AS_HELP_STRING([--with-pg[=ARG]],
+	       [Include PostgreSQL GDAL/OGR Support (ARG=yes,no)]),,)
+
+if test "x$with_pg" = "xyes" -o "x$with_pg" = "x" ; then
+  PG_CONFIG=yes
+elif test "x$with_pg" != "xno"; then
+  AC_MSG_ERROR([Only --with-pg=yes/no supported])
+fi
+
+AC_MSG_CHECKING([for PostgreSQL])
+
+if test "x$PG_CONFIG" = "xno" ; then
+
+  HAVE_PG=no
+  PG_LIB=
+  PG_INC=
+
+  AC_MSG_RESULT([no])
+
+else
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([PQ],[libpq > 9.1], [HAVE_PG=yes], [HAVE_PG=no])
+
+  if test "${HAVE_PG}" = "yes" ; then
+    PG_LIB="${PQ_LIBS}"
+    PG_INC="${PQ_CFLAGS}"
+    SAVED_LIBS="${LIBS}"
+    LIBS="${PG_LIB}"
+    AC_CHECK_LIB(pq,PQconnectdb,HAVE_PG=yes,HAVE_PG=no)
+    LIBS="${SAVED_LIBS}"
+    if test "${HAVE_PG}" = "yes" ; then
+      LIBS="${PG_LIB} ${LIBS}"
+    fi
+  else
+    if test "x$with_pg" = "xyes"; then
+      AC_MSG_ERROR([--with-pg was requested, but libpq is not available])
+    fi
+  fi
+
+fi
+
+AC_SUBST(HAVE_PG,$HAVE_PG)
+AC_SUBST(PG_INC,$PG_INC)
+AC_SUBST(PG_LIB,$PG_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if cfitsio library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(cfitsio,[  --with-cfitsio[=ARG]    Include FITS support (ARG=no or libcfitsio path)],,)
+
+if test "$with_cfitsio" = "no" ; then
+
+  FITS_SETTING=no
+
+  echo "FITS support disabled."
+
+elif test "$with_cfitsio" = "yes" -o "$with_cfitsio" = "" ; then
+
+  AC_CHECK_LIB(cfitsio,ffopen,FITS_SETTING=external,FITS_SETTING=no,)
+
+  if test "$FITS_SETTING" = "external" ; then
+    LIBS="-lcfitsio $LIBS"
+    echo "using pre-installed libcfitsio."
+  else
+    echo "libcfitsio not found - FITS support disabled"
+  fi
+
+dnl Fedora has cfitsio headers in /usr/include/cfitsio
+  if test "$FITS_SETTING" = "external" -a -d /usr/include/cfitsio ; then
+    EXTRA_INCLUDES="-I/usr/include/cfitsio $EXTRA_INCLUDES"
+  fi
+
+else
+
+  FITS_SETTING=external
+  LIBS="-L$with_cfitsio -L$with_cfitsio/lib -lcfitsio $LIBS"
+  EXTRA_INCLUDES="-I$with_cfitsio -I$with_cfitsio/include $EXTRA_INCLUDES"
+
+  echo "using libcfitsio from $with_cfitsio."
+fi
+
+AC_SUBST(FITS_SETTING,$FITS_SETTING)
+
+if test "$FITS_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="fits $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if PCRaster (libcsf) library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(pcraster,[  --with-pcraster[=ARG]   Include PCRaster (libcsf) support (ARG=internal, no or path)],,)
+
+if test "$with_pcraster" = "no" ; then
+
+  PCRASTER_SETTING=no
+
+  echo "PCRaster support disabled."
+
+elif test "$with_pcraster" = "yes" -o "$with_pcraster" = "" ; then
+
+  AC_CHECK_LIB(csf,Mopen,PCRASTER_SETTING=external,PCRASTER_SETTING=internal,$LIBS)
+  AC_CHECK_HEADERS(csf.h)
+
+  if test "$PCRASTER_SETTING" = "external" -a "$ac_cv_header_csf_h" = "no" ; then
+    PCRASTER_SETTING=internal
+  fi
+
+  if test "$PCRASTER_SETTING" = "external" ; then
+    LIBS="-lcsf $LIBS"
+    echo "using pre-installed libcsf."
+  else
+    echo "using internal csf code."
+  fi
+
+elif test "$with_pcraster" = "internal" ; then
+
+  PCRASTER_SETTING=internal
+
+  echo "using internal csf code."
+
+else
+
+  PCRASTER_SETTING=external
+  LIBS="-L$with_pcraster/lib -lcsf $LIBS"
+  EXTRA_INCLUDES="-I$with_pcraster/include $EXTRA_INCLUDES"
+
+  echo "using libcsf from $with_pcraster."
+
+fi
+
+AC_SUBST(PCRASTER_SETTING,$PCRASTER_SETTING)
+
+if test "$PCRASTER_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="pcraster $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select a PNG Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([png], [  --with-png[=ARG]        Include PNG support (ARG=internal, no or path)],,)
+
+AC_MSG_CHECKING([for libpng])
+
+if test "$with_png" = "no" ; then
+
+  PNG_SETTING=no
+
+  echo "png support disabled."
+
+elif test "$with_png" = "yes" -o "$with_png" = "" ; then
+
+  AC_CHECK_LIB([png], [png_set_IHDR], [PNG_SETTING=external], [PNG_SETTING=internal], [$LIBS])
+  AC_CHECK_HEADERS([png.h])
+
+  if test "$PNG_SETTING" = "external" -a "$ac_cv_header_png_h" = "no" ; then
+    PNG_SETTING=internal
+  fi
+  if test "$PNG_SETTING" = "external" ; then
+    LIBS="-lpng $LIBS"
+    echo "using pre-installed libpng."
+  else
+    echo "using internal png code."
+  fi
+
+elif test "$with_png" = "internal" ; then
+
+  PNG_SETTING=internal
+
+  echo "using internal png code."
+
+else
+
+  PNG_SETTING=external
+  LIBS="-L$with_png -L$with_png/lib -lpng $LIBS"
+  EXTRA_INCLUDES="-I$with_png -I$with_png/include $EXTRA_INCLUDES"
+
+  echo "using libpng from $with_png."
+
+fi
+
+AC_SUBST([PNG_SETTING], [$PNG_SETTING])
+
+if test "$PNG_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="png $OPT_GDAL_FORMATS"
+  if test "x$INTERNAL_FORMAT_grib_ENABLED" = "xyes"; then
+  	GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED grib"
+  fi
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if user requests renaming internal libpng symbols
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rename_internal_libpng_symbols,[  --with-rename-internal-libpng-symbols[=ARG] Prefix internal libpng symbols with gdal_ (ARG=yes/no)],,)
+
+RENAME_INTERNAL_PNG_SYMBOLS=no
+if test "x$with_rename_internal_libpng_symbols" = "xyes" -o "x$with_rename_internal_libpng_symbols" = "x"; then
+    RENAME_INTERNAL_PNG_SYMBOLS=yes
+fi
+
+AC_SUBST(RENAME_INTERNAL_PNG_SYMBOLS,$RENAME_INTERNAL_PNG_SYMBOLS)
+
+dnl ---------------------------------------------------------------------------
+dnl Enable DDS driver.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([dds], [  --with-dds[=ARG]        Include DDS support (ARG=no, or path)],,)
+
+AC_MSG_CHECKING([for libcrunch])
+
+if test "$with_dds" = "no" -o "$with_dds" = ""; then
+
+  DDS_SETTING="no"
+  CRUNCHDIR=""
+
+  echo "dds support disabled."
+
+else
+
+  DDS_SETTING=yes
+  CRUNCHDIR="$with_dds"
+  LIBS="-L$with_dds/lib/ -lcrunch $LIBS"
+  echo "using libcrunch from $with_dds."
+
+fi
+
+AC_SUBST(CRUNCHDIR,$CRUNCHDIR)
+AC_SUBST([DDS_SETTING], [$DDS_SETTING])
+
+if test "$DDS_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="dds $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if GTA library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([gta],[  --with-gta[=ARG]        Include GTA support (ARG=no or libgta tree prefix)],,)
+
+if test "$with_gta" = "no" ; then
+
+  GTA_SETTING=no
+
+  echo "GTA support disabled."
+
+elif test "$with_gta" = "yes" -o "$with_gta" = "" ; then
+
+  AC_CHECK_LIB([gta], [gta_version], [GTA_SETTING=yes], [GTA_SETTING=no],)
+
+  if test "$GTA_SETTING" = "yes" ; then
+    LIBS="-lgta $LIBS"
+    echo "using pre-installed libgta."
+  else
+    echo "libgta not found - GTA support disabled"
+  fi
+
+else
+
+  GTA_SETTING=yes
+  LIBS="-L$with_gta -L$with_gta/lib -lgta $LIBS"
+  EXTRA_INCLUDES="-I$with_gta -I$with_gta/include $EXTRA_INCLUDES"
+
+  echo "using libgta from $with_gta."
+fi
+
+AC_SUBST([GTA_SETTING], [$GTA_SETTING])
+
+if test "$GTA_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="gta $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select PCIDSK options.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([pcidsk], [  --with-pcidsk[=ARG]     Path to external PCIDSK SDK or internal (default)],,)
+
+AC_MSG_CHECKING([for PCIDSK])
+
+PCIDSK_LIB=
+PCIDSK_INCLUDE=
+
+if test "$with_pcidsk" = "no" ; then
+
+  PCIDSK_SETTING=no
+
+  echo "pcidsk support disabled."
+
+elif test "$with_pcidsk" = "" -o "$with_pcidsk" = "yes" -o "$with_pcidsk" = "internal" ; then
+
+  PCIDSK_SETTING=internal
+
+  echo "using internal libpcidsk."
+
+else
+
+  PCIDSK_SETTING=external
+  PCIDSK_LIB="-L$with_pcidsk/lib -lpcidsk"
+  PCIDSK_INCLUDE="-I$with_pcidsk/include -I$with_pcidsk/include/pcidsk"
+
+  echo "using libpcidsk from $with_pcidsk."
+
+fi
+
+if test "$with_pcidsk" != "no" ; then
+
+  AC_SUBST([PCIDSK_SETTING], [$PCIDSK_SETTING])
+  AC_SUBST([PCIDSK_LIB], [$PCIDSK_LIB])
+  AC_SUBST([PCIDSK_INCLUDE], [$PCIDSK_INCLUDE])
+
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select a libgeotiff library to use.
+dnl ---------------------------------------------------------------------------
+
+GEOTIFF_INCLUDE=
+AC_ARG_WITH(geotiff,[  --with-geotiff=ARG    Libgeotiff library to use (ARG=internal, yes or path)],,)
+
+if test "$with_geotiff" = "yes" -o "$with_geotiff" = "" ; then
+
+  if test "$TIFF_SETTING" = "internal" ; then
+    GEOTIFF_SETTING=internal
+  else
+    dnl We now require libgeotiff 1.5.0
+    AC_CHECK_LIB(geotiff,GTIFAttachPROJContext,GEOTIFF_SETTING=external,GEOTIFF_SETTING=internal)
+
+  fi
+
+  if test "$GEOTIFF_SETTING" = "external" ; then
+
+    dnl Now search for headers
+    if test -r /usr/include/geotiff.h ; then
+      GEOTIFF_INCLUDE=
+    dnl Debian (at least some versions of it) install in /usr/include/geotiff
+    elif test -r /usr/include/geotiff/geotiff.h ; then
+      GEOTIFF_INCLUDE="-I/usr/include/geotiff"
+    dnl Fedora and OpenSuse in /usr/include/libgeotiff (#4706)
+    elif test -r /usr/include/libgeotiff/geotiff.h ; then
+      GEOTIFF_INCLUDE="-I/usr/include/libgeotiff"
+    else
+      AC_CHECK_HEADERS([geotiff.h])
+      if test "$ac_cv_header_geotiff_h" = "no" ; then
+        AC_MSG_ERROR([cannot find geotiff.h])
+      fi
+    fi
+
+    LIBS="-lgeotiff $LIBS"
+    echo "using pre-installed libgeotiff."
+
+  else
+
+    echo "using internal GeoTIFF code."
+
+  fi
+
+elif test "$with_geotiff" = "internal" ; then
+
+  GEOTIFF_SETTING=internal
+
+  echo "using internal GeoTIFF code."
+
+elif test "x${with_geotiff}" = "xno" ; then
+
+  AC_MSG_ERROR([libgeotiff is a required dependency])
+
+else
+
+  GEOTIFF_SETTING=external
+
+  dnl We now require libgeotiff 1.5.0
+  dnl first check if $with_geotiff/lib has the library:
+  AC_CHECK_LIB(geotiff,GTIFAttachPROJContext,GEOTIFF_SETTING=external,GEOTIFF_SETTING=not_found,-L$with_geotiff/lib)
+
+  if test $GEOTIFF_SETTING = "external" ; then
+    LIBS="-L$with_geotiff/lib -lgeotiff $LIBS"
+    if test  -d $with_geotiff/include ; then
+      EXTRA_INCLUDES="-I$with_geotiff/include $EXTRA_INCLUDES"
+    fi
+  else
+    dnl check if $with_geotiff itself contains the header and library (e.g. as an uninstalled build directory would)
+    AC_CHECK_LIB(geotiff,GTIFAttachPROJContext,GEOTIFF_SETTING=external,AC_MSG_ERROR([We require at least GeoTIFF 1.5.0. Consider using the one supplied with GDAL]),-L$with_geotiff)
+    if test $GEOTIFF_SETTING = "external" ; then
+      LIBS="-L$with_geotiff -lgeotiff $LIBS"
+      EXTRA_INCLUDES="-I$with_geotiff $EXTRA_INCLUDES"
+    fi
+  fi
+
+  echo "using libgeotiff from $with_geotiff."
+fi
+
+AC_SUBST(GEOTIFF_SETTING,$GEOTIFF_SETTING)
+AC_SUBST(GEOTIFF_INCLUDE,$GEOTIFF_INCLUDE)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for JPEG 12 bit
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([jpeg12],
+	    AS_HELP_STRING([--without-jpeg12],
+	       [Disable JPEG 8/12bit TIFF support]),,)
+
+TIFF_JPEG12_ENABLED=no
+AC_MSG_CHECKING([for jpeg12])
+if test "$with_jpeg12" =  no ; then
+    JPEG12_ENABLED=no
+    AC_MSG_RESULT([disabled by user])
+
+elif test "$JPEG_SETTING" = "no" -a "$with_jpeg12" = ""; then
+    JPEG12_ENABLED=no
+    AC_MSG_RESULT([disabled, JPEG disabled])
+
+elif test "$TIFF_SETTING" = "internal" ; then
+    AC_MSG_RESULT([enabled])
+    JPEG12_ENABLED=yes
+    TIFF_JPEG12_ENABLED=yes
+
+else
+    AC_MSG_RESULT([enabled])
+    JPEG12_ENABLED=yes
+
+fi
+
+AC_SUBST(JPEG12_ENABLED,$JPEG12_ENABLED)
+AC_SUBST(TIFF_JPEG12_ENABLED,$TIFF_JPEG12_ENABLED)
+
+dnl ---------------------------------------------------------------------------
+dnl Select a GIF Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(gif,[  --with-gif[=ARG]        Include GIF support (ARG=internal, no or path)],,)
+
+if test "$with_gif" = "no" ; then
+
+  GIF_SETTING=no
+
+  echo "gif support disabled."
+
+elif test "$with_gif" = "yes" -o "$with_gif" = "" ; then
+
+  AC_CHECK_LIB(gif,DGifOpenFileName,GIF_SETTING=external,GIF_SETTING=internal,)
+  AC_CHECK_HEADERS(gif_lib.h)
+
+  if test "$GIF_SETTING" = "external" ; then
+    LIBS="-lgif $LIBS"
+    echo "using pre-installed libgif."
+  else
+    echo "using internal gif code."
+  fi
+
+elif test "$with_gif" = "internal" ; then
+
+  GIF_SETTING=internal
+
+  echo "using internal gif code."
+
+else
+
+  GIF_SETTING=external
+  LIBS="-L$with_gif -L$with_gif/lib -lgif $LIBS"
+  EXTRA_INCLUDES="-I$with_gif -I$with_gif/include $EXTRA_INCLUDES"
+
+  echo "using libgif from $with_gif."
+
+fi
+
+AC_SUBST(GIF_SETTING,$GIF_SETTING)
+
+if test "$GIF_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="gif $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select an OGDI Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+OGDI_INCLUDE=
+export OGDI_INCLUDE
+
+AC_ARG_WITH(ogdi,[  --with-ogdi[=ARG]       Include OGDI support (ARG=path)],,)
+
+if test "$with_ogdi" = "no" ; then
+
+  HAVE_OGDI=no
+
+  echo "ogdi support disabled."
+
+elif test "$with_ogdi" = "yes" -o "$with_ogdi" = "" ; then
+
+  PKG_CHECK_MODULES([OGDI], [ogdi], [HAVE_OGDI=yes], [:])
+  if test "$HAVE_OGDI" = yes; then
+    OGDI_INCLUDE=$OGDI_CFLAGS
+    LIBS="$OGDI_LIBS $LIBS"
+  else
+    AC_CHECK_HEADERS(ecs.h)
+    if test "$ac_cv_header_ecs_h" = "no" ; then
+      if test -f "/usr/include/ogdi/ecs.h"; then
+          OGDI_INCLUDE="-I/usr/include/ogdi"
+      elif test -f "/usr/local/include/ogdi/ecs.h"; then
+          OGDI_INCLUDE="-I/usr/local/include/ogdi"
+      elif test -f "/usr/include/ecs.h"; then
+          OGDI_INCLUDE="-I/usr/include"
+      elif test -f "/usr/local/include/ecs.h"; then
+          OGDI_INCLUDE="-I/usr/local/include"
+      fi
+    fi
+
+    if test "$OGDI_INCLUDE" != "" -o "$ac_cv_header_ecs_h" = "yes"; then
+      AC_CHECK_LIB(ogdi,cln_GetLayerCapabilities,HAVE_OGDI=yes,HAVE_OGDI=no,)
+      if test "$HAVE_OGDI" = "yes" ; then
+        LIBS="-logdi $LIBS"
+      else
+        dnl For backward compatibility. Retry with ogdi31 as a name
+        AC_CHECK_LIB(ogdi31,cln_GetLayerCapabilities,HAVE_OGDI=yes,HAVE_OGDI=no,)
+        if test "$HAVE_OGDI" = "yes" ; then
+          LIBS="-logdi31 $LIBS"
+        fi
+      fi
+    else
+      HAVE_OGDI=no
+    fi
+  fi
+
+else
+
+  AC_CHECK_LIB(ogdi,cln_GetLayerCapabilities,HAVE_OGDI=yes,HAVE_OGDI=no,-L$with_ogdi -L$with_ogdi/lib -logdi)
+  if test "$HAVE_OGDI" = "yes" ; then
+    if test -f "$with_ogdi/ecs.h" -o -f "$with_ogdi/include/ecs.h"; then
+        LIBS="-L$with_ogdi -L$with_ogdi/lib -logdi $LIBS"
+        OGDI_INCLUDE="-I$with_ogdi -I$with_ogdi/include"
+
+        echo "using libogdi from $with_ogdi."
+     else
+        HAVE_OGDI=no
+        AC_MSG_ERROR([ecs.h not found.])
+     fi
+  else
+    dnl For backward compatibility. Retry with ogdi31 as a name
+    AC_CHECK_LIB(ogdi31,cln_GetLayerCapabilities,HAVE_OGDI=yes,HAVE_OGDI=no,-L$with_ogdi -L$with_ogdi/lib -logdi31)
+    if test "$HAVE_OGDI" = "yes" ; then
+      if test -f "$with_ogdi/ecs.h" -o -f "$with_ogdi/include/ecs.h"; then
+        LIBS="-L$with_ogdi -L$with_ogdi/lib -logdi31 $LIBS"
+        OGDI_INCLUDE="-I$with_ogdi -I$with_ogdi/include"
+
+        echo "using libogdi31 from $with_ogdi."
+      else
+        HAVE_OGDI=no
+        AC_MSG_ERROR([ecs.h not found.])
+      fi
+    else
+      AC_MSG_ERROR([libogdi not found.])
+    fi
+  fi
+
+fi
+
+AC_SUBST(HAVE_OGDI,$HAVE_OGDI)
+AC_SUBST(OGDI_INCLUDE,$OGDI_INCLUDE)
+
+dnl ---------------------------------------------------------------------------
+dnl Select a SOSI lib to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(sosi,[  --with-sosi[=ARG]        Include SOSI support (ARG=SOSI lib Path, yes or no)],,)
+
+if test -z "$with_sosi" -o "$with_sosi" = "no" ; then
+
+  SOSI_ENABLED=no
+
+  echo "SOSI support disabled."
+
+elif test "$with_sosi" = "yes" ; then
+
+    AC_MSG_CHECKING([for libfyba])
+
+    rm -f testfyba.*
+    rm -f testfyba
+    echo "#include <fyba.h>" > testfyba.cpp
+    echo "int main() { LC_Init(); return 0; }" >> testfyba.cpp
+    if test  -r /usr/include/fyba -a -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -I/usr/include/fyba -DLINUX testfyba.cpp -lfyba -lfygm -lfyut -o testfyba 2>&1`" ; then
+        AC_MSG_RESULT([found])
+        SOSI_ENABLED=yes
+        SOSI_LIB="-lfyba -lfygm -lfyut"
+        SOSI_INC="-I/usr/include/fyba"
+    else
+        AC_MSG_RESULT([not found])
+        AC_MSG_CHECKING([for libfyba.a, libfygm.a and libfyut.a in /usr/local/lib])
+        if test -r /usr/local/lib/libfyba.a -a -r /usr/local/lib/libfygm.a -a -r /usr/local/lib/libfyut.a ; then
+            AC_MSG_RESULT([found])
+            SOSI_ENABLED=yes
+            SOSI_LIB="/usr/local/lib/libfyba.a /usr/local/lib/libfygm.a /usr/local/lib/libfyut.a"
+        else
+            AC_MSG_ERROR([not found.])
+        fi
+
+        AC_MSG_CHECKING([for fyba.h, fygm.h and fyut.h in /usr/local/include/fyba])
+        if test -r /usr/local/include/fyba/fyba.h -a -r /usr/local/include/fyba/fygm.h -a -r /usr/local/include/fyba/fyut.h ; then
+            AC_MSG_RESULT([found])
+            SOSI_ENABLED=yes
+            SOSI_INC="-I/usr/local/include/fyba"
+        else
+            AC_MSG_ERROR([not found.])
+        fi
+    fi
+
+    rm -f testfyba.*
+    rm -f testfyba
+else
+
+  AC_MSG_CHECKING([for libfyba.a, libfygm.a and libfyut.a in $with_sosi/lib])
+  if test -r $with_sosi/lib/libfyba.a -a -r $with_sosi/lib/libfygm.a -a -r $with_sosi/lib/libfyut.a ; then
+    AC_MSG_RESULT([found.])
+    SOSI_LIB="$with_sosi/lib/libfyba.a $with_sosi/lib/libfygm.a $with_sosi/lib/libfyut.a"
+    SOSI_ENABLED=yes
+  else
+    AC_MSG_ERROR([not found.])
+  fi
+
+  AC_MSG_CHECKING([for fyba.h in $with_sosi/include/fyba])
+  if test -r $with_sosi/include/fyba/fyba.h -a -r $with_sosi/include/fyba/fygm.h -a -r $with_sosi/include/fyba/fyut.h ; then
+    AC_MSG_RESULT([found.])
+    SOSI_INC="-I$with_sosi/include/fyba"
+    SOSI_ENABLED=yes
+  else
+    AC_MSG_ERROR([not found.])
+  fi
+
+fi
+
+AC_SUBST(SOSI_ENABLED, $SOSI_ENABLED)
+AC_SUBST(SOSI_LIB, $SOSI_LIB)
+AC_SUBST(SOSI_INC, $SOSI_INC)
+
+dnl ---------------------------------------------------------------------------
+dnl MongoCXXv3 driver
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(mongocxxv3,[  --with-mongocxxv3[=ARG]        Include MongoCXXv3 support (ARG=yes or no)],,)
+
+MONGOCXXV3_ENABLED=no
+
+if test "$with_mongocxxv3" = "no" ; then
+
+  echo "MONGODBv3 support disabled."
+
+elif test "$with_mongocxxv3" = "yes" -o "$with_mongocxxv3" = "" ; then
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([MONGOCXXV3], [libmongocxx >= 3.4.0], [MONGOCXXV3_ENABLED=yes], [MONGOCXXV3_ENABLED=no])
+
+  if test "$MONGOCXXV3_ENABLED" = "no" -a "$with_mongocxxv3" = "yes" ; then
+    AC_MSG_ERROR([mongocxxv3 requested but no found])
+  fi
+
+fi
+
+AC_SUBST(MONGOCXXV3_ENABLED, $MONGOCXXV3_ENABLED)
+AC_SUBST(MONGOCXXV3_LIBS, $MONGOCXXV3_LIBS)
+AC_SUBST(MONGOCXXV3_CFLAGS, $MONGOCXXV3_CFLAGS)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Select an HDF4 Library to use, or disable driver.
+dnl
+dnl We assume the user will have libjpeg and libz from other sources when
+dnl linking against static HDF4 libraries.
+dnl ---------------------------------------------------------------------------
+
+HDF4_INCLUDE=""
+
+AC_ARG_WITH(hdf4,[  --with-hdf4[=ARG]       Include HDF4 support (ARG=path)],,)
+
+if test x"$with_hdf4" = x"no" ; then
+
+  HAVE_HDF4=no
+
+  echo "hdf4 support disabled."
+
+else
+
+  if test x"$with_hdf4" = x"yes" -o x"$with_hdf4" = x"" ; then
+dnl Fedora has hdf static libraries in /usr/lib/hdf
+    if test -d /usr/lib64/hdf; then
+      HDF_LIB_DIR="/usr/lib64/hdf"
+    elif test -d /usr/lib/hdf; then
+      HDF_LIB_DIR="/usr/lib/hdf"
+    else
+      HDF_LIB_DIR=""
+    fi
+  else
+    if test -d $with_hdf4/lib ; then
+      HDF_LIB_DIR="$with_hdf4/lib"
+    else
+      HDF_LIB_DIR="$with_hdf4"
+    fi
+  fi
+
+  ORIG_LIBS="$LIBS"
+  if test "$HDF_LIB_DIR" != "" ; then
+    LIBS="-L$HDF_LIB_DIR $LIBS"
+  fi
+
+dnl Debian supplies the HDF4 library which does not conflict with NetCDF.
+dnl Test for Debian flavor first. Hint: install the libhdf4-alt-dev package.
+  AC_CHECK_LIB(mfhdfalt,SDreaddata,HDF_LIB_NAME="-lmfhdfalt -ldfalt",HDF_LIB_NAME=missing,-ldfalt)
+
+dnl If it fails, test again for normal libmfhdf/libdf
+  if test "$HDF_LIB_NAME" = "missing" ; then
+    unset ac_cv_lib_mfhdf_SDreaddata
+    AC_CHECK_LIB(mfhdf,SDreaddata,HDF_LIB_NAME="-lmfhdf -ldf",HDF_LIB_NAME=missing,-ldf)
+    if test "$HDF_LIB_NAME" = "missing" ; then
+      unset ac_cv_lib_mfhdf_SDreaddata
+      AC_CHECK_LIB(hdf4,SDreaddata,HDF_LIB_NAME=-lhdf4,HDF_LIB_NAME=missing,)
+    fi
+  fi
+
+dnl Test again, with -ldf, -ljpeg and -lz this time.
+  if test "$HDF_LIB_NAME" = "missing" ; then
+    unset ac_cv_lib_mfhdf_SDreaddata
+    AC_CHECK_LIB(mfhdf,SDreaddata,HDF_LIB_NAME="-lmfhdf -ldf",HDF_LIB_NAME=missing,-ldf -ljpeg -lz)
+  fi
+
+dnl Not found... again, with -lsz.
+  if test "$HDF_LIB_NAME" = "missing" ; then
+    unset ac_cv_lib_mfhdf_SDreaddata
+    AC_CHECK_LIB(mfhdf,SDreaddata,HDF_LIB_NAME="-lmfhdf -ldf -lsz",HDF_LIB_NAME=missing,-ldf -lsz -ljpeg -lz)
+  fi
+
+  if test "$HDF_LIB_NAME" != "missing" ; then
+
+    if test "$HDF_LIB_DIR" != "" ; then
+      LIBS="-L$HDF_LIB_DIR $HDF_LIB_NAME $ORIG_LIBS"
+    else
+      LIBS="$HDF_LIB_NAME $ORIG_LIBS"
+    fi
+
+    dnl HDF4 library newer than 4.2.5 has a SDreset_maxopenfiles/SDget_maxopenfiles interface
+    dnl which allows opening many HDF files simultaneously (the max number of files was previously
+    dnl hardcoded and too low, smth. like 32). Search for it and use if available.
+    AC_CHECK_LIB(mfhdfalt,SDget_maxopenfiles,HDF4_HAS_MAXOPENFILES=yes,HDF4_HAS_MAXOPENFILES=no,$HDF_LIB_NAME)
+    if test "$HDF4_HAS_MAXOPENFILES" = "no" ; then
+      AC_CHECK_LIB(mfhdf,SDget_maxopenfiles,HDF4_HAS_MAXOPENFILES=yes,HDF4_HAS_MAXOPENFILES=no,$HDF_LIB_NAME)
+    fi
+
+  dnl Now search for headers
+    if test "$with_hdf4" = "yes" -o "$with_hdf4" = "" -a -r /usr/include/hdf/hdf.h ; then
+      HDF4_INCLUDE="-I/usr/include/hdf"
+    elif test -r "$with_hdf4/hdf/hdf.h" ; then
+      HDF4_INCLUDE="-I$with_hdf4/hdf"
+    elif test -r "$with_hdf4/include/hdf/hdf.h" ; then
+      HDF4_INCLUDE="-I$with_hdf4/include/hdf"
+    elif test -r "$with_hdf4/include/hdf.h" ; then
+      HDF4_INCLUDE="-I$with_hdf4/include"
+    elif test -r "$with_hdf4/hdf.h" ; then
+      HDF4_INCLUDE="-I$with_hdf4"
+    fi
+
+    HAVE_HDF4=yes
+
+  else
+
+    if test x"$with_hdf4" != x"" ; then
+      AC_MSG_ERROR([HDF4 support requested with arg "$with_hdf4", but neither hdf4 nor mfhdf lib found])
+    else
+      LIBS="$ORIG_LIBS"
+      HAVE_HDF4=no
+    fi
+
+  fi
+
+fi
+
+AC_SUBST(HAVE_HDF4,$HAVE_HDF4)
+AC_SUBST(HDF4_INCLUDE,$HDF4_INCLUDE)
+AC_SUBST(HDF4_HAS_MAXOPENFILES,$HDF4_HAS_MAXOPENFILES)
+
+if test "$HAVE_HDF4" != "no" ; then
+  OPT_GDAL_FORMATS="hdf4 $OPT_GDAL_FORMATS"
+fi
+
+
+dnl ---------------------------------------------------------------------------
+dnl Select an HDF5 Library to use, or disable driver.
+dnl
+dnl ---------------------------------------------------------------------------
+
+HDF5_INCLUDE=""
+
+AC_ARG_WITH(hdf5,[  --with-hdf5[=ARG]       Include HDF5 support (ARG=path)],,)
+
+if test "$with_hdf5" = "no" ; then
+
+  HAVE_HDF5=no
+
+  echo "hdf5 support disabled."
+
+elif test "$with_hdf5" = "yes" -o "$with_hdf5" = "" ; then
+
+  HDF5_CFLAGS=""
+  HDF5_LIBS=""
+  PKG_PROG_PKG_CONFIG([0.21]) # check and set $PKG_CONFIG
+  PKG_CHECK_MODULES([HDF5], [hdf5], [HAVE_HDF5=yes], [HAVE_HDF5=no])
+
+  if test "$HAVE_HDF5" = "yes"; then
+
+    # Test that the package found is for the right architecture
+    saved_LIBS="$LIBS"
+    LIBS="$HDF5_LIBS"
+    AC_CHECK_LIB(hdf5,H5Fopen, [HAVE_HDF5=yes], [HAVE_HDF5=no])
+    LIBS="$saved_LIBS"
+
+    if test "$HAVE_HDF5" = "yes"; then
+        LIBS="$HDF5_LIBS $LIBS"
+        HDF5_INCLUDE="$HDF5_CFLAGS"
+    fi
+
+  else
+
+    AC_CHECK_LIB(hdf5,H5Fopen,HAVE_HDF5=yes,HAVE_HDF5=no,)
+
+    if test "$HAVE_HDF5" = "yes" ; then
+        LIBS="-lhdf5 $LIBS"
+    fi
+
+    dnl Some Linux distros install hdf include files here.
+    dnl if test "$HAVE_HDF5" = "yes" -a -r /usr/include/hdf5.h ; then
+    dnl    HDF5_INCLUDE="-I/usr/include"
+    dnl fi
+  fi
+
+else
+
+  if test -d $with_hdf5/lib ; then
+    HDF5_LIB_DIR=$with_hdf5/lib
+  else
+    HDF5_LIB_DIR=$with_hdf5
+  fi
+
+  ORIG_LIBS="$LIBS"
+  LIBS="-L$HDF5_LIB_DIR $LIBS -lhdf5"
+
+  AC_CHECK_LIB(hdf5,H5Fopen,HDF5_LIB_NAME="-lhdf5 ",HDF5_LIB_NAME=missing,-lhdf5)
+
+  if test "$HDF5_LIB_NAME" = "missing" ; then
+    AC_MSG_ERROR([HDF5 support requested with arg $with_hdf5, but no hdf5 lib found])
+  fi
+
+  LIBS="-L$HDF5_LIB_DIR $HDF5_LIB_NAME $ORIG_LIBS"
+
+  if test -r "$with_hdf5/hdf5/hdf5.h" ; then
+    HDF5_INCLUDE="-I$with_hdf5/hdf5"
+  elif test -r "$with_hdf5/include/hdf5/hdf5.h" ; then
+    HDF5_INCLUDE="-I$with_hdf5/include/hdf5"
+  elif test -r "$with_hdf5/include/hdf5.h" ; then
+    HDF5_INCLUDE="-I$with_hdf5/include"
+  elif test -r "$with_hdf5/hdf.h" ; then
+    HDF5_INCLUDE="-I$with_hdf5"
+  fi
+
+  HAVE_HDF5=yes
+fi
+
+AC_SUBST(HAVE_HDF5,$HAVE_HDF5)
+AC_SUBST(HDF5_INCLUDE,$HDF5_INCLUDE)
+
+if test "$HAVE_HDF5" != "no" ; then
+  OPT_GDAL_FORMATS="hdf5 $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if kealib library is available.
+dnl ---------------------------------------------------------------------------
+
+KEA_CONFIG=no
+
+AC_ARG_WITH(kea,[  --with-kea[=ARG]      Include kealib (ARG=path to kea-config) [[default=yes]]],,)
+
+if test "$with_kea" = "yes" -o "x$with_kea" = "x" ; then
+  AC_PATH_PROG(KEA_CONFIG, kea-config, no)
+else
+   KEA_CONFIG=$with_kea
+fi
+
+AC_MSG_CHECKING([for kea])
+
+if test "$KEA_CONFIG" = "no" ; then
+
+  HAVE_KEA=no
+  KEA_LIB=
+  KEA_INC=
+
+  AC_MSG_RESULT([no])
+
+else
+  if test -d $KEA_CONFIG ; then
+      AC_MSG_RESULT([no])
+      AC_MSG_ERROR([--with-kea argument is a directory.  It should be the path to the kea_config script, often somewhere like /usr/local/bin/kea_config.])
+  fi
+
+  if test \! -x $KEA_CONFIG ; then
+      AC_MSG_RESULT([no])
+      AC_MSG_ERROR([--with-kea argument is a not an executable file.  It should be the path to the kea_config script, often somewhere like /usr/local/bin/kea_config.])
+  fi
+
+  HAVE_KEA=yes
+  KEA_LIB="`$KEA_CONFIG --libs --hdflibs`"
+  KEA_INC="`$KEA_CONFIG --cflags --hdfcflags`"
+  AC_MSG_RESULT([yes])
+fi
+
+AC_SUBST(HAVE_KEA,$HAVE_KEA)
+AC_SUBST(KEA_INC,$KEA_INC)
+AC_SUBST(KEA_LIB,$KEA_LIB)
+
+if test "$HAVE_KEA" != "no" ; then
+  OPT_GDAL_FORMATS="kea $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if netcdf library is available.
+dnl ---------------------------------------------------------------------------
+
+NETCDF_SETTING=
+NETCDF_MEM=
+NETCDF_ROOT=
+NETCDF_HAS_NC4=
+NETCDF_HAS_HDF4=
+NETCDF_NCCONFIG=
+
+AC_ARG_WITH([netcdf],[  --with-netcdf[=ARG]     Include netCDF support (ARG=no or netCDF tree prefix)],,)
+
+if test "$with_netcdf" = "no" ; then
+
+  NETCDF_SETTING=no
+  NETCDF_MEM=no
+
+  echo "netCDF support disabled."
+
+else
+
+  dnl find nc-config location
+  unset ac_cv_path_NETCDF_NCCONFIG
+  if test "$with_netcdf" = "yes" -o "$with_netcdf" = "" ; then
+    AC_PATH_PROG(NETCDF_NCCONFIG, nc-config, no)
+  else
+    tmp_path="$with_netcdf/bin$PATH_SEPARATOR$with_netcdf"
+    AC_PATH_PROG(NETCDF_NCCONFIG, nc-config, no, $tmp_path)
+  fi
+
+  dnl test nc-config
+  if test "$NETCDF_NCCONFIG" = "no" ; then
+    echo "        did not find nc-config, some features may be missing"
+    echo "        use --with-netcdf=/path/to/netcdf or add nc-config to PATH"
+    NETCDF_NCCONFIG=
+  elif test "`$NETCDF_NCCONFIG --version`" = "" ; then
+    echo "did not get netCDF version from $NETCDF_NCCONFIG ... using fallback"
+    NETCDF_NCCONFIG=
+  fi
+
+  dnl test linking using flags from nc-config
+  if test "$NETCDF_NCCONFIG" != "" ; then
+
+    AC_MSG_CHECKING([libnetcdf compiler and linker flags with nc-config])
+    NETCDF_VERSION=`$NETCDF_NCCONFIG --version`
+    NETCDF_PREFIX=`$NETCDF_NCCONFIG --prefix`
+    NETCDF_INCLUDEDIR=`$NETCDF_NCCONFIG --includedir`
+    NETCDF_LIBS=`$NETCDF_NCCONFIG --static --libs`
+    echo ""
+    AC_MSG_RESULT([ got version="$NETCDF_VERSION", prefix="$NETCDF_PREFIX",
+ libs="$NETCDF_LIBS", includedir="$NETCDF_INCLUDEDIR"])
+
+    AC_CHECK_LIB([netcdf], [nc_open], [NETCDF_SETTING=yes], [NETCDF_SETTING=no], $NETCDF_LIBS)
+
+    if test "$NETCDF_SETTING" = "yes" ; then
+      EXTRA_INCLUDES="-I$NETCDF_INCLUDEDIR $EXTRA_INCLUDES"
+      NETCDF_ROOT=$NETCDF_PREFIX
+      LIBS="$NETCDF_LIBS $LIBS"
+    else
+      AC_MSG_ERROR("Netcdf via nc-config not working")
+    fi
+
+dnl previous behavior without nc-config
+
+dnl test linking using default settings
+elif test "$with_netcdf" = "yes" -o "$with_netcdf" = "" ; then
+
+  AC_CHECK_LIB([netcdf], [nc_open], [NETCDF_SETTING=yes], [NETCDF_SETTING=no],)
+
+  if test "$NETCDF_SETTING" = "yes" ; then
+
+    dnl Fedora has netcdf headers in /usr/include/netcdf
+    if test -d /usr/include/netcdf ; then
+      EXTRA_INCLUDES="-I/usr/include/netcdf $EXTRA_INCLUDES"
+      NETCDF_ROOT="/usr"
+    dnl RHEL 5 has netcdf headers in /usr/include/netcdf-3
+    elif test -d /usr/include/netcdf-3 ; then
+      EXTRA_INCLUDES="-I/usr/include/netcdf-3 $EXTRA_INCLUDES"
+      NETCDF_ROOT="/usr"
+    dnl ubuntu and fedora have netcdf headers in /usr/include
+    elif test -f /usr/include/netcdf.h ; then
+      NETCDF_ROOT="/usr"
+    dnl try /usr/local
+    elif test -f /usr/local/include/netcdf.h ; then
+      NETCDF_ROOT="/usr/local"
+    dnl print warning if include cannot be found
+    else
+      echo "using pre-installed libnetcdf."
+      echo -n "libnetcdf is installed but its location cannot be found, "
+      echo "use --with-netcdf=/path_to_netcdf for proper support"
+    fi
+    NETCDF_INCLUDEDIR="$NETCDF_ROOT/include/"
+
+    LIBS="-lnetcdf $LIBS"
+    if test "$NETCDF_ROOT" != "" ; then
+      echo "using pre-installed libnetcdf from "$NETCDF_ROOT
+    fi
+
+  else
+    echo "libnetcdf not found ... netCDF support disabled"
+  fi
+
+dnl test linking using --with_netcdf dir
+else
+
+  AC_CHECK_LIB([netcdf], [nc_open], [NETCDF_SETTING=yes], [NETCDF_SETTING=no],-L$with_netcdf -L$with_netcdf/lib)
+
+  if test "$NETCDF_SETTING" = "yes" ; then
+
+    NETCDF_SETTING=yes
+    NETCDF_ROOT="$with_netcdf"
+
+    if test -d $with_netcdf/lib ; then
+      LIBS="-L$with_netcdf/lib -lnetcdf $LIBS"
+      EXTRA_INCLUDES="-I$with_netcdf/include $EXTRA_INCLUDES"
+    else
+      LIBS="-L$with_netcdf -lnetcdf $LIBS"
+      EXTRA_INCLUDES="-I$with_netcdf $EXTRA_INCLUDES"
+    fi
+    NETCDF_INCLUDEDIR="$with_netcdf/include/"
+
+    echo "using libnetcdf from $with_netcdf"
+
+  else
+    echo "libnetcdf not found in "$with_netcdf" ... netCDF support disabled"
+  fi
+
+fi
+
+dnl test for NC4 and HDF4 support with nc-config
+  if test "$NETCDF_SETTING" = "yes" ; then
+
+    if test "$NETCDF_NCCONFIG" != "" ; then
+
+      AC_MSG_CHECKING([for netcdf-4 (and HDF5) support in libnetcdf])
+        if test "x$($NETCDF_NCCONFIG --has-nc4)" = "xyes"; then :
+          AC_MSG_RESULT([yes])
+          NETCDF_HAS_NC4=yes
+        else
+          AC_MSG_RESULT([no])
+          NETCDF_HAS_NC4=no
+        fi
+
+      AC_MSG_CHECKING([for HDF4 support in libnetcdf])
+        if test "x$($NETCDF_NCCONFIG --has-hdf4)" = "xyes"; then :
+          AC_MSG_RESULT([yes])
+          NETCDF_HAS_HDF4=yes
+        else
+          AC_MSG_RESULT([no])
+          NETCDF_HAS_HDF4=no
+        fi
+
+    else
+      NETCDF_HAS_NC4=no
+      NETCDF_HAS_HDF4=no
+    fi
+fi
+
+fi
+
+dnl export results
+
+AC_SUBST([NETCDF_SETTING], [$NETCDF_SETTING])
+
+if test "$NETCDF_SETTING" != "no" ; then
+
+   NETCDF_MEM=no
+   if test -f "$NETCDF_INCLUDEDIR/netcdf_mem.h"; then
+       NETCDF_MEM=yes;
+   fi
+
+   AC_SUBST([NETCDF_MEM], [$NETCDF_MEM])
+   AC_SUBST([NETCDF_ROOT], [$NETCDF_ROOT])
+   AC_SUBST([NETCDF_HAS_NC4], [$NETCDF_HAS_NC4])
+   AC_SUBST([NETCDF_HAS_HDF4], [$NETCDF_HAS_HDF4])
+
+   OPT_GDAL_FORMATS="netcdf $OPT_GDAL_FORMATS"
+
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select a OpenJPEG Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(openjpeg,[  --with-openjpeg     Include JPEG-2000 support via OpenJPEG 2.x library],,)
+
+HAVE_OPENJPEG=no
+
+if test "$with_openjpeg" = "no" ; then
+
+  AC_MSG_NOTICE([OpenJPEG (JPEG2000) support disabled.])
+
+else
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([OPENJPEG], [libopenjp2 >= 2.1.0],
+        [OPENJPEG_VERSION=`$PKG_CONFIG --modversion libopenjp2`],
+        [OPENJPEG_VERSION=;])
+
+  if test -n "$OPENJPEG_CFLAGS"; then
+
+    # Test that the package found is for the right architecture
+    saved_LIBS="$LIBS"
+    LIBS="$OPENJPEG_LIBS"
+    AC_CHECK_LIB(openjp2,opj_setup_decoder, [HAVE_OPENJPEG=yes], [HAVE_OPENJPEG=no])
+    LIBS="$saved_LIBS"
+
+    if test "$HAVE_OPENJPEG" = "yes"; then
+        EXTRA_INCLUDES="$OPENJPEG_CFLAGS $EXTRA_INCLUDES"
+        LIBS="$OPENJPEG_LIBS $LIBS"
+    fi
+  fi
+fi
+
+if test "$HAVE_OPENJPEG" != "no" ; then
+  OPT_GDAL_FORMATS="openjpeg $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select a FGDB API to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(fgdb,[  --with-fgdb[=ARG]        Include ESRI File Geodatabase support (ARG=FGDP API Path, yes or no)],,)
+
+FGDB_ENABLED=no
+FGDB_LIB=
+
+if test "$with_fgdb" = "no" ; then
+
+  echo "FGDB support disabled."
+
+elif test "$with_fgdb" = "yes" -o "$with_fgdb" = "" ; then
+
+    AC_MSG_CHECKING([for FileGDBAPI])
+
+    rm -f testfgdb.*
+    rm -f testfgdb
+    echo "#include <FileGDBAPI.h>" > testfgdb.cpp
+    echo "using namespace FileGDBAPI;" >> testfgdb.cpp
+    echo "int main() { Geodatabase oDB; std::wstring osStr; ::OpenGeodatabase(osStr, oDB); return 0; }" >> testfgdb.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testfgdb.cpp -lFileGDBAPI -lfgdbunixrtl -o testfgdb 2>&1`" ; then
+        AC_MSG_RESULT([FileGDBAPI found])
+        FGDB_ENABLED="yes"
+        FGDB_LIB="-lFileGDBAPI -lfgdbunixrtl"
+    else
+        if test "$with_fgdb" = "yes"; then
+            AC_MSG_ERROR([FileGDBAPI not found.])
+        else
+            AC_MSG_RESULT([FileGDBAPI not found.])
+        fi
+    fi
+    rm -f testfgdb.*
+    rm -f testfgdb
+
+else
+
+  AC_MSG_CHECKING([for libFileGDBAPI.so in in $with_fgdb/lib])
+  FGDB_ENABLED=yes
+  if test -r $with_fgdb/lib/libFileGDBAPI.so -a -r $with_fgdb/lib/libfgdbunixrtl.so ; then
+    AC_MSG_RESULT([found.])
+    FGDB_LIB="-L$with_fgdb/lib -lFileGDBAPI -lfgdbunixrtl"
+  elif test -r $with_fgdb/lib/libFileGDBAPI.dylib -a -r $with_fgdb/lib/libfgdbunixrtl.dylib ; then
+    AC_MSG_RESULT([found.])
+    FGDB_LIB="-L$with_fgdb/lib -lFileGDBAPI -lfgdbunixrtl"
+  else
+    AC_MSG_ERROR([not found.])
+  fi
+
+  AC_MSG_CHECKING([for FileGDBAPI.h in $with_fgdb/include])
+  if test -r $with_fgdb/include/FileGDBAPI.h ; then
+    AC_MSG_RESULT([found.])
+    FGDB_INC="-I$with_fgdb/include"
+  else
+    AC_MSG_ERROR([not found.])
+  fi
+
+fi
+
+if test "$FGDB_LIB" != ""; then
+  dnl pj_datums is not a function but an object, but for linking that doesn't matter.
+  AC_CHECK_LIB(FileGDBAPI,pj_datums,FGDB_HAS_PROJ4=yes,FGDB_HAS_PROJ4=no,$FGDB_LIB)
+fi
+
+AC_SUBST(FGDB_ENABLED, $FGDB_ENABLED)
+AC_SUBST(FGDB_LIB, $FGDB_LIB)
+AC_SUBST(FGDB_INC, $FGDB_INC)
+
+dnl ---------------------------------------------------------------------------
+dnl Select a ECW Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+ECW_FLAGS=
+ECW_LIBS=
+ECW_INCLUDE=
+ECW_54=
+
+AC_ARG_WITH(ecw,[  --with-ecw[=ARG]        Include ECW support (ARG=ECW SDK Path, yes or no)],,)
+
+if test ! -z "`uname | grep Darwin`" ; then
+  CARBON_FRAMEWORK="-framework Carbon"
+else
+  CARBON_FRAMEWORK=
+fi
+
+if test "$with_ecw" = "no" ; then
+
+  ECW_SETTING=no
+
+  echo "ECW support disabled."
+
+elif test "$with_ecw" = "yes" -o "$with_ecw" = "" ; then
+
+  AC_CHECK_LIB(NCSEcw,NCScbmOpenFileView,ECW_SETTING=yes,ECW_SETTING=no,-lNCSCnet -lNCSUtil)
+
+  if test "$ECW_SETTING" = "yes" ; then
+    ECW_LIBS="-lNCSEcw -lNCSEcwC -lNCSCnet -lNCSUtil"
+  fi
+
+  if test "$ECW_SETTING" = "no" ; then
+    AC_CHECK_LIB(ecwj2,NCScbmOpenFileView,ECW_SETTING=yes,ECW_SETTING=no,$CARBON_FRAMEWORK)
+    if test "$ECW_SETTING" = "yes" ; then
+      ECW_LIBS="-lecwj2 $CARBON_FRAMEWORK"
+    fi
+  fi
+else
+
+  AC_MSG_CHECKING([for libNCSEcw.a or libecwj2])
+  ECW_ARCH=x86
+  ECW_CONF="release"
+  ECW_FLAGS="-DLINUX -DX86 -DPOSIX -DHAVE_COMPRESS -DECW_COMPRESS_RW_SDK_VERSION"
+  ECW_FRAMEWORK_COCOA=""
+  if test "`arch`" = "x86_64" ; then
+    ECW_ARCH="x64"
+  fi
+  if test ! -z "`uname | grep Darwin`" ; then
+    ECW_ARCH=""
+    ECW_CONF=""
+    ECW_FLAGS=""
+    ECW_FRAMEWORK_COCOA=" -framework Cocoa "
+  fi
+
+  ECW_SETTING=yes
+  if test -r $with_ecw/lib/libNCSCnet.so -o -r $with_ecw/lib/libNCSCnet.dylib ; then
+    ECW_LIBS="-L$with_ecw/lib -lNCSEcw -lNCSEcwC -lNCSCnet -lNCSUtil"
+    AC_MSG_RESULT([found in $with_ecw/lib.])
+  elif test -r $with_ecw/lib/libNCSCNet.so -o -r $with_ecw/lib/libNCSCNet.dylib ; then
+    ECW_LIBS="-L$with_ecw/lib -lNCSEcw -lNCSEcwC -lNCSCNet -lNCSUtil"
+    AC_MSG_RESULT([found in $with_ecw/lib.])
+  elif test -r $with_ecw/bin/libNCSEcw.so -o -r $with_ecw/bin/libNCSEcw.dylib ; then
+    ECW_LIBS="-L$with_ecw/bin -lNCSEcw -lNCSEcwC -lNCSCnet -lNCSUtil"
+    AC_MSG_RESULT([found in $with_ecw/bin.])
+  elif test -r $with_ecw/lib/libecwj2.dylib ; then
+    ECW_LIBS="-L$with_ecw/lib -lecwj2 $CARBON_FRAMEWORK"
+    AC_MSG_RESULT([found libecwj2 in $with_ecw/lib.])
+
+  # ECW SDK 5.0 style and also for the case where license type is included in path i.e. specific license type is requested.
+  elif test -r $with_ecw/lib/$ECW_ARCH/$ECW_CONF/libNCSEcw.a ; then
+    # Test if we must use the newabi/cpp11abi version (SDK 5.4+)
+    if test -r $with_ecw/lib/newabi/$ECW_ARCH/$ECW_CONF/libNCSEcw.a || test -r $with_ecw/lib/cpp11abi/$ECW_ARCH/$ECW_CONF/libNCSEcw.a; then
+        if test -d $with_ecw/lib/newabi; then
+            ECW_ABIDIR=newabi
+        else
+            ECW_ABIDIR=cpp11abi
+        fi
+        echo "#include <string>" > testnewabi.cpp
+        echo "namespace NCS { class CString { public: static std::wstring Utf8Decode (const std::string &sUtf8); }; }" >> testnewabi.cpp
+        echo "int main() { return static_cast<int>(NCS::CString::Utf8Decode(std::string()).size()); }" >> testnewabi.cpp
+        if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testnewabi.cpp -L$with_ecw/lib/$ECW_ABIDIR/$ECW_ARCH/$ECW_CONF -lNCSEcw -o testnewabi 2>&1`" ; then
+            ECW_LIBDIR=$with_ecw/lib/$ECW_ABIDIR/$ECW_ARCH/$ECW_CONF
+            ECW_LIBS="-L$ECW_LIBDIR -lNCSEcw $ECW_FRAMEWORK_COCOA"
+            with_ecw=$with_ecw/$ecw_license_type
+            ECW_54="yes"
+            AC_MSG_RESULT([found Intergraph 5.4+ SDK with ${ECW_ABIDIR} in ${ECW_LIBDIR}.])
+            rm -f testnewabi.*
+            rm -f testnewabi
+            break
+        fi
+        rm -f testnewabi.*
+        rm -f testnewabi
+    fi
+    if test "$ECW_LIBS" = ""; then
+        ECW_LIBDIR=$with_ecw/lib/$ECW_ARCH/$ECW_CONF
+        ECW_LIBS="-L$ECW_LIBDIR -lNCSEcw $ECW_FRAMEWORK_COCOA"
+        AC_MSG_RESULT([found Intergraph 5.x+ SDK in ${ECW_LIBDIR}.])
+    fi
+ # ECWJP2 SDK 5.1 style
+  elif test -d $with_ecw; then
+    for ecw_license_type in "Desktop_Read-Write" "Server_Read-Only_EndUser" "Server_Read-Only" "Server_Read-Write" "Desktop_Read-Only"
+      do
+        # Test if we must use the newabi/cpp11abi version (SDK 5.4+)
+        if test -r $with_ecw/$ecw_license_type/lib/newabi/$ECW_ARCH/$ECW_CONF/libNCSEcw.a || test -r $with_ecw/$ecw_license_type/lib/cpp11abi/$ECW_ARCH/$ECW_CONF/libNCSEcw.a; then
+            if test -d $with_ecw/lib/newabi; then
+                ECW_ABIDIR=newabi
+            else
+                ECW_ABIDIR=cpp11abi
+            fi
+            echo "#include <string>" > testnewabi.cpp
+            echo "namespace NCS { class CString { public: static std::wstring Utf8Decode (const std::string &sUtf8); }; }" >> testnewabi.cpp
+            echo "int main() { return static_cast<int>(NCS::CString::Utf8Decode(std::string()).size()); }" >> testnewabi.cpp
+            if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testnewabi.cpp -L$with_ecw/$ecw_license_type/lib/$ECW_ABIDIR/$ECW_ARCH/$ECW_CONF -lNCSEcw -o testnewabi 2>&1`" ; then
+                ECW_LIBDIR=$with_ecw/$ecw_license_type/lib/$ECW_ABIDIR/$ECW_ARCH/$ECW_CONF
+                ECW_LIBS="-L$ECW_LIBDIR -lNCSEcw $ECW_FRAMEWORK_COCOA"
+                with_ecw=$with_ecw/$ecw_license_type
+                AC_MSG_RESULT([found Intergraph 5.4+ SDK with ${ECW_ABIDIR} in ${ECW_LIBDIR}.])
+                ECW_54="yes"
+                rm -f testnewabi.*
+                rm -f testnewabi
+                break
+            fi
+            rm -f testnewabi.*
+            rm -f testnewabi
+        fi
+        if test "$ECW_LIBS" = ""; then
+            ECW_LIBDIR=$with_ecw/$ecw_license_type/lib/$ECW_ARCH/$ECW_CONF
+            if test -r $ECW_LIBDIR/libNCSEcw.a; then
+                ECW_LIBS="-L$ECW_LIBDIR -lNCSEcw $ECW_FRAMEWORK_COCOA"
+                with_ecw=$with_ecw/$ecw_license_type
+                AC_MSG_RESULT([found Intergraph 5.x+ SDK in ${ECW_LIBDIR}.])
+                break
+            fi
+        fi
+      done
+ else
+    AC_MSG_ERROR([not found in $with_ecw.])
+  fi
+
+  AC_MSG_CHECKING([for NCSECWClient.h in $with_ecw/include])
+  if test -r $with_ecw/include/NCSECWClient.h ; then
+    AC_MSG_RESULT([found.])
+    ECW_INCLUDE="-I$with_ecw/include"
+  else
+    AC_MSG_ERROR([not found.])
+  fi
+  AC_MSG_CHECKING([for ECWJP2BuildNumber.h in $with_ecw/include])
+  if test -r $with_ecw/include/ECWJP2BuildNumber.h ; then
+    AC_MSG_RESULT([found.])
+    ECW_FLAGS="-DHAVE_ECW_BUILDNUMBER_H $ECW_FLAGS"
+  else
+    AC_MSG_RESULT([not found.])
+  fi
+fi
+
+AC_SUBST(ECW_SETTING,$ECW_SETTING)
+AC_SUBST(ECW_LIBS,$ECW_LIBS)
+AC_SUBST(ECW_FLAGS,$ECW_FLAGS)
+AC_SUBST(ECW_INCLUDE,$ECW_INCLUDE)
+
+if test "$ECW_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="ecw $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Select Kakadu library or disable driver.
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([for Kakadu JPEG2000 support])
+
+AC_ARG_WITH(kakadu,[  --with-kakadu[=ARG]     Include Kakadu/JPEG2000 support],,)
+
+if test "$with_kakadu" = "no" -o "$with_kakadu" = "" ; then
+  KAKDIR=
+  AC_MSG_RESULT([not requested.])
+  HAVE_KAKADU=no
+elif test "$with_kakadu" = "yes" ; then
+  AC_MSG_ERROR([
+For JPEG2000 support using Kakadu you need provide the path to the Kakadu
+build directory.  Note that Kakadu is *not* free software.])
+else
+  KAKDIR=$with_kakadu
+  OPT_GDAL_FORMATS="jp2kak jpipkak $OPT_GDAL_FORMATS"
+  LIBS="$LIBS -L$with_kakadu/lib -lkdu"
+  AC_MSG_RESULT([requested.])
+  HAVE_KAKADU=yes
+fi
+
+AC_SUBST(KAKDIR,$KAKDIR)
+
+dnl ---------------------------------------------------------------------------
+dnl Select MrSID library or disable driver.
+dnl ---------------------------------------------------------------------------
+MRSID_FLAGS=
+HAVE_MRSID=no
+
+AC_ARG_WITH(mrsid,[  --with-mrsid[=ARG]      Include MrSID support (ARG=path to MrSID DSDK or no)],,)
+
+AC_ARG_WITH(jp2mrsid,[  --with-jp2mrsid[=ARG]   Enable MrSID JPEG2000 support (ARG=yes/no)],,)
+
+if test "x$with_mrsid" = "xno"  -o "x$with_mrsid" = "x" ; then
+
+  HAVE_MRSID=no
+
+  AC_MSG_NOTICE([MrSID support disabled.])
+
+else
+
+  MRSID_BASE="$with_mrsid/include"
+
+  AC_MSG_CHECKING([for lt_base.h in $MRSID_BASE/support])
+  if test -r "$MRSID_BASE/support/lt_base.h" ; then
+
+    AC_MSG_RESULT([found MrSID DSDK version 4.x or newer.])
+    HAVE_MRSID=yes
+    MRSID_INCLUDE="-I$MRSID_BASE/base -I$MRSID_BASE/metadata -I$MRSID_BASE/mrsid_readers -I$MRSID_BASE/j2k_readers -I$MRSID_BASE/support"
+
+  else
+
+    AC_MSG_RESULT([not found.])
+
+    AC_MSG_CHECKING([for lt_base.h in $MRSID_BASE])
+    if test -r "$MRSID_BASE/lt_base.h" ; then
+
+      AC_MSG_RESULT([found MrSID DSDK version 7.x or newer.]);
+      HAVE_MRSID=yes
+      MRSID_INCLUDE="-I$MRSID_BASE"
+
+    fi
+
+  fi
+
+  if test $HAVE_MRSID = yes ; then
+
+    MRSID_LIBS="-lpthread"
+
+    if test -r "$with_mrsid/lib/libltiesdk.a" ; then # v8+ esdk contains dsdk
+      _LIBPART=lib
+      MRSID_LIBS="-lltiesdk $MRSID_LIBS"
+    elif test -e "$with_mrsid/lib/libltidsdk.a" \
+           -o -e "$with_mrsid/lib/libltidsdk.so" \
+           -o -e "$with_mrsid/lib/libltidsdk.dylib" ; then
+      _LIBPART=lib
+      MRSID_LIBS="-lltidsdk $MRSID_LIBS"
+    else
+      _LIBPART=lib/Release
+      MRSID_LIBS="-lltidsdk $MRSID_LIBS"
+    fi
+
+    AC_MSG_CHECKING([for MG3ImageWriter.h in $with_mrsid/include/mrsid_writers])
+    if test -r "$with_mrsid/include/mrsid_writers/MG3ImageWriter.h" ; then
+      AC_MSG_RESULT([found MrSID ESDK version 4.x or newer.])
+      MRSID_FLAGS="-DMRSID_ESDK $MRSID_FLAGS"
+      MRSID_INCLUDE="-I$with_mrsid/include/mrsid_writers -I$with_mrsid/include/j2k_writers $MRSID_INCLUDE"
+      if test -r $with_mrsid/3rd-party/lib/Release/libcryptopp.a ; then
+        MRSID_LIBS="-lltiesdk -lcryptopp -lxmlparse $MRSID_LIBS"
+      else
+        MRSID_LIBS="-lltiesdk -lxmlparse $MRSID_LIBS"
+      fi
+    else
+      AC_MSG_RESULT([no encoding support.])
+    fi
+
+    AC_MSG_CHECKING([for MrSID JPEG2000 support])
+    if test "x$with_jp2mrsid" = "xyes" -a "$HAVE_KAKADU" = "yes" ; then
+      # SDK v8 or later don't seem to conflict with Kakadu
+      major_version=`cat $with_mrsid/include/lti_version.h | grep MAJOR | sed 's/#define LTI_SDK_MAJOR[ ]*\(.*\)/\1/'`
+      if test "x$major_version" != "x"; then
+        if test "$major_version" -ge 8; then
+            V8_OR_LATER=yes
+        fi
+      fi
+      if test "x$V8_OR_LATER" = "x"; then
+        AC_MSG_ERROR([MrSID JPEG2000 support requested, but this is incompatible with use of standalone Kakadu])
+      fi
+    fi
+
+    MRSID_KAKADU_LIB=""
+    if test "$HAVE_KAKADU" = "no" ; then
+      if test x"$with_jp2mrsid" = x"" -o x"$with_jp2mrsid" = x"yes" ; then
+        if test -r "$with_mrsid/3rd-party/$_LIBPART/libltikdu.a" ; then
+          with_jp2mrsid=yes
+          MRSID_KAKADU_LIB=-lltikdu
+        elif test -r "$with_mrsid/3rd-party/$_LIBPART/liblt_kakadu.a" ; then
+          with_jp2mrsid=yes
+          MRSID_KAKADU_LIB=-llt_kakadu
+        elif test -e "$with_mrsid/lib/libltidsdk.so" \
+               -o -e "$with_mrsid/lib/libltidsdk.dylib"; then # v8+ .so has kdu
+          with_jp2mrsid=yes
+        elif test x"$with_jp2mrsid" = x"yes" ; then
+          AC_MSG_ERROR([MrSID JPEG2000 support requested, but libltikdu.a not found.])
+        else
+          with_jp2mrsid=no
+        fi
+      fi
+    fi
+
+    if test "x$with_jp2mrsid" = "xyes" ; then
+      MRSID_LIBS="$MRSID_LIBS $MRSID_KAKADU_LIB"
+      MRSID_FLAGS="-DMRSID_J2K $MRSID_FLAGS"
+      AC_MSG_RESULT([enabled])
+    else
+      AC_MSG_RESULT([disabled])
+    fi
+
+    MRSID_LIBS="-L$with_mrsid/$_LIBPART $MRSID_LIBS"
+    MRSID_LIBS="-L$with_mrsid/3rd-party/$_LIBPART $MRSID_LIBS"
+
+  else
+    HAVE_MRSID=no
+    AC_MSG_RESULT([not found.])
+    AC_MSG_ERROR([  MrSID requested, but components not found.])
+  fi
+fi
+
+AC_SUBST(MRSID_INCLUDE,$MRSID_INCLUDE)
+AC_SUBST(MRSID_FLAGS,$MRSID_FLAGS)
+AC_SUBST(MRSID_LIBS,$MRSID_LIBS)
+
+if test "$HAVE_MRSID" != "no" ; then
+  CPPFLAGS="-D_REENTRANT $CPPFLAGS"
+  OPT_GDAL_FORMATS="mrsid $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if LuraTech library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(jp2lura,[  --with-j2lura[=ARG]    Include JP2Lua support (ARG=no, lura SDK install path)],,)
+
+AC_MSG_CHECKING([for JP2Lura support])
+
+HAVE_JP2LURA=no
+JP2LURA_INCLUDE=
+
+if test "$with_jp2lura" != "" -a "$with_jp2lura" != "no" ; then
+  AC_MSG_CHECKING([for lwf_jp2.h])
+  if test -f "$with_jp2lura/include/lwf_jp2.h"; then
+    AC_MSG_RESULT([yes])
+  else
+    AC_MSG_RESULT([no])
+    AC_MSG_ERROR([JP2Lura support requested but header not found])
+  fi
+  JP2LURA_INCLUDE="-I$with_jp2lura/include"
+
+  # mingw support
+  if test -f "$with_jp2lura/library/lwf_jp2.lib"; then
+      ln -s "$with_jp2lura/library/lwf_jp2.lib" "$with_jp2lura/library/lib_lwf_jp2.a"
+  fi
+
+  ORIG_LIBS="$LIBS"
+  LIBS="-L$with_jp2lura/library"
+
+  AC_CHECK_LIB(_lwf_jp2,JP2_Decompress_SetLicense,HAVE_JP2LURA="yes",,-lm)
+
+  if test "$HAVE_JP2LURA" = "no" ; then
+    AC_MSG_ERROR([JP2Lura support requested but library not found])
+  fi
+
+  LIBS="-L$with_jp2lura/library -l_lwf_jp2 -lm $ORIG_LIBS"
+fi
+
+AC_SUBST([JP2LURA_INCLUDE], [$JP2LURA_INCLUDE])
+
+if test "$HAVE_JP2LURA" != "no" ; then
+  OPT_GDAL_FORMATS="jp2lura $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Enable MSG format if EUMETSAT Wavelet Transform Software
+dnl available in the local tree
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([msg],
+	    AS_HELP_STRING([--with-msg[=ARG]],
+	       [Enable MSG driver (ARG=yes or no)]),,)
+
+HAVE_MSG=no
+HAVE_EUMETSATWT=no
+
+if test "x$with_msg" = "xyes" ; then
+    AC_MSG_CHECKING([for EUMETSAT Wavelet Transformation Software])
+
+    if test -d "frmts/msg/PublicDecompWT" -a \
+        -f "frmts/msg/PublicDecompWT/COMP/Inc/CImage.h"; then
+        HAVE_EUMETSATWT=yes
+    else
+        HAVE_EUMETSATWT=no
+    fi
+    AC_MSG_RESULT([$HAVE_EUMETSATWT])
+fi
+
+AC_MSG_CHECKING([for MSG])
+
+if test "x$with_msg" = "xyes" -o "x$with_msg" = "x" \
+    -a "x$HAVE_EUMETSATWT" = "xyes"; then
+    OPT_GDAL_FORMATS="msg $OPT_GDAL_FORMATS"
+    HAVE_MSG=yes
+    AC_MSG_RESULT([enabled])
+else
+    HAVE_MSG=no
+    AC_MSG_RESULT([not requested])
+fi
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check for GeoRaster in the local tree.
+dnl ---------------------------------------------------------------------------
+
+ORACLE_OCI_REQ_VERSION="10.0.1"
+AX_LIB_ORACLE_OCI($ORACLE_OCI_REQ_VERSION)
+
+if test "$HAVE_ORACLE_OCI" = "yes"; then
+    OPT_GDAL_FORMATS="georaster $OPT_GDAL_FORMATS"
+    HAVE_GEORASTER=yes
+else
+    HAVE_GEORASTER=no
+fi
+
+
+dnl ---------------------------------------------------------------------------
+
+AC_SUBST([OPT_GDAL_FORMATS], [$OPT_GDAL_FORMATS])
+
+dnl ---------------------------------------------------------------------------
+
+GNM_ENABLED=yes
+
+AC_ARG_WITH(gnm,[  --with-gnm            Build GNM into shared library],,)
+
+if test "$with_gnm" = "no" ; then
+  GNM_ENABLED=no
+  AC_MSG_RESULT([disabled by user])
+else
+  GNM_ENABLED=yes
+  AC_MSG_RESULT([enabled])
+fi
+AC_SUBST(GNM_ENABLED,$GNM_ENABLED)
+
+dnl ---------------------------------------------------------------------------
+dnl Select an MySQL Library to use, or disable driver.
+dnl ---------------------------------------------------------------------------
+
+MYSQL_CONFIG=no
+
+AC_ARG_WITH(mysql,[  --with-mysql[=ARG]      Include MySQL (ARG=path to mysql_config) [[default=no]]],,)
+
+if test "$with_mysql" = "yes" ; then
+  AC_PATH_PROG(MYSQL_CONFIG, mysql_config, no)
+else
+    if test "x$with_mysql" != "x" ; then
+      MYSQL_CONFIG=$with_mysql
+    fi
+fi
+
+AC_MSG_CHECKING([for MySQL])
+
+if test "$MYSQL_CONFIG" = "no" ; then
+
+  HAVE_MYSQL=no
+  MYSQL_LIB=
+  MYSQL_INC=
+
+  AC_MSG_RESULT([no])
+
+else
+  if test -d $MYSQL_CONFIG ; then
+      AC_MSG_RESULT([no])
+      AC_MSG_ERROR([--with-mysql argument is a directory.  It should be the path to the mysql_config script, often somewhere like /usr/local/bin/mysql_config.])
+  fi
+
+  if test \! -x $MYSQL_CONFIG ; then
+      AC_MSG_RESULT([no])
+      AC_MSG_ERROR([--with-mysql argument is a not an executable file.  It should be the path to the mysql_config script, often somewhere like /usr/local/bin/mysql_config.])
+  fi
+
+  MYSQL_VERSION="`$MYSQL_CONFIG --version`"
+  MYSQL_MAJOR_VERSION=${MYSQL_VERSION%%'.'*}
+
+  if test $MYSQL_MAJOR_VERSION -le 3 ; then
+    HAVE_MYSQL=no
+    AC_MSG_RESULT([no, mysql is pre-4.x])
+  else
+      HAVE_MYSQL=yes
+      MYSQL_LIB="`$MYSQL_CONFIG --libs`"
+      STRIP_SYSTEM_LIBRARY_PATHS("${MYSQL_LIB}")
+      MYSQL_LIB="$STRIPPED_LIBRARY_NAME"
+      MYSQL_INC="`$MYSQL_CONFIG --include`"
+      AC_MSG_RESULT([yes])
+  fi
+fi
+
+AC_SUBST(HAVE_MYSQL,$HAVE_MYSQL)
+AC_SUBST(MYSQL_INC,$MYSQL_INC)
+AC_SUBST(MYSQL_LIB,$MYSQL_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for Xerces C++ Parser support.
+dnl ---------------------------------------------------------------------------
+
+XERCES_REQ_VERSION="3.1.0"
+AX_LIB_XERCES($XERCES_REQ_VERSION)
+
+if test "$HAVE_XERCES" = "yes"; then
+    LIBS="$XERCES_LDFLAGS $LIBS"
+
+m4_foreach_w([frmt],XERCES_DRIVERS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+    OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+  fi
+])
+
+fi
+
+AC_SUBST([HAVE_XERCES], $HAVE_XERCES)
+AC_SUBST([XERCES_INCLUDE], $XERCES_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for Expat configuration.
+dnl ---------------------------------------------------------------------------
+
+dnl Expat 1.95.0 released in 2000-09-28
+EXPAT_REQ_VERSION="1.95.0"
+AX_LIB_EXPAT($EXPAT_REQ_VERSION)
+
+if test "$HAVE_EXPAT" = "yes"; then
+    LIBS="$EXPAT_LDFLAGS $LIBS"
+
+m4_foreach_w([frmt],EXPAT_DRIVERS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+    OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+  fi
+])
+
+fi
+
+AC_SUBST([HAVE_EXPAT], $HAVE_EXPAT)
+AC_SUBST([EXPAT_INCLUDE], $EXPAT_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for Google libkml support.
+dnl ---------------------------------------------------------------------------
+
+LIBKML_REQ_VERSION="1.3.0"
+AX_LIB_LIBKML($LIBKML_REQ_VERSION)
+
+if test "$HAVE_LIBKML" = "yes"; then
+    LIBS="$LIBKML_LDFLAGS $LIBS"
+fi
+
+AC_SUBST([HAVE_LIBKML], $HAVE_LIBKML)
+AC_SUBST([LIBKML_INCLUDE], $LIBKML_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for ODBC support.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(odbc,[  --with-odbc[=ARG]       Include ODBC support (ARG=no or path)],,)
+
+if test "$with_odbc" = "no" ; then
+
+  ODBC_SETTING=no
+
+  echo "ODBC support disabled."
+
+elif test "$with_odbc" = "yes" -o "$with_odbc" = "" ; then
+  ODBC_SETTING=no
+
+  echo "check for unixODBC"
+  AC_CHECK_LIB(odbc,SQLConnect,[ODBC_LIBS="-lodbc -lodbcinst"])
+  AC_CHECK_LIB(odbcinst,SQLInstallDriverEx,ODBC_SETTING=yes)
+
+  if test "$ODBC_SETTING" = "no" ; then
+    echo "check for windows ODBC"
+    AC_CHECK_LIB(odbc32,main,[ODBC_LIBS="-lodbc32 -lodbccp32"])
+    AC_CHECK_LIB(odbccp32,SQLInstallDriverEx,ODBC_SETTING=yes)
+  fi
+
+  if test "$ODBC_SETTING" = "yes" ; then
+    AC_CHECK_HEADERS(sql.h,,[ODBC_SETTING=no],
+[#ifdef _WIN32
+# include <windows.h>
+#endif
+])
+    if test "$ODBC_SETTING" = "no" ; then
+      if test -f /usr/local/include/sql.h ; then
+        ODBC_SETTING=yes
+        echo "using sql.h from /usr/local/include"
+      elif test -f /usr/include/sql.h ; then
+        ODBC_SETTING=yes
+        echo "using sql.h from /usr/include"
+      else
+        echo "sql.h not found"
+      fi
+    fi
+  fi
+
+  if test "$ODBC_SETTING" = "yes"  ; then
+    LIBS="$ODBC_LIBS $LIBS"
+  fi
+
+else
+
+  ODBC_SETTING=yes
+  ODBC_LIBS=""
+  AC_CHECK_LIB(odbc,SQLConnect,ODBC_LIBS="-lodbc -lodbcinst")
+  AC_CHECK_LIB(odbc32,main,ODBC_LIBS="-lodbc32 -lodbccp32")
+  if test "$ODBC_LIBS" = ""; then
+    AC_MSG_ERROR([Cannot find ODBC libs])
+  fi
+  LIBS="-L$with_odbc -L$with_odbc/lib $ODBC_LIBS $LIBS"
+  EXTRA_INCLUDES="-I$with_odbc -I$with_odbc/include $EXTRA_INCLUDES"
+
+  echo "using odbc library from $with_odbc."
+fi
+
+if test "$ODBC_SETTING" = "yes"  ; then
+m4_foreach_w([frmt],ODBC_DRIVERS,[
+  driver_enabled=m4_join([_],[$INTERNAL_FORMAT],frmt,[ENABLED])
+  if test "x$driver_enabled" = "xyes"; then
+    OGRFORMATS_ENABLED="$OGRFORMATS_ENABLED frmt"
+    OGRFORMATS_ENABLED_CFLAGS="$OGRFORMATS_ENABLED_CFLAGS _OGRDEFINE(frmt)"
+  fi
+])
+fi
+
+AC_SUBST(ODBC_SETTING,$ODBC_SETTING)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for SAP HANA support.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(hana, AS_HELP_STRING([--with-hana[=ARG]] Include SAP HANA (ARG=no(default), yes or path to odbc-cpp-wrapper)),,)
+
+AC_MSG_CHECKING([for SAP HANA])
+
+if test "x$with_hana" = "xno" -o "x$with_hana" = "x" ; then
+  HAVE_HANA=no
+  ODBCCPP_LIB=
+  ODBCCPP_INC=
+  AC_MSG_RESULT([no])
+else
+  if test "$ODBC_SETTING" = "no" ; then
+      AC_MSG_ERROR([SAP HANA driver requires odbc driver to be installed.])
+  fi
+
+  if test "$with_hana" = "yes" ; then
+      ODBCCPP_PATH=/usr/local
+  else
+      ODBCCPP_PATH=$with_hana
+  fi
+
+  if test -d ${ODBCCPP_PATH} ; then
+     AC_LANG_PUSH(C++)
+     LIBS="-lodbccpp $LIBS"
+     AC_CHECK_HEADER(odbc/PreparedStatement.h)
+     AC_LINK_IFELSE(
+       [AC_LANG_PROGRAM(
+           [#include <odbc/Environment.h>],
+           [
+              odbc::EnvironmentRef env = odbc::Environment::create();
+           ]
+         )],
+       [HAVE_HANA="yes"],
+       [AC_MSG_WARN([Cannot find odbccpp.])])
+     AC_LANG_POP(C++)
+
+     if test "${HAVE_HANA}" = "yes" ; then
+         ODBCCPP_LIB=-L"$ODBCCPP_PATH/lib"
+         ODBCCPP_INC=-I"$ODBCCPP_PATH/include"
+         AC_MSG_RESULT([yes])
+     else
+         AC_MSG_ERROR([--with-hana argument points to a directory which does not contain the odbc-cpp-wrapper library.])
+     fi
+  else
+      AC_MSG_RESULT([no])
+      AC_MSG_ERROR([--with-hana argument is not a directory. It should be the path to the odbc-cpp-wrapper library, often somewhere like /usr/local.])
+  fi
+fi
+
+AC_SUBST(HAVE_HANA,$HAVE_HANA)
+AC_SUBST(ODBCCPP_INC,$ODBCCPP_INC)
+AC_SUBST(ODBCCPP_LIB,$ODBCCPP_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for OCI support.
+dnl ---------------------------------------------------------------------------
+
+ORACLE_OCI_REQ_VERSION="8.1.7"
+AX_LIB_ORACLE_OCI($ORACLE_OCI_REQ_VERSION)
+
+if test "$HAVE_ORACLE_OCI" = "yes"; then
+    OCI_INCLUDE="$ORACLE_OCI_CFLAGS"
+    LIBS="$ORACLE_OCI_LDFLAGS $LIBS"
+fi
+
+AC_SUBST([HAVE_OCI], [$HAVE_ORACLE_OCI])
+AC_SUBST([OCI_INCLUDE], $[OCI_INCLUDE])
+
+dnl ---------------------------------------------------------------------------
+dnl Check for libxml2.
+dnl ---------------------------------------------------------------------------
+
+HAVE_LIBXML2=no
+LIBXML2_INC=
+LIBXML2_LIB=
+
+AC_ARG_WITH(xml2,
+    [  --with-xml2[=ARG]       Include libxml2 (ARG=yes/no)],,,)
+
+if test "x$with_xml2" = "xyes" -o "x$with_xml2" = "x" ; then
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES(LIBXML2,[libxml-2.0], [HAVE_LIBXML2=yes], [HAVE_LIBXML2=no])
+
+  if test "${HAVE_LIBXML2}" = "yes"; then
+    SAVED_LIBS="${LIBS}"
+    LIBS="${LIBXML2_LIBS}"
+    AC_CHECK_LIB(xml2,xmlParseDoc,HAVE_LIBXML2=yes,HAVE_LIBXML2=no)
+    LIBS="${SAVED_LIBS}"
+  fi
+
+  if test "${HAVE_LIBXML2}" = "yes"; then
+    LIBXML2_INC="${LIBXML2_CFLAGS}"
+    LIBXML2_LIB="${LIBXML2_LIBS}"
+  else
+    if test "x$with_xml2" = "xyes"; then
+      AC_MSG_ERROR([--with-xml2 was requested, but libxml2 is not available])
+    fi
+  fi
+elif test "x$with_xml2" != "xno"; then
+  AC_MSG_ERROR([Only --with-xml2=yes/no supported])
+fi
+
+AC_SUBST(HAVE_LIBXML2,$HAVE_LIBXML2)
+AC_SUBST(LIBXML2_INC, $LIBXML2_INC)
+AC_SUBST(LIBXML2_LIB, $LIBXML2_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for librasterlite2.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rasterlite2,
+    [  --with-rasterlite2=ARG Include RasterLite2 support (ARG=no(default), yes or path)],
+    ,,)
+
+HAVE_RASTERLITE2=no
+RASTERLITE2_CFLAGS=
+
+if test -z "$with_rasterlite2" -o "$with_rasterlite2" = "no"; then
+    AC_MSG_NOTICE([rasterlite2 support disabled])
+elif test "$with_rasterlite2" = "yes"; then
+    AC_CHECK_HEADERS(rasterlite2/rasterlite2.h)
+    if test "$ac_cv_header_rasterlite2_rasterlite2_h" = "yes"; then
+        AC_CHECK_LIB(rasterlite2,rl2_load_raw_tiles_into_dbms,HAVE_RASTERLITE2=yes,HAVE_RASTERLITE2=no,)
+        if test "$HAVE_RASTERLITE2" = "yes"; then
+            LIBS="$LIBS -lrasterlite2 -lsqlite3"
+        else
+            AC_MSG_ERROR([did not find rl2_load_raw_tiles_into_dbms])
+        fi
+    else
+        AC_MSG_ERROR([did not find rasterlite2.h])
+    fi
+else
+    AC_MSG_CHECKING([for include/rasterlite2/rasterlite2.h])
+    if test -f "$with_rasterlite2/include/rasterlite2/rasterlite2.h"; then
+        AC_MSG_RESULT([found])
+        AC_CHECK_LIB(rasterlite2,rl2_load_raw_tiles_into_dbms,HAVE_RASTERLITE2=yes,HAVE_RASTERLITE2=no,-L$with_rasterlite2/lib)
+        if test "$HAVE_RASTERLITE2" = "yes"; then
+            RASTERLITE2_CFLAGS="-I$with_rasterlite2/include"
+            LIBS="$LIBS -L$with_rasterlite2/lib -lrasterlite2 -lsqlite3"
+        else
+            AC_MSG_ERROR([did not find rl2_load_raw_tiles_into_dbms])
+        fi
+    else
+        AC_MSG_ERROR([did not find rasterlite2.h])
+    fi
+fi
+
+AC_SUBST([HAVE_RASTERLITE2], $HAVE_RASTERLITE2)
+AC_SUBST([RASTERLITE2_CFLAGS], $RASTERLITE2_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for PCRE2.
+dnl ---------------------------------------------------------------------------
+
+HAVE_PCRE2=no
+
+AC_ARG_WITH(pcre2,
+    [  --with-pcre2             Include libpcre2 support (REGEXP support for SQLite)],
+    ,,)
+
+if test "$with_pcre2" = "no"; then
+    AC_MSG_RESULT(disabled)
+    HAVE_PCRE2=no
+else
+    save_CPPFLAGS="$CPPFLAGS"
+    CPPFLAGS="$CPPFLAGS -DPCRE2_CODE_UNIT_WIDTH=8"
+    AC_CHECK_HEADERS([pcre2.h])
+    CPPFLAGS="$save_CPPFLAGS"
+    if test "$ac_cv_header_pcre2_h" = "no" ; then
+        if test "$with_pcre2" = "yes"; then
+            AC_MSG_ERROR([cannot find pcre2.h])
+        fi
+    else
+        AC_CHECK_LIB(pcre2-8,pcre2_compile_8,HAVE_PCRE2=yes,HAVE_PCRE2=no,)
+        if test "$HAVE_PCRE2" = "yes" ; then
+            HAVE_PCRE2=yes
+            LIBS="$LIBS -lpcre2-8"
+        else
+            if test "$with_pcre2" = "yes"; then
+                AC_MSG_ERROR([cannot find libpcre2])
+            fi
+        fi
+    fi
+fi
+
+AC_SUBST(HAVE_PCRE2)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for PCRE.
+dnl ---------------------------------------------------------------------------
+
+HAVE_PCRE=no
+
+AC_ARG_WITH(pcre,
+    [  --with-pcre             Include libpcre support (REGEXP support for SQLite)],
+    ,,)
+
+if test "$with_pcre" = "no"; then
+    AC_MSG_RESULT(disabled)
+    HAVE_PCRE=no
+elif test "$HAVE_PCRE2" = "no"; then
+    AC_CHECK_HEADERS([pcre.h])
+    if test "$ac_cv_header_pcre_h" = "no" ; then
+        if test "$with_pcre" = "yes"; then
+            AC_MSG_ERROR([cannot find pcre.h])
+        fi
+    else
+        AC_CHECK_LIB(pcre,pcre_compile,HAVE_PCRE=yes,HAVE_PCRE=no,)
+        if test "$HAVE_PCRE" = "yes" ; then
+            HAVE_PCRE=yes
+            LIBS="$LIBS -lpcre"
+        else
+            if test "$with_pcre" = "yes"; then
+                AC_MSG_ERROR([cannot find libpcre])
+            fi
+        fi
+    fi
+fi
+
+AC_SUBST(HAVE_PCRE)
+
+dnl ---------------------------------------------------------------------------
+dnl Check for Teigha.
+dnl ---------------------------------------------------------------------------
+
+TEIGHA_DIR=
+TEIGHA_CPPFLAGS=
+
+AC_MSG_CHECKING(Checking for Teigha)
+AC_ARG_WITH(teigha,
+    [  --with-teigha[=path] Include Teigha DWG/DGN support],
+    ,,)
+
+if test -z "$with_teigha" -o "$with_teigha" = "no"; then
+    AC_MSG_RESULT(disabled)
+    HAVE_TEIGHA=no
+else
+    AC_MSG_RESULT(enabled)
+
+    AC_ARG_WITH(teigha-plt,
+      [  --with-teigha-plt[=platform] Teigha platform],
+      ,,)
+    if test "x$with_teigha_plt" != "x" ; then
+        TEIGHA_DIR=$with_teigha
+        HAVE_TEIGHA=yes
+        TEIGHA_PLT=$with_teigha_plt
+        LIBS="${LIBS} ${TEIGHA_DIR}/bin/${TEIGHA_PLT}/TG_Db.tx"
+        if test -f "${TEIGHA_DIR}/bin/${TEIGHA_PLT}/TD_DbEntities.tx"; then
+            LIBS="${LIBS} ${TEIGHA_DIR}/bin/${TEIGHA_PLT}/TD_DbEntities.tx"
+            LIBS="${LIBS} ${TEIGHA_DIR}/lib/${TEIGHA_PLT}/libTD_DrawingsExamplesCommon.a"
+        fi
+        LIBS="${LIBS} ${TEIGHA_DIR}/lib/${TEIGHA_PLT}/libTG_ExamplesCommon.a"
+        LIBS="${LIBS} ${TEIGHA_DIR}/lib/${TEIGHA_PLT}/libTD_ExamplesCommon.a"
+        LIBS="${LIBS} ${TEIGHA_DIR}/lib/${TEIGHA_PLT}/libTD_Key.a"
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_Db"
+        if test -f "${TEIGHA_DIR}/bin/${TEIGHA_PLT}/libTD_DbCore.*"; then
+            LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_DbCore"
+        fi
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_DbRoot"
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_Gi"
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_SpatialIndex"
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_Root"
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_Ge"
+        if test -f "${TEIGHA_DIR}/bin/${TEIGHA_PLT}/libTD_Zlib.*"; then
+            LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_Zlib"
+        fi
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -lTD_Alloc"
+        LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -loless"
+        if test -f "${TEIGHA_DIR}/bin/${TEIGHA_PLT}/liblibcrypto.*"; then
+            LIBS="${LIBS} -L${TEIGHA_DIR}/bin/${TEIGHA_PLT} -llibcrypto"
+        fi
+        if test -f "${TEIGHA_DIR}/bin/${TEIGHA_PLT}/libTD_Db.so"; then
+            TEIGHA_CPPFLAGS="-D_TOOLKIT_IN_DLL_"
+        fi
+    else
+        AC_MSG_ERROR([--with-teigha-plt not specified])
+    fi
+fi
+
+AC_SUBST(TEIGHA_DIR)
+AC_SUBST(HAVE_TEIGHA)
+AC_SUBST(TEIGHA_CPPFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Select Informix DataBlade support
+dnl ---------------------------------------------------------------------------
+
+HAVE_IDB=no
+
+AC_ARG_WITH(idb,[  --with-idb=DIR        Include Informix DataBlade support (DIR points to Informix root)],,)
+
+if test x"${with_idb}" = x"no" ; then
+  AC_MSG_NOTICE(["IBM Informix DataBlade support disabled."])
+else
+  if test x"${with_idb}" = x ; then
+    with_idb=$INFORMIXDIR
+  fi
+
+  if test -e "${with_idb}/incl/c++/it.h" ; then
+
+    LIBS_DIRS="-L${with_idb}/lib/ -L${with_idb}/lib/esql"
+    LIBS_ESQL="-lifsql -lifasf -lifgen -lifos -lifgls -lifglx ${with_idb}/lib/esql/checkapi.o"
+    LIBS_LIBMI="-L${with_idb}/lib/dmi -lifdmi"
+    LIBS_CPPIF="-L${with_idb}/lib/c++ -lifc++"
+
+    IDB_INC="-I${with_idb}/incl/ -I${with_idb}/incl/dmi -I${with_idb}/incl/c++"
+    IDB_LIB="${LIBS_CPPIF} ${LIBS_LIBMI} ${LIBS_DIRS} ${LIBS_ESQL}"
+
+    ax_save_LIBS="${LIBS}"
+    LIBS="${IDB_LIB} -ldl -lcrypt"
+    AC_CHECK_LIB(ifsql,ifx_srvinfo,HAVE_IDB=yes,HAVE_IDB=no,)
+    LIBS="${ax_save_LIBS}"
+
+  fi
+
+  if test "${HAVE_IDB}" = "yes" ; then
+    AC_MSG_NOTICE([using Informix C++ client library from $with_idb.])
+  else
+    AC_MSG_NOTICE([IBM Informix DataBlade not supported.])
+  fi
+
+fi
+
+AC_SUBST(HAVE_IDB,${HAVE_IDB})
+AC_SUBST(IDB_INC,${IDB_INC})
+AC_SUBST(IDB_LIB,${IDB_LIB})
+
+dnl ---------------------------------------------------------------------------
+dnl Check if webp library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(webp,[  --with-webp[=ARG]    Include WEBP support (ARG=no, yes or libwebp install root path)],,)
+
+WEBP_SETTING=no
+
+if test "$with_webp" = "yes" -o "$with_webp" = "" ; then
+
+  AC_CHECK_LIB(webp,WebPDecodeRGB,WEBP_SETTING=yes,WEBP_SETTING=no,)
+
+  if test "$WEBP_SETTING" = "yes" ; then
+    LIBS="-lwebp $LIBS"
+  else
+    echo "libwebp not found - WEBP support disabled"
+  fi
+
+elif test "$with_webp" != "no" -a "$with_webp" != ""; then
+
+  AC_CHECK_LIB(webp,WebPDecodeRGB,WEBP_SETTING=yes,WEBP_SETTING=no,-L$with_webp/lib -lwebp)
+
+  if test "$WEBP_SETTING" = "yes" ; then
+    LIBS="-L$with_webp/lib -lwebp $LIBS"
+    EXTRA_INCLUDES="-I$with_webp/include $EXTRA_INCLUDES"
+  else
+    echo "libwebp not found - WEBP support disabled"
+  fi
+
+fi
+
+AC_SUBST(WEBP_SETTING,$WEBP_SETTING)
+
+if test "$WEBP_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="webp $OPT_GDAL_FORMATS"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if geos library is available.
+dnl ---------------------------------------------------------------------------
+
+GEOS_INIT(3.1.0)
+if test "${HAVE_GEOS}" = "yes" ; then
+  AC_MSG_NOTICE([Using C API from GEOS $GEOS_VERSION])
+  STRIP_SYSTEM_LIBRARY_PATHS("${GEOS_LIBS}")
+  GEOS_LIBS="$STRIPPED_LIBRARY_NAME"
+  LIBS="${GEOS_LIBS} ${LIBS}"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if SFCGAL library is available.
+dnl ---------------------------------------------------------------------------
+
+SFCGAL_INIT(1.2.2)
+if test "${HAVE_SFCGAL}" = "yes" ; then
+  AC_MSG_NOTICE([Using C API from SFCGAL $SFCGAL_VERSION])
+  STRIP_SYSTEM_LIBRARY_PATHS("${SFCGAL_LIBS}")
+  SFCGAL_LIBS="$STRIPPED_LIBRARY_NAME"
+  LIBS="${SFCGAL_LIBS} ${LIBS}"
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Check if QHull library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(qhull,[  --with-qhull[=ARG]     Include QHull support (ARG=no, yes, internal)],,)
+
+QHULL_SETTING=no
+
+if test "$with_qhull" = "no" ; then
+
+  AC_MSG_NOTICE([QHull support disabled.])
+
+elif test "$with_qhull" = "yes" -o "$with_qhull" = "" ; then
+
+  AC_ARG_WITH(qhull_pkgname,[  --with-qhull-pkgname[=ARG]     pkg-config name of the reentrant qhull library, typically qhull_r (default) or qhullstatic_r],,)
+
+  if test "x$with_qhull_pkgname" = "x" ; then
+    with_qhull_pkgname=qhull_r
+  fi
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([QHULL],[$with_qhull_pkgname], [HAVE_QHULL=yes], [HAVE_QHULL=no])
+
+  dnl First try with pkg-config
+  if test "$HAVE_QHULL" = "yes" ; then
+    QHULL_SETTING=external
+    CFLAGS="$CFLAGS $QHULL_CFLAGS"
+    LIBS="$LIBS $QHULL_LIBS"
+  else
+    AC_CHECK_HEADERS([libqhull_r/libqhull_r.h])
+    if test "$ac_cv_header_libqhull_r_libqhull_r_h" = "yes"; then
+      AC_CHECK_LIB(qhull_r,qh_new_qhull,QHULL_SETTING=yes,QHULL_SETTING=no,)
+      if test "$QHULL_SETTING" = "yes"; then
+        QHULL_SETTING=external
+        LIBS="-lqhull_r $LIBS"
+      fi
+    fi
+
+    if test "$QHULL_SETTING" = "no" ; then
+      if test "$with_qhull" = "yes"; then
+        AC_MSG_ERROR([--with-qhull requested, but library not found!])
+      else
+        QHULL_SETTING=internal
+      fi
+    fi
+  fi
+else
+  QHULL_SETTING=internal
+fi
+
+AC_SUBST([QHULL_SETTING],$QHULL_SETTING)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if opencl library is available.
+dnl ---------------------------------------------------------------------------
+
+OPENCL_SETTING=no
+OPENCL_FLAGS=
+OPENCL_LIB=
+
+AC_ARG_WITH(opencl,
+    [  --with-opencl[=ARG]       Include OpenCL (GPU) support],,,)
+
+AC_MSG_CHECKING([for OpenCL support])
+
+if test "$with_opencl" = "yes" ; then
+
+  AC_ARG_WITH(opencl-include,
+      [  --with-opencl-include=ARG OpenCL Include directory (with a CL subdirectory)],,,)
+
+  OPENCL_SETTING=yes
+
+  if test "x$with_opencl_include" = "x" ; then
+    OPENCL_FLAGS=-DHAVE_OPENCL
+    if test -z "`uname | grep Darwin`" ; then
+        AC_CHECK_HEADERS([CL/opencl.h])
+        if test "$ac_cv_header_CL_opencl_h" = "no" ; then
+            AC_MSG_ERROR([cannot find CL/opencl.h])
+        fi
+    fi
+  else
+    OPENCL_FLAGS="-I$with_opencl_include -DHAVE_OPENCL"
+  fi
+
+  AC_ARG_WITH(opencl-lib,
+      [  --with-opencl-lib=ARG   OpenCL Link Flags (i.e. -L/xxx -lOpenCL)],,,)
+
+  if test "x$with_opencl_lib" = "x" ; then
+    if test ! -z "`uname | grep Darwin`" ; then
+      OPENCL_LIB="-framework OpenCL"
+    else
+      AC_CHECK_LIB(OpenCL,clGetPlatformIDs,OPENCL_LIB=-lOpenCL,OPENCL_LIB=missing)
+      if test "$OPENCL_LIB" = "missing"; then
+        AC_MSG_ERROR([--with-opencl requested, but libraries not found!])
+      fi
+    fi
+  else
+    OPENCL_LIB="$with_opencl_lib"
+  fi
+
+fi
+
+AC_MSG_RESULT([$OPENCL_SETTING])
+
+AC_SUBST(OPENCL_FLAGS,  $OPENCL_FLAGS)
+AC_SUBST(OPENCL_LIB,    $OPENCL_LIB)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if FreeXL library is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(freexl,[  --with-freexl[=ARG]    Include freexl support (ARG=no, yes (default) or libfreexl install path)],,)
+
+AC_MSG_CHECKING([for FreeXL support])
+
+HAVE_FREEXL=no
+FREEXL_INCLUDE=
+
+if test "$with_freexl" = "" -o "$with_freexl" = "yes" ; then
+  AC_CHECK_HEADERS(freexl.h)
+  AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-lfreexl",FREEXL_LIBS=missing)
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-lfreexl -lm",FREEXL_LIBS=missing,-lm)
+  fi
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-lfreexl -liconv",FREEXL_LIBS=missing,-liconv)
+  fi
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-lfreexl -liconv -lm",FREEXL_LIBS=missing,-liconv -lm)
+  fi
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-lfreexl -liconv -lcharset",FREEXL_LIBS=missing,-liconv -lcharset)
+  fi
+
+  if test "$FREEXL_LIBS" != "missing" -a "$ac_cv_header_freexl_h" = "yes" ; then
+
+    # Check that freexl is recent enough
+    rm -f testrlist.*
+    echo '#include <freexl.h>' > testfreexl.c
+    echo 'int main(int argc, char** argv) { FreeXL_CellValue s; freexl_get_cell_value (0,0,0,&s); return 0; } ' >> testfreexl.c
+    if test -z "`${CC} ${CFLAGS} testfreexl.c -c 2>&1`" ; then
+        HAVE_FREEXL=yes
+        LIBS="$FREEXL_LIBS $LIBS"
+    else
+        HAVE_FREEXL=no
+        AC_MSG_RESULT([freexl too old. Needs freexl >= 1.0])
+    fi
+    rm -f testfreexl.*
+
+  else
+    HAVE_FREEXL=no
+    echo "libfreexl not found - FreeXL support disabled"
+  fi
+
+elif test "$with_freexl" != "no"; then
+
+  AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-L$with_freexl/lib -lfreexl",FREEXL_LIBS=missing,-L$with_freexl/lib)
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-L$with_freexl/lib -lfreexl -lm",FREEXL_LIBS=missing,-L$with_freexl/lib -lm)
+  fi
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-L$with_freexl/lib -lfreexl -liconv",FREEXL_LIBS=missing,-L$with_freexl/lib -liconv)
+  fi
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-L$with_freexl/lib -lfreexl -liconv -lm",FREEXL_LIBS=missing,-L$with_freexl/lib -liconv -lm)
+  fi
+
+  if test "$FREEXL_LIBS" = "missing"; then
+    unset ac_cv_lib_freexl_freexl_open
+    AC_CHECK_LIB(freexl,freexl_open,FREEXL_LIBS="-L$with_freexl/lib -lfreexl -liconv -lcharset",FREEXL_LIBS=missing,-L$with_freexl/lib -liconv -lcharset)
+  fi
+
+  if test "$FREEXL_LIBS" != "missing" -a -f "$with_freexl/include/freexl.h" ; then
+
+    # Check that freexl is recent enough
+    rm -f testrlist.*
+    echo '#include <freexl.h>' > testfreexl.c
+    echo 'int main(int argc, char** argv) { FreeXL_CellValue s; freexl_get_cell_value (0,0,0,&s); return 0; } ' >> testfreexl.c
+    if test -z "`${CC} ${CFLAGS} -I$with_freexl/include testfreexl.c -c 2>&1`" ; then
+        HAVE_FREEXL=yes
+        LIBS="$FREEXL_LIBS $LIBS"
+        FREEXL_INCLUDE="-I$with_freexl/include"
+    else
+        HAVE_FREEXL=no
+        AC_MSG_RESULT([freexl too old. Needs freexl >= 1.0])
+    fi
+    rm -f testfreexl.*
+
+  else
+    HAVE_FREEXL=no
+    echo "libfreexl not found - FreeXL support disabled"
+  fi
+
+fi
+
+AC_SUBST(HAVE_FREEXL,  $HAVE_FREEXL)
+AC_SUBST(FREEXL_INCLUDE,  $FREEXL_INCLUDE)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if libjson-c is available.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(libjson-c,[  --with-libjson-c[=ARG]       Include libjson-c support (ARG=internal or libjson-c directory)],,)
+
+if test "$with_libjson_c" = "external" -o "$with_libjson_c" = "" -o "$with_libjson_c" = "yes" ; then
+  AC_CHECK_LIB(json-c,json_object_set_serializer,LIBJSONC_SETTING=external,LIBJSONC_SETTING=internal,)
+elif test "$with_libjson_c" = "internal" ; then
+  LIBJSONC_SETTING=internal
+elif test "$with_libjson_c" != "no"; then
+  LIBS="-L$with_libjson_c/lib $LIBS"
+  AC_CHECK_LIB(json-c,json_object_set_serializer,LIBJSONC_SETTING=external,LIBJSONC_SETTING=internal,-L$with_libjson_c/lib)
+else
+  AC_MSG_ERROR([libjson-c (internal or external) is required])
+fi
+
+if test "$LIBJSONC_SETTING" = "external" ; then
+  AC_MSG_RESULT([using pre-installed libjson-c])
+  LIBS="-ljson-c $LIBS"
+  if test "$with_libjson_c" != "" -a "$with_libjson_c" != "yes" -a "$with_libjson_c" != "external" ; then
+    JSON_INCLUDE="-I$with_libjson_c/include/json-c"
+  elif test -f "/usr/include/json-c/json.h"; then
+    JSON_INCLUDE="-I/usr/include/json-c"
+  elif test -f "/usr/local/include/json-c/json.h"; then
+    JSON_INCLUDE="-I/usr/local/include/json-c"
+  else
+    AC_MSG_ERROR([could not find json-c/json.h])
+  fi
+else
+    JSON_INCLUDE="-I\$(GDAL_ROOT)/ogr/ogrsf_frmts/geojson/libjson"
+    AC_MSG_RESULT([using internal libjson-c code])
+fi
+
+AC_SUBST(LIBJSONC_SETTING,$LIBJSONC_SETTING)
+AC_SUBST(JSON_INCLUDE,$JSON_INCLUDE)
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if we must enable PAM
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([whether to enable PAM])
+
+AC_ARG_WITH(pam,[  --without-pam         Disable PAM (.aux.xml) support],,)
+
+export PAM_SETTING=
+
+if test "x$with_pam" = "xno" ; then
+  AC_MSG_RESULT([no])
+else
+  AC_MSG_RESULT([yes])
+  PAM_SETTING=-DPAM_ENABLED
+fi
+
+AC_SUBST(PAM_SETTING, $PAM_SETTING)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if the PDF driver should be built as a plugin
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([whether to build PDF driver as a plugin])
+
+AC_ARG_ENABLE(pdf_plugin,
+              AS_HELP_STRING([--enable-pdf-plugin],
+                             [enable PDF driver as a plugin (included in libgdal by default)]),,)
+
+PDF_PLUGIN=no
+if test "x$enable_pdf_plugin" = "xyes" ; then
+
+  if test "$with_libtool" = "yes"; then
+    AC_MSG_ERROR([--enable-pdf-plugin not supported together --with-libtool])
+  fi
+
+  PDF_PLUGIN=yes
+
+  AC_MSG_RESULT([yes])
+else
+  AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(PDF_PLUGIN, $PDF_PLUGIN)
+if test "$PDF_PLUGIN" != "yes" ; then
+  if test "x$INTERNAL_FORMAT_pdf_ENABLED" = "xyes"; then
+    if test "$LIBZ_SETTING" != "no" ; then
+      GDALFORMATS_ENABLED="$GDALFORMATS_ENABLED pdf"
+    fi
+  fi
+fi
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check if libpoppler is available
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(poppler,[  --with-poppler[=ARG]    Include poppler(for PDF) support (ARG=no(default), yes or poppler install path)],,)
+
+HAVE_POPPLER=no
+POPPLER_MAJOR_VERSION=
+POPPLER_MINOR_VERSION=
+
+AC_MSG_CHECKING([for poppler])
+
+if test "$with_poppler" != "no" -a "$with_poppler" != ""; then
+
+    PKG_PROG_PKG_CONFIG([0.21])
+    PKG_CHECK_MODULES([POPPLER], [poppler >= 0.23.0],
+            [POPPLER_VERSION=`$PKG_CONFIG --modversion poppler`], [POPPLER_VERSION=])
+    if test "$POPPLER_VERSION" != ""; then
+        HAVE_POPPLER=yes
+        POPPLER_MAJOR_VERSION=`echo $POPPLER_VERSION | cut -d'.' -f1`
+        POPPLER_MINOR_VERSION=`echo $POPPLER_VERSION | cut -d'.' -f2 | sed -e 's/^0//'`
+        POPPLER_CFLAGS=`echo $POPPLER_CFLAGS $POPPLER_CFLAGS | sed "s/include\/poppler/include/"`
+    fi
+else
+    AC_MSG_RESULT([disabled])
+fi
+
+if test "$HAVE_POPPLER" = "yes" -a "$PDF_PLUGIN" = "no"; then
+    LIBS="${POPPLER_LIBS} ${LIBS}"
+fi
+
+AC_SUBST(HAVE_POPPLER, $HAVE_POPPLER)
+AC_SUBST(POPPLER_MAJOR_VERSION, $POPPLER_MAJOR_VERSION)
+AC_SUBST(POPPLER_MINOR_VERSION, $POPPLER_MINOR_VERSION)
+AC_SUBST(POPPLER_CFLAGS, $POPPLER_CFLAGS)
+AC_SUBST(POPPLER_PLUGIN_LIB, $POPPLER_LIBS)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if libpodofo is available
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(podofo,[  --with-podofo[=ARG]    Include podofo(for PDF) support (ARG=no(default), yes or podofo install path)],,)
+
+HAVE_PODOFO=no
+
+AC_MSG_CHECKING([for podofo])
+
+if test "$with_podofo" != "no" -a "$with_podofo" != ""; then
+
+    AC_ARG_WITH(podofo-lib,
+      [  --with-podofo-lib=ARG   podofo Link Flags (i.e. -L/xxx -lpodofo ...). Mainly for static libpodofo],,,)
+
+    if test "$with_podofo" = "yes" ; then
+        TEST_PODOFO_INC="-I/usr/include/podofo"
+        PODOFO_LIB="-lpodofo"
+    else
+        TEST_PODOFO_INC="-I$with_podofo/include -I$with_podofo/include/podofo"
+        PODOFO_LIB="-L$with_podofo/lib -lpodofo"
+    fi
+
+    if test "x$with_podofo_lib" = "x" ; then
+        rm -f testpodofo.*
+        echo '#include <podofo.h>' > testpodofo.cpp
+        echo 'int main(int argc, char** argv) { PoDoFo::PdfError::EnableDebug( 0 ); return 0; } ' >> testpodofo.cpp
+        ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testpodofo.cpp -o testpodofo ${TEST_PODOFO_INC} ${PODOFO_LIB} 2>/dev/null
+        RETVAL=$?
+        if test $RETVAL -eq 0; then
+            HAVE_PODOFO=yes
+            if test "$PDF_PLUGIN" = "no"; then
+                LIBS="${PODOFO_LIB} ${LIBS}"
+            fi
+            PODOFO_INC=$TEST_PODOFO_INC
+            PODOFO_PLUGIN_LIB="${PODOFO_LIB}"
+            AC_MSG_RESULT([yes])
+        fi
+        rm -f testpodofo.*
+        rm -f testpodofo
+    fi
+
+    if test "$HAVE_PODOFO" = "no"; then
+        if test "x$with_podofo_lib" != "x" ; then
+            PODOFO_LIB="$with_podofo_lib"
+        else
+            # This may be a static libpodofo.a, so add dependent libraries.
+            PODOFO_LIB="$PODOFO_LIB -lfreetype -lfontconfig -lpthread"
+        fi
+
+        AC_ARG_WITH(podofo-extra-lib-for-test,
+          [  --with-podofo-extra-lib-for-test=ARG   Additional libraries to pass the detection test, but not used for libgdal linking (i.e. -ljpeg ...). Mainly for static libpodofo],,,)
+
+        if test "x$with_podofo_extra_lib_for_test" = "x" ; then
+            TEST_PODOFO_LIB="$PODOFO_LIB"
+        else
+            TEST_PODOFO_LIB="$PODOFO_LIB $with_podofo_extra_lib_for_test"
+        fi
+
+        rm -f testpodofo.*
+        echo '#include <podofo.h>' > testpodofo.cpp
+        echo 'int main(int argc, char** argv) { PoDoFo::PdfError::EnableDebug( 0 ); return 0; } ' >> testpodofo.cpp
+        ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testpodofo.cpp -o testpodofo ${TEST_PODOFO_INC} ${TEST_PODOFO_LIB} 2>/dev/null
+        RETVAL=$?
+        if test $RETVAL -eq 0; then
+            HAVE_PODOFO=yes
+            if test "$PDF_PLUGIN" = "no"; then
+                LIBS="${PODOFO_LIB} ${LIBS}"
+            fi
+            PODOFO_INC=$TEST_PODOFO_INC
+            PODOFO_PLUGIN_LIB="${PODOFO_LIB}"
+            AC_MSG_RESULT([yes])
+        else
+            AC_MSG_RESULT([no])
+        fi
+        rm -f testpodofo.*
+        rm -f testpodofo
+    fi
+else
+    AC_MSG_RESULT([disabled])
+fi
+
+AC_SUBST(HAVE_PODOFO, $HAVE_PODOFO)
+AC_SUBST(PODOFO_INC, $PODOFO_INC)
+AC_SUBST(PODOFO_PLUGIN_LIB, $PODOFO_PLUGIN_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Check if libpdfium is available
+dnl
+dnl Support for open-source PDFium library
+dnl
+dnl Copyright (C) 2015 Klokan Technologies GmbH (http://www.klokantech.com/)
+dnl Author: Martin Mikita <martin.mikita@klokantech.com>, xmikit00 @ FIT VUT Brno
+dnl Copyright 2019 Even Rouault
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(pdfium,[  --with-pdfium[=ARG]    Include pdfium (for PDF) support (ARG=no(default), yes or pdfium install path)],,)
+
+HAVE_PDFIUM=no
+
+AC_MSG_CHECKING([for pdfium])
+
+if test "$with_pdfium" != "no" -a "$with_pdfium" != ""; then
+
+    if test "$with_pdfium" = "yes" ; then
+        PDFIUM_INC="-I/usr/include/pdfium"
+        PDFIUM_LIB="-lpdfium"
+    else
+        PDFIUM_INC="-I$with_pdfium/include/pdfium"
+        PDFIUM_LIB="-L$with_pdfium/lib -lpdfium"
+    fi
+
+    PDFIUM_LIB="$PDFIUM_LIB -lopenjp2 -ljpeg -lpng -lz -llcms2 -lpthread -lm -lstdc++"
+
+    if test ! -z "`uname | grep Darwin`" ; then
+        PDFIUM_LIB="-stdlib=libstdc++ $PDFIUM_LIB"
+    fi
+
+    rm -f testpdfium.*
+    echo '#include "public/fpdfview.h"' > testpdfium.cpp
+    echo '#include "core/fpdfapi/page/cpdf_page.h"' >> testpdfium.cpp
+    echo '#include "constants/transparency.h"' >> testpdfium.cpp # specific to pdfium_build_gdal_3_2
+    echo 'int main(int argc, char** argv) { FPDF_InitLibrary(); FPDF_DestroyLibrary(); return 0; } ' >> testpdfium.cpp
+    TEST_CXX_FLAGS=""
+    if test ! -z "`uname | grep Darwin`" ; then
+        TEST_CXX_FLAGS="$TEST_CXX_FLAGS -stdlib=libstdc++"
+    fi
+    if ${CXX} ${CXXFLAGS} ${CPPFLAGS} $TEST_CXX_FLAGS -std=c++14 testpdfium.cpp -o testpdfium ${PDFIUM_INC} ${PDFIUM_LIB} >/dev/null 2>/dev/null; then
+        HAVE_PDFIUM=yes
+        CXXFLAGS="$TEST_CXX_FLAGS $CXXFLAGS"
+        if test "$PDF_PLUGIN" = "no"; then
+            LIBS="${PDFIUM_LIB} ${LIBS}"
+        fi
+        PDFIUM_PLUGIN_LIB="${PDFIUM_LIB}"
+        AC_MSG_RESULT([yes])
+    fi
+    rm -f testpdfium.*
+    rm -f testpdfium
+
+    if test "$HAVE_PDFIUM" = "no" -a "$with_pdfium" != ""; then
+        AC_MSG_ERROR([pdfium requested but not found. Must come from https://github.com/rouault/pdfium_build_gdal_3_4])
+    fi
+else
+    AC_MSG_RESULT([disabled])
+fi
+
+AC_SUBST(HAVE_PDFIUM, $HAVE_PDFIUM)
+AC_SUBST(PDFIUM_INC, $PDFIUM_INC)
+AC_SUBST(PDFIUM_PLUGIN_LIB, $PDFIUM_PLUGIN_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl Get/override version.
+dnl ---------------------------------------------------------------------------
+
+
+AC_ARG_WITH(gdal-ver,[  --with-gdal-ver=ARG   Override GDAL version ],,)
+GDAL_VERSION_MAJOR=`grep "#*define.GDAL_VERSION_MAJOR.*" gcore/gdal_version.h.in | awk '{print $4}'`
+GDAL_VERSION_MINOR=`grep "#*define.GDAL_VERSION_MINOR.*" gcore/gdal_version.h.in | awk '{print $4}'`
+GDAL_VERSION_REV=`grep "#*define.GDAL_VERSION_REV.*" gcore/gdal_version.h.in | awk '{print $4}'`
+
+AC_MSG_RESULT([checking GDAL version information from gdal_version.h.in: $GDAL_VERSION_MAJOR.$GDAL_VERSION_MINOR.$GDAL_VERSION_REV])
+
+AC_SUBST(GDAL_VERSION_MAJOR,    "$GDAL_VERSION_MAJOR")
+AC_SUBST(GDAL_VERSION_MINOR,    "$GDAL_VERSION_MINOR")
+AC_SUBST(GDAL_VERSION_REV,    "$GDAL_VERSION_REV")
+
+if test "x$with_gdal_ver" != "x"; then
+
+  GDAL_VER=$with_gdal_ver
+  AC_MSG_RESULT([  overridden GDAL version: $GDAL_VER])
+else
+
+  GDAL_VER=$GDAL_VERSION_MAJOR.$GDAL_VERSION_MINOR.$GDAL_VERSION_REV
+
+fi
+
+AC_SUBST(GDAL_VER, $GDAL_VER)
+echo $GDAL_VER > VERSION
+
+dnl ---------------------------------------------------------------------------
+dnl MacOS X Framework Build
+
+if test ! -z "`uname | grep Darwin`" ; then
+
+  CXXFLAGS="$ARCHFLAGS $CXXFLAGS"
+  CFLAGS="$ARCHFLAGS $CFLAGS"
+  LIBS="$ARCHFLAGS $LIBS"
+
+  MACOSX_FRAMEWORK=no
+  AC_ARG_WITH(macosx-framework,[  --with-macosx-framework         Build and install GDAL as a Mac OS X Framework],,)
+  AC_MSG_CHECKING([for Mac OS X Framework build])
+  if test "$with_macosx_framework" = yes ; then
+    MACOSX_FRAMEWORK=yes
+    AC_MSG_RESULT([enabled])
+    AC_DEFINE_UNQUOTED(MACOSX_FRAMEWORK,1, [Define for Mac OSX Framework build])
+    prefix="/Library/Frameworks/GDAL.framework/Versions/${GDAL_VERSION_MAJOR}.${GDAL_VERSION_MINOR}"
+    exec_prefix='${prefix}'
+    includedir='${prefix}/Headers'
+    datadir='${prefix}/Resources/gdal'
+    libdir='${exec_prefix}'
+    bindir='${exec_prefix}/Programs'
+    docdir='${prefix}/Resources/doc'
+    mandir='${prefix}/Resources/man'
+  else
+    AC_MSG_RESULT([disabled])
+  fi
+  AC_SUBST(MACOSX_FRAMEWORK, $MACOSX_FRAMEWORK)
+fi
+
+AC_SUBST(EXTRA_INCLUDES,$EXTRA_INCLUDES)
+
+dnl ---------------------------------------------------------------------------
+dnl Check whether we need to add specific suffix for executables (.EXE when
+dnl building for Windows). This test should work for the case of
+dnl cross-compilation too.
+dnl ---------------------------------------------------------------------------
+case "${host_os}" in
+    cygwin* | mingw* | pw32*)
+      EXE_EXT=.exe
+      SO_EXT=dll
+      ;;
+    *)
+      EXE_EXT=
+      ;;
+esac
+
+AC_SUBST(EXE_EXT)
+AC_SUBST(SO_EXT)
+
+dnl ---------------------------------------------------------------------------
+dnl Which "true" program should we use?
+dnl ---------------------------------------------------------------------------
+BINTRUE=/bin/true
+
+if test -f /bin/true.exe ; then
+  BINTRUE=/bin/true.exe
+fi
+if test -f /usr/bin/true ; then
+  BINTRUE=/usr/bin/true
+fi
+
+export BINTRUE
+
+AC_SUBST(BINTRUE,$BINTRUE)
+
+dnl ---------------------------------------------------------------------------
+dnl Capture GDAL_PREFIX for the cpl_config.h include file.
+dnl ---------------------------------------------------------------------------
+
+if test "$prefix" = "NONE" ; then
+  GDAL_PREFIX=/usr/local
+else
+  GDAL_PREFIX=${prefix}
+fi
+
+export GDAL_PREFIX
+AC_DEFINE_UNQUOTED(GDAL_PREFIX,["]$GDAL_PREFIX["], [--prefix directory for GDAL install])
+
+dnl ---------------------------------------------------------------------------
+dnl NG Python bindings.
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(python,[  --with-python=ARG   Enable python bindings (ARG=yes, no, or path to python binary)],,)
+
+AC_MSG_CHECKING([for python bindings])
+if test "$with_python" = "yes" ; then
+  dnl
+  dnl Check for Python executable in PATH
+  dnl
+  AC_CHECK_PROGS([PYTHON], [python python3 python2])
+  if test "x$PYTHON" = "x"; then
+    AC_MSG_ERROR([--with-python requested, but Python not found!])
+  fi
+elif test "x$with_python" != "x" -a "$with_python" != "no" ; then
+  PYTHON="$with_python"
+  if test "`$PYTHON -c 'print(1)'`" != "1"; then
+    AC_MSG_ERROR([--with-python requested, but Python not found!])
+  fi
+  AC_MSG_RESULT([enabled])
+else
+  PYTHON=""
+  AC_MSG_RESULT([disabled])
+fi
+
+if test "x$PYTHON" != "x"; then
+  BINDINGS="python $BINDINGS"
+
+  AC_MSG_CHECKING([for python setuptools])
+  SETUPTEST='try:
+  import setuptools
+  print(1)
+except ImportError:
+  pass'
+  PY_HAVE_SETUPTOOLS=`$PYTHON -c "$SETUPTEST"`
+  if test "$PY_HAVE_SETUPTOOLS" = "1"; then
+    AC_MSG_RESULT([found])
+  else
+    AC_MSG_RESULT([not found])
+  fi
+fi
+
+AC_SUBST([PY_HAVE_SETUPTOOLS])
+AC_SUBST([BINDINGS])
+
+dnl ---------------------------------------------------------------------------
+dnl Java support
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(java,[  --with-java       Include Java support (ARG=yes, no or JDK home path)  [[default=no]]],,)
+
+AC_MSG_CHECKING([whether we should include Java support])
+
+JAVA_HOME=""
+JAVA_INC=""
+mac_java_fw=""
+
+if test "x$with_java" = "xyes"; then
+
+dnl Ubuntu
+    JAVA_6_TEST_DIR=
+    JAVA_7_TEST_DIR=
+    JAVA_8_TEST_DIR=
+    JAVA_MAC_TEST_DIR=
+    case "$host_cpu" in
+        i*86*)
+            JAVA_6_TEST_DIR=/usr/lib/jvm/java-6-openjdk-i386
+            JAVA_7_TEST_DIR=/usr/lib/jvm/java-7-openjdk-i386
+            JAVA_8_TEST_DIR=/usr/lib/jvm/java-8-openjdk-i386
+            ;;
+        x86_64*)
+            JAVA_6_TEST_DIR=/usr/lib/jvm/java-6-openjdk-amd64
+            JAVA_7_TEST_DIR=/usr/lib/jvm/java-7-openjdk-amd64
+            JAVA_8_TEST_DIR=/usr/lib/jvm/java-8-openjdk-amd64
+            ;;
+        *)
+            ;;
+    esac
+    case "${host_os}" in
+      darwin*)
+        JAVA_MAC_TEST_DIR=$(/usr/libexec/java_home)
+        ;;
+    esac
+
+    if test "x$JAVA_8_TEST_DIR" != "x" -a -d "$JAVA_8_TEST_DIR/include"; then
+        with_java="$JAVA_8_TEST_DIR"
+
+    elif test "x$JAVA_7_TEST_DIR" != "x" -a -d "$JAVA_7_TEST_DIR/include"; then
+        with_java="$JAVA_7_TEST_DIR"
+
+    elif test "x$JAVA_6_TEST_DIR" != "x" -a -d "$JAVA_6_TEST_DIR/include"; then
+        with_java="$JAVA_6_TEST_DIR"
+
+    elif test -d /usr/lib/jvm/java-6-openjdk; then
+        with_java="/usr/lib/jvm/java-6-openjdk"
+
+dnl RHEL6
+    elif test -d /usr/lib/jvm/java-openjdk; then
+        with_java="/usr/lib/jvm/java-openjdk"
+
+
+dnl OpenSolaris
+    elif test -d /usr/java; then
+        with_java="/usr/java"
+
+dnl Mac OS X
+    elif test "x$JAVA_MAC_TEST_DIR" != "x"; then
+        if test -d "$JAVA_MAC_TEST_DIR/bundle"; then
+            # Mac default 1.6.0_x framework
+            # test for ./bundle first, since older installs also have ./include
+            with_java="$JAVA_MAC_TEST_DIR"
+            mac_java_fw="JavaVM"
+        elif test -d "$JAVA_MAC_TEST_DIR/include"; then
+            # Oracle Java install
+            with_java="$JAVA_MAC_TEST_DIR"
+        fi
+    else
+        AC_MSG_ERROR("cannot find JDK root directory.")
+    fi
+
+    if test \! -d "$with_java/include" && test \! -d "$with_java/bundle"; then
+        AC_MSG_ERROR("$with_java is not a valid JDK.")
+    fi
+fi
+
+if test "x$JAVA_INC" != "x"; then
+    AC_MSG_RESULT([yes])
+elif test "x$with_java" != "x" -a "x$with_java" != "xno"; then
+
+    if test -d "$with_java/bundle" && test -d "/System/Library/Frameworks/JavaVM.framework/Headers"; then
+        # Mac default 1.6.0_x framework
+        # test for ./bundle first, since older installs also have ./include
+        JAVA_HOME="$with_java"
+        JAVA_INC="-I/System/Library/Frameworks/JavaVM.framework/Headers"
+        mac_java_fw="JavaVM"
+        AC_MSG_RESULT([yes])
+    elif test -d "$with_java/include"; then
+        if test -d "$with_java/include/linux"; then
+            JAVA_HOME="$with_java"
+            JAVA_INC="-I$JAVA_HOME/include -I$JAVA_HOME/include/linux"
+            AC_MSG_RESULT([yes])
+        elif test -d "$with_java/include/solaris"; then
+            JAVA_HOME="$with_java"
+            JAVA_INC="-I$JAVA_HOME/include -I$JAVA_HOME/include/solaris"
+            AC_MSG_RESULT([yes])
+        elif test -d "$with_java/include/freebsd"; then
+            JAVA_HOME="$with_java"
+            JAVA_INC="-I$JAVA_HOME/include -I$JAVA_HOME/include/freebsd"
+            AC_MSG_RESULT([yes])
+        elif test -d "$with_java/include/darwin"; then
+            # Oracle Java install, use instead of Mac default 1.6.0_x
+            JAVA_HOME="$with_java"
+            JAVA_INC="-I$JAVA_HOME/include -I$JAVA_HOME/include/darwin"
+            AC_MSG_RESULT([yes])
+        else
+            AC_MSG_ERROR("Cannot find $with_java/include/linux or solaris or freebsd or darwin directory.")
+        fi
+    else
+        AC_MSG_ERROR("Cannot find $with_java/include or <mac_java_framework>/Headers directory.")
+    fi
+
+else
+    AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(JAVA_HOME,$JAVA_HOME)
+AC_SUBST(JAVA_INC,$JAVA_INC)
+
+dnl ---------------------------------------------------------------------------
+dnl HDFS support
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(hdfs,[  --with-hdfs[=ARG]        Include HDFS support (ARG=Path or no)],,)
+
+HDFS_ENABLED=no
+
+if test -z "$with_hdfs" -o "$with_hdfs" = "no" ; then
+     AC_MSG_RESULT([HDFS support not requested.])
+else
+     if test "$JAVA_HOME"; then
+          JNI_LIB="-L$(find $JAVA_HOME | grep libjvm | head -1 | sed "s/[[^/]]*$//") -ljvm"
+     else
+          AC_MSG_ERROR([HDFS support requires java support (--with-java). $JAVA_HOME])
+     fi
+     if echo $JNI_LIB | grep $JAVA_HOME; then
+          AC_MSG_CHECKING([for HDFS in $with_hdfs])
+          AC_CHECK_LIB(hdfs,hdfsConnect,HAVE_HDFS_LIB=yes,HAVE_HDFS_LIB=no,$JNI_LIB -L$with_hdfs/lib/native)
+          AC_CHECK_FILE($with_hdfs/include/hdfs.h,HAVE_HDFS_HEADER=yes,HAVE_HDFS_HEADER=no)
+          if test "$HAVE_HDFS_LIB" = "yes" -a "$HAVE_HDFS_HEADER" = "yes"; then
+               AC_MSG_RESULT([HDFS support enabled.])
+               HDFS_ENABLED=yes
+               HDFS_LIB="-L$with_hdfs/lib/native -lhdfs"
+               HDFS_INC="-I$with_hdfs/include"
+          else
+               AC_MSG_ERROR([HDFS support not enabled.])
+          fi
+     else
+          AC_MSG_ERROR([Unable to find libjvm.])
+     fi
+fi
+
+AC_SUBST(HDFS_ENABLED,$HDFS_ENABLED)
+AC_SUBST(HDFS_LIB,$HDFS_LIB)
+AC_SUBST(HDFS_INC,$HDFS_INC)
+AC_SUBST(JNI_LIB,$JNI_LIB)
+
+dnl ---------------------------------------------------------------------------
+dnl TileDB support
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(tiledb,[  --with-tiledb[=ARG]    Include TileDB support (ARG=no, yes or tiledb install root path)],,)
+
+TILEDB_SETTING=no
+TILEDB_CFLAGS=
+
+if test "$with_tiledb" = "yes" -o "$with_tiledb" = "" ; then
+
+  AC_CHECK_LIB(tiledb,tiledb_coords,TILEDB_SETTING=yes,TILEDB_SETTING=no,)
+
+  if test "$TILEDB_SETTING" = "yes" ; then
+    LIBS="-ltiledb $LIBS"
+  else
+    echo "libtiledb not found - TileDB support disabled"
+  fi
+
+elif test "$with_tiledb" != "no" -a "$with_tiledb" != ""; then
+
+  AC_CHECK_LIB(tiledb,tiledb_coords,TILEDB_SETTING=yes,TILEDB_SETTING=no,-L$with_tiledb/lib -ltiledb)
+
+  if test "$TILEDB_SETTING" = "yes" ; then
+    LIBS="-L$with_tiledb/lib -ltiledb $LIBS"
+    TILEDB_CFLAGS="-I$with_tiledb/include"
+  else
+    echo "libtiledb not found - TileDB support disabled"
+  fi
+fi
+
+if test "$TILEDB_SETTING" != "no" ; then
+
+  AC_LANG_PUSH([C++])
+  SAVED_CXXFLAGS=$CXXFLAGS
+  CXXFLAGS="$CXXFLAGS $TILEDB_CFLAGS"
+  AC_MSG_CHECKING([if tiledb/tiledb can be included without additional flags])
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+    [[#include "tiledb/tiledb"]])],
+    [TILEDB_CAN_BE_INCLUDED="yes"]
+    [AC_MSG_RESULT([yes])],
+    [TILEDB_CAN_BE_INCLUDED="no"]
+    [AC_MSG_RESULT([no])])
+  CXXFLAGS=$SAVED_CXXFLAGS
+  AC_LANG_POP([C++])
+
+  if test "$TILEDB_CAN_BE_INCLUDED" = "no"; then
+    AC_LANG_PUSH([C++])
+    SAVED_CXXFLAGS=$CXXFLAGS
+    CXXFLAGS="$CXXFLAGS $TILEDB_CFLAGS -std=c++17"
+    AC_MSG_CHECKING([if tiledb/tiledb can be included with -std=c++17])
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+      [[#include "tiledb/tiledb"]])],
+      [TILEDB_CAN_BE_INCLUDED="yes"]
+      [AC_MSG_RESULT([yes])],
+      [TILEDB_CAN_BE_INCLUDED="no"]
+      [AC_MSG_RESULT([no])])
+    CXXFLAGS=$SAVED_CXXFLAGS
+    AC_LANG_POP([C++])
+
+    if test "$TILEDB_CAN_BE_INCLUDED" = "yes"; then
+      TILEDB_CFLAGS="$TILEDB_CFLAGS -std=c++17"
+    fi
+  fi
+
+  OPT_GDAL_FORMATS="tiledb $OPT_GDAL_FORMATS"
+fi
+
+AC_SUBST(TILEDB_SETTING,$TILEDB_SETTING)
+AC_SUBST(TILEDB_CFLAGS,$TILEDB_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Select Rasdaman or disable driver.
+dnl ---------------------------------------------------------------------------
+
+RASDAMAN_ENABLED=no
+
+AS_MESSAGE([checking whether we should include rasdaman support...])
+AC_ARG_WITH(rasdaman,
+[  --with-rasdaman[=DIR]        Include rasdaman support (DIR is rasdaman's install dir).],,)
+
+if test "$with_rasdaman" = "yes" ; then
+
+  AC_CHECK_LIB(raslib,main,RASDAMAN_ENABLED=yes,,,)
+
+  if test -n "$RASDAMAN_ENABLED" ; then
+      RASDAMAN_LIB="-lrasodmg -lclientcomm -lcompression -lnetwork -lraslib"
+      OPT_GDAL_FORMATS="rasdaman $OPT_GDAL_FORMATS"
+      AC_MSG_RESULT([        using rasdaman from system libs.])
+  else
+      AC_MSG_WARN([        rasdaman not found in system libs... use --with-rasdaman=DIR.])
+  fi
+
+elif test -n "$with_rasdaman" -a "$with_rasdaman" != "no" ; then
+
+  RASDAMAN_DIR=$with_rasdaman
+
+  if test -f $RASDAMAN_DIR/include/rasdaman.hh -a -d$RASDAMAN_DIR/lib ; then
+      RASDAMAN_INC=-I$RASDAMAN_DIR/include
+      RASDAMAN_LIB="-L$RASDAMAN_DIR/lib -lrasodmg -lclientcomm -lcompression -lnetwork -lraslib"
+  else
+      AC_MSG_ERROR("Could not find rasdaman.hh or libraslib.a in $RASDAMAN_DIR.")
+  fi
+
+  RASDAMAN_ENABLED=yes
+  OPT_GDAL_FORMATS="rasdaman $OPT_GDAL_FORMATS"
+  AC_MSG_RESULT([        using rasdaman from $RASDAMAN_DIR.])
+
+else
+
+  AC_MSG_RESULT([        rasdaman support not requested.])
+fi
+
+AC_SUBST(RASDAMAN_ENABLED,$RASDAMAN_ENABLED)
+AC_SUBST(RASDAMAN_INC,    $RASDAMAN_INC)
+AC_SUBST(RASDAMAN_LIB,    $RASDAMAN_LIB)
+
+
+dnl ---------------------------------------------------------------------------
+dnl brunsli support
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(brunsli,[  --with-brunsli    Include brunsli support via libbrunsli library],,)
+
+BRUNSLI_ENABLED=no
+
+if test "$with_brunsli" != "" -a "$with_brunsli" != "no" ; then
+  BRUNSLI_ENABLED="yes"
+  AC_SUBST(BRUNSLI_ENABLED, $BRUNSLI_ENABLED)
+  AC_SUBST(BRUNSLI_INCLUDE, -I$prefix/include)
+  AC_SUBST(BRUNSLI_LIB, "-lbrunslienc-c -lbrunslidec-c")
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl RDB support
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(rdb,[  --with-rdb[=ARG]    Include RDB support (ARG=no, yes or RDB SDK root path)],,)
+
+RDB_SETTING=no
+
+if test "$with_rdb" = "yes" -o "$with_rdb" = "" ; then
+
+  AC_CHECK_LIB(rdb,rdb_library_name,RDB_SETTING=yes,RDB_SETTING=no,)
+
+  if test "$RDB_SETTING" = "yes" ; then
+    LIBS="-lrdb $LIBS"
+  else
+    echo "librdb not found - RDB support disabled"
+  fi
+
+elif test "$with_rdb" != "no" -a "$with_rdb" != ""; then
+
+  AC_CHECK_LIB(rdb,rdb_library_name,RDB_SETTING=yes,RDB_SETTING=no,-L$with_rdb/library -lrdb)
+
+  if test "$RDB_SETTING" = "yes" ; then
+    LIBS="-L$with_rdb/library -lrdb $LIBS"
+    EXTRA_INCLUDES="-I$with_rdb/interface/cpp/ -I$with_rdb/interface/c/ $EXTRA_INCLUDES"
+  else
+    echo "librdb not found - RDB support disabled"
+  fi
+
+fi
+
+AC_SUBST(RDB_SETTING,$RDB_SETTING)
+
+if test "$RDB_SETTING" != "no" ; then
+  OPT_GDAL_FORMATS="rdb $OPT_GDAL_FORMATS"
+fi
+
+
+dnl ---------------------------------------------------------------------------
+dnl Armadillo support
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(armadillo,[  --with-armadillo=ARG       Include Armadillo support for faster TPS transform computation (ARG=yes/no/path to armadillo install root) [[default=no]]],,)
+
+AC_MSG_CHECKING([whether we should include Armadillo support])
+
+HAVE_ARMADILLO=no
+
+if test "$with_armadillo" = "yes" ; then
+    rm -f testarmadillo.*
+    rm -f testarmadillo
+    echo '#include <armadillo>' > testarmadillo.cpp
+    echo 'int main(int argc, char** argv) { arma::mat matInput(2,2); const arma::mat& matInv = arma::inv(matInput); return 0; } ' >> testarmadillo.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testarmadillo.cpp -o testarmadillo -larmadillo 2>&1`" ; then
+        HAVE_ARMADILLO=yes
+        LIBS="-larmadillo ${LIBS}"
+        AC_MSG_RESULT([yes])
+    else
+        dnl Try adding -llapack (#4923)
+        if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testarmadillo.cpp -o testarmadillo -larmadillo -llapack 2>&1`" ; then
+            HAVE_ARMADILLO=yes
+            LIBS="-larmadillo -llapack ${LIBS}"
+            AC_MSG_RESULT([yes])
+        else
+            # clang 3.4 needs linking against libstdc++ (ubuntu 14.04)
+            if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} testarmadillo.cpp -o testarmadillo -larmadillo -lstdc++ 2>&1`" ; then
+                HAVE_ARMADILLO=yes
+                LIBS="-larmadillo -lstdc++ ${LIBS}"
+                AC_MSG_RESULT([yes])
+            else
+                AC_MSG_RESULT([no])
+            fi
+        fi
+    fi
+    rm -f testarmadillo.*
+    rm -f testarmadillo
+
+elif test -n "$with_armadillo" -a "$with_armadillo" != "no" ; then
+
+    rm -f testarmadillo.*
+    rm -f testarmadillo
+    echo '#include <armadillo>' > testarmadillo.cpp
+    echo 'int main(int argc, char** argv) { arma::mat matInput(2,2); const arma::mat& matInv = arma::inv(matInput); return 0; } ' >> testarmadillo.cpp
+    if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -I$with_armadillo/include testarmadillo.cpp -o testarmadillo -L$with_armadillo/lib -larmadillo 2>&1`" ; then
+        HAVE_ARMADILLO=yes
+        LIBS="-L$with_armadillo/lib -larmadillo ${LIBS}"
+        EXTRA_INCLUDES="-I$with_armadillo/include $EXTRA_INCLUDES"
+        AC_MSG_RESULT([yes])
+    else
+        dnl Try adding -llapack (#4923)
+        if test -z "`${CXX} ${CXXFLAGS} ${CPPFLAGS} -I$with_armadillo/include testarmadillo.cpp -o testarmadillo -L$with_armadillo/lib -larmadillo -llapack 2>&1`" ; then
+            HAVE_ARMADILLO=yes
+            LIBS="-L$with_armadillo/lib -larmadillo -llapack ${LIBS}"
+            EXTRA_INCLUDES="-I$with_armadillo/include $EXTRA_INCLUDES"
+            AC_MSG_RESULT([yes])
+        else
+            AC_MSG_RESULT([no])
+        fi
+    fi
+    rm -f testarmadillo.*
+    rm -f testarmadillo
+
+else
+    AC_MSG_RESULT([no])
+fi
+
+AC_SUBST(HAVE_ARMADILLO,$HAVE_ARMADILLO)
+
+dnl ---------------------------------------------------------------------------
+dnl libcryptopp
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(cryptopp,[  --with-cryptopp[=ARG]       Include cryptopp support (ARG=yes, no or path)],,)
+
+HAVE_CRYPTOPP=no
+USE_ONLY_CRYPTODLL_ALG=yes
+
+AC_MSG_CHECKING([for cryptopp])
+
+if test "$with_cryptopp" = "no" ; then
+
+  AC_MSG_RESULT([disabled])
+
+elif test "$with_cryptopp" = "yes" -o "$with_cryptopp" = "" ; then
+
+    rm -f testcryptopp.*
+    echo '#include <cryptopp/aes.h>' > testcryptopp.cpp
+    # Catch issue with clang++ (https://groups.google.com/forum/#!topic/cryptopp-users/DfWHy3bT0KI)
+    echo '#include <cryptopp/osrng.h>' >> testcryptopp.cpp
+    echo 'int main(int argc, char** argv) { CryptoPP::AES::Encryption oEnc; return 0; } ' >> testcryptopp.cpp
+    ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testcryptopp.cpp -o testcryptopp -lcryptopp 2>/dev/null
+    RETVAL=$?
+    if test $RETVAL -eq 0; then
+        HAVE_CRYPTOPP=yes
+        LIBS="-lcryptopp ${LIBS}"
+        AC_MSG_RESULT([yes])
+    else
+        AC_MSG_RESULT([no])
+        if test "$with_cryptopp" = "yes"; then
+            AC_MSG_ERROR([--with-cryptopp was requested, but not available])
+        fi
+    fi
+    rm -f testcryptopp.*
+    rm -f testcryptopp
+
+    if test "$HAVE_CRYPTOPP" = "yes"; then
+
+        AC_MSG_CHECKING([if cryptopp has all cipher methods builtin])
+        rm -f testcryptopp.*
+        echo '#include <cryptopp/blowfish.h>' > testcryptopp.cpp
+        echo 'int main(int argc, char** argv) { CryptoPP::Blowfish::Encryption oEnc; return 0; } ' >> testcryptopp.cpp
+        ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testcryptopp.cpp -o testcryptopp -lcryptopp 2>/dev/null
+        RETVAL=$?
+        if test $RETVAL -eq 0; then
+            USE_ONLY_CRYPTODLL_ALG=no
+            AC_MSG_RESULT([yes])
+        else
+            USE_ONLY_CRYPTODLL_ALG=yes
+            AC_MSG_RESULT([no])
+        fi
+        rm -f testcryptopp.*
+        rm -f testcryptopp
+    fi
+
+else
+
+    rm -f testcryptopp.*
+    echo '#include <cryptopp/aes.h>' > testcryptopp.cpp
+    # Catch issue with clang++ (https://groups.google.com/forum/#!topic/cryptopp-users/DfWHy3bT0KI)
+    echo '#include <cryptopp/osrng.h>' >> testcryptopp.cpp
+    echo 'int main(int argc, char** argv) { CryptoPP::AES::Encryption oEnc; return 0; } ' >> testcryptopp.cpp
+    ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testcryptopp.cpp -I$with_cryptopp/include -o testcryptopp -L$with_cryptopp/lib -lcryptopp 2>/dev/null
+    RETVAL=$?
+    if test $RETVAL -eq 0; then
+        HAVE_CRYPTOPP=yes
+        LIBS="-L$with_cryptopp/lib -lcryptopp ${LIBS}"
+        EXTRA_INCLUDES="-I$with_cryptopp/include $EXTRA_INCLUDES"
+        AC_MSG_RESULT([yes])
+    else
+        AC_MSG_RESULT([no])
+    fi
+    rm -f testcryptopp.*
+    rm -f testcryptopp
+
+    if test "$HAVE_CRYPTOPP" = "yes"; then
+
+        AC_MSG_CHECKING([if cryptopp has all cipher methods builtin])
+        rm -f testcryptopp.*
+        echo '#include <cryptopp/blowfish.h>' > testcryptopp.cpp
+        echo 'int main(int argc, char** argv) { CryptoPP::Blowfish::Encryption oEnc; return 0; } ' >> testcryptopp.cpp
+        ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testcryptopp.cpp -I$with_cryptopp/include -o testcryptopp -L$with_cryptopp/lib -lcryptopp 2>/dev/null
+        RETVAL=$?
+        if test $RETVAL -eq 0; then
+            USE_ONLY_CRYPTODLL_ALG=no
+            AC_MSG_RESULT([yes])
+        else
+            USE_ONLY_CRYPTODLL_ALG=yes
+            AC_MSG_RESULT([no])
+        fi
+        rm -f testcryptopp.*
+        rm -f testcryptopp
+    fi
+
+fi
+
+AC_SUBST(HAVE_CRYPTOPP,$HAVE_CRYPTOPP)
+AC_SUBST(USE_ONLY_CRYPTODLL_ALG,$USE_ONLY_CRYPTODLL_ALG)
+
+dnl ---------------------------------------------------------------------------
+dnl crypto
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(crypto,[  --with-crypto[=ARG]       Include crypto (from openssl) support (ARG=yes, no or path)],,)
+
+HAVE_OPENSSL_CRYPTO=no
+
+AC_MSG_CHECKING([for crypto])
+
+if test "$with_crypto" = "no" ; then
+
+  AC_MSG_RESULT([disabled])
+
+elif test "$with_crypto" = "yes" -o \( "$with_crypto" = "" -a "$HAVE_CRYPTOPP" = "no" \) ; then
+
+    AC_CHECK_LIB(crypto,EVP_sha256,HAVE_OPENSSL_CRYPTO=yes)
+    if test "$HAVE_OPENSSL_CRYPTO" = "yes"; then
+        AC_CHECK_HEADERS([openssl/bio.h])
+        if test "$ac_cv_header_openssl_bio_h" = "no"; then
+            HAVE_OPENSSL_CRYPTO=no
+        else
+            LIBS="-lcrypto $LIBS"
+        fi
+    fi
+fi
+
+AC_SUBST(HAVE_OPENSSL_CRYPTO,$HAVE_OPENSSL_CRYPTO)
+
+dnl ---------------------------------------------------------------------------
+dnl Whether to include LERC in the build
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(lerc,
+    [  --with-lerc[=ARG]         Include libLerc support(ARG=yes/no/internal/path). Used by internal libtiff and MRF.],,,)
+
+HAVE_LERC=no
+AC_MSG_CHECKING([for LERC])
+if test "$with_lerc" = "internal"; then
+    if test "$ac_cv_c_bigendian" = "yes"; then
+        AC_MSG_RESULT([disabled on big-endian])
+    else
+        HAVE_LERC=internal
+        AC_MSG_RESULT([enabled, internal])
+    fi
+elif test "$with_lerc" = "no"; then
+    HAVE_LERC=no
+    AC_MSG_RESULT([disabled by user])
+elif test "$with_lerc" = "yes" -o "x$with_lerc" = "x" ; then
+  lerc_lib_name="LercLib"
+  AC_CHECK_LIB("$lerc_lib_name", lerc_decode, [lerc_lib=yes], [lerc_lib=no],)
+  if test "$lerc_lib" = "no" ; then
+    lerc_lib_name="Lerc"
+    AC_CHECK_LIB("$lerc_lib_name", lerc_decode, [lerc_lib=yes], [lerc_lib=no],)
+  fi
+  if test "$lerc_lib" = "no" -a "$with_lerc" = "yes"; then
+    AC_MSG_ERROR([lerc library not found])
+  fi
+
+  AC_CHECK_HEADER(Lerc_c_api.h, [lerc_c_api_h=yes], [lerc_c_api_h=no])
+  if test "$lerc_c_api_h" = "no" -a "$with_lerc" = "yes"; then
+    AC_MSG_ERROR([Liblerc headers not found])
+  fi
+
+  if test "$lerc_lib" = "yes" -a "$lerc_c_api_h" = "yes"; then
+    HAVE_LERC=external
+    LIBS="$LIBS -l$lerc_lib_name"
+  else
+    if test "$ac_cv_c_bigendian" = "yes"; then
+        AC_MSG_RESULT([disabled on big-endian])
+    else
+        HAVE_LERC=internal
+        AC_MSG_RESULT([enabled, internal])
+    fi
+  fi
+else
+
+  ORIG_LIBS="$LIBS"
+  LIBS="-L$with_lerc/lib $LIBS"
+  lerc_lib_name="LercLib"
+  AC_CHECK_LIB("$lerc_lib_name", lerc_decode, [lerc_lib=yes], [lerc_lib=no],)
+  if test "$lerc_lib" = "no" ; then
+    lerc_lib_name="Lerc"
+    AC_CHECK_LIB("$lerc_lib_name", lerc_decode, [lerc_lib=yes], [lerc_lib=no],)
+  fi
+  if test "$lerc_lib" = "no"; then
+    AC_MSG_ERROR([lerc library not found])
+  fi
+
+  LIBS="-L$with_lerc/lib -l$lerc_lib_name $ORIG_LIBS"
+
+  if ! test -f "$with_lerc/include/Lerc_c_api.h"; then
+    AC_MSG_ERROR([Liblerc headers not found])
+  fi
+
+  HAVE_LERC=external
+  LERC_INCLUDE="-I$with_lerc/include"
+fi
+
+AC_SUBST(HAVE_LERC,$HAVE_LERC)
+AC_SUBST(LERC_INCLUDE,$LERC_INCLUDE)
+
+dnl ---------------------------------------------------------------------------
+dnl Whether to include NULL driver in the build
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH([null],
+	    AS_HELP_STRING([--with-null],
+	       [Enable NULL driver (only useful for development purposes]),,)
+
+AC_MSG_CHECKING([for NULL])
+if test "$with_null" = "yes" ; then
+    OPT_GDAL_FORMATS="null $OPT_GDAL_FORMATS"
+    AC_MSG_RESULT([enabled])
+else
+    AC_MSG_RESULT([disabled])
+fi
+
+dnl ---------------------------------------------------------------------------
+dnl Detect OpenEXR
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(exr,[  --with-exr            Include EXR support via OpenEXR library],,)
+
+HAVE_EXR=no
+EXR_CFLAGS=""
+
+if test "$with_exr" = "no" ; then
+
+  AC_MSG_NOTICE([EXR support disabled.])
+
+else
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([EXR], [OpenEXR >= 2.2], [HAVE_EXR=yes], [HAVE_EXR=no])
+
+  if test -n "$EXR_CFLAGS"; then
+
+    # Test that the package found is for the right architecture
+    saved_LIBS="$LIBS"
+    LIBS="$EXR_LIBS"
+    AC_CHECK_LIB(IlmImf,ImfTiledInputReadTile, [HAVE_EXR=yes], [HAVE_EXR=no])
+    if test "$HAVE_EXR" = "no"; then
+      dnl Try with OpenEXR >= 3 name
+      AC_CHECK_LIB(OpenEXR,ImfTiledInputReadTile, [HAVE_EXR=yes], [HAVE_EXR=no])
+    fi
+    LIBS="$saved_LIBS"
+
+    if test "$HAVE_EXR" = "yes"; then
+        OPT_GDAL_FORMATS="exr $OPT_GDAL_FORMATS"
+        LIBS="$EXR_LIBS $LIBS"
+    else
+        EXR_CFLAGS=""
+    fi
+  fi
+fi
+
+AC_SUBST(EXR_CFLAGS,$EXR_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Detect libheif
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(heif,[  --with-heif            Include HEIF support via libheif library],,)
+
+HAVE_HEIF=no
+HEIF_CFLAGS=""
+
+if test "$with_heif" = "no" ; then
+
+  AC_MSG_NOTICE([HEIF support disabled.])
+
+else
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([HEIF], [libheif >= 1.1], [], [HAVE_HEIF=no])
+
+  if test -n "$HEIF_LIBS"; then
+
+    # Test that the package found is for the right architecture
+    saved_LIBS="$LIBS"
+    LIBS="$HEIF_LIBS"
+    AC_CHECK_LIB(heif,heif_context_get_list_of_top_level_image_IDs, [HAVE_HEIF=yes], [HAVE_HEIF=no])
+    LIBS="$saved_LIBS"
+
+    if test "$HAVE_HEIF" = "yes"; then
+        OPT_GDAL_FORMATS="heif $OPT_GDAL_FORMATS"
+        LIBS="$HEIF_LIBS $LIBS"
+    else
+        HEIF_CFLAGS=""
+    fi
+  fi
+fi
+
+AC_SUBST(HEIF_CFLAGS,$HEIF_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Detect libjxl
+dnl ---------------------------------------------------------------------------
+
+AC_ARG_WITH(jxl,[  --with-jxl            Include JPEG-XL support via libjxl library, requires an internal libtiff.],,)
+
+HAVE_JXL=no
+
+if test "$TIFF_SETTING" != "internal" -o  "$with_jxl" = "no" ; then
+
+  AC_MSG_NOTICE([JXL support disabled.])
+
+else
+
+  PKG_PROG_PKG_CONFIG([0.21])
+  PKG_CHECK_MODULES([JXL], [libjxl], [], [HAVE_JXL=no])
+
+  if test -n "$JXL_LIBS" ; then
+
+    # Test that the package found is for the right architecture
+    saved_LIBS="$LIBS"
+    LIBS="$JXL_LIBS"
+    AC_CHECK_LIB(jxl,JxlEncoderOptionsCreate, [HAVE_JXL=yes], [HAVE_JXL=no])
+    LIBS="$saved_LIBS"
+
+    if test "$HAVE_JXL" = "yes"; then
+        LIBS="$JXL_LIBS $LIBS"
+
+        AC_CHECK_LIB(jxl,JxlEncoderFrameSettingsSetOption, [HAVE_JxlEncoderFrameSettingsSetOption=yes], [HAVE_JxlEncoderFrameSettingsSetOption=no])
+        if test "$HAVE_JxlEncoderFrameSettingsSetOption" = "yes"; then
+            JXL_CFLAGS="$JXL_CFLAGS -DHAVE_JxlEncoderFrameSettingsSetOption"
+        fi
+    fi
+  fi
+fi
+
+AC_SUBST(HAVE_JXL,$HAVE_JXL)
+AC_SUBST(JXL_CFLAGS,$JXL_CFLAGS)
+
+dnl ---------------------------------------------------------------------------
+dnl Test if sprintf can be overloaded with _XOPEN_SOURCE being defined or other,
+dnl includes being included before, which mingw64 4.8 doesn't like (#6390)
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([if sprintf can be overloaded for GDAL compilation])
+echo '#define _XOPEN_SOURCE' > testdeprecated.cpp
+echo '#include <vector>' >> testdeprecated.cpp
+echo '#include <stdio.h>' >> testdeprecated.cpp
+echo 'extern "C"' >> testdeprecated.cpp
+echo '{' >> testdeprecated.cpp
+echo 'int sprintf(char *str, const char* fmt, ...);' >> testdeprecated.cpp
+echo '}' >> testdeprecated.cpp
+${CXX} ${CXXFLAGS} ${CPPFLAGS} testdeprecated.cpp -c 2>/dev/null
+RETVAL=$?
+if test $RETVAL -eq 0; then
+    AC_MSG_RESULT([yes])
+else
+    CPPFLAGS="$CPPFLAGS -DDONT_DEPRECATE_SPRINTF"
+    AC_MSG_RESULT([no])
+fi
+rm -f testdeprecated.*
+rm -f testdeprecated
+
+dnl Use -municode for mingw
+case "${host_os}" in
+    mingw32*)
+        AC_MSG_CHECKING([if mingw supports wmain])
+        rm -f testwmain*
+        echo '#include <wchar.h>' > testwmain.cpp
+        echo '#include <stdlib.h>' >> testwmain.cpp
+        echo 'extern "C" int wmain( int argc, wchar_t ** argv_w );' >> testwmain.cpp
+        echo 'extern "C" int wmain( int , wchar_t **  ) { return 0; } ' >> testwmain.cpp
+        ${CXX} ${CXXFLAGS} ${CPPFLAGS} ${LDFLAGS} testwmain.cpp -o testwmain.exe -municode 2>/dev/null
+        RETVAL=$?
+        rm -f testwmain*
+        if test $RETVAL -eq 0; then
+            AC_MSG_RESULT([yes])
+            CPPFLAGS="$CPPFLAGS -DSUPPORTS_WMAIN"
+            LDFLAGS="$LDFLAGS -municode"
+        else
+            AC_MSG_RESULT([no])
+        fi
+        ;;
+    *)
+        ;;
+esac
+
+AC_CONFIG_FILES([GDALmake.opt])
+AC_OUTPUT
+
+dnl ---------------------------------------------------------------------------
+dnl Display configuration status
+dnl ---------------------------------------------------------------------------
+
+LOC_MSG()
+LOC_MSG([GDAL is now configured for ${host}])
+LOC_MSG()
+LOC_MSG([  Installation directory:    ${prefix}])
+LOC_MSG([  C compiler:                ${CC} ${CFLAGS}])
+LOC_MSG([  C++ compiler:              ${CXX} ${CXXFLAGS}])
+LOC_MSG([  C++14 support:             ${CXX14_SUPPORT}])
+LOC_MSG()
+LOC_MSG([  LIBTOOL support:           ${with_libtool}])
+LOC_MSG()
+LOC_MSG([  Armadillo support:         ${HAVE_ARMADILLO}])
+LOC_MSG([  Blosc support:             ${HAVE_BLOSC}])
+LOC_MSG([  CFITSIO support:           ${FITS_SETTING}])
+LOC_MSG([  crypto/openssl support:    ${HAVE_OPENSSL_CRYPTO}])
+LOC_MSG([  cryptopp support:          ${HAVE_CRYPTOPP}])
+LOC_MSG([  cURL support (wms/wcs/...):${CURL_SETTING}])
+LOC_MSG([  DDS support:               ${DDS_SETTING}])
+LOC_MSG([  ECW support:               ${ECW_SETTING}])
+LOC_MSG([  Expat support:             ${HAVE_EXPAT}])
+LOC_MSG([  EXR support:               ${HAVE_EXR}])
+LOC_MSG([  FGDB support:              ${FGDB_ENABLED}])
+LOC_MSG([  FreeXL support:            ${HAVE_FREEXL}])
+LOC_MSG([  GEORASTER support:         ${HAVE_GEORASTER}])
+LOC_MSG([  GEOS support:              ${HAVE_GEOS}])
+LOC_MSG([  Google libkml support:     ${HAVE_LIBKML}])
+LOC_MSG([  GTA support:               ${GTA_SETTING}])
+LOC_MSG([  HDF4 support:              ${HAVE_HDF4}])
+LOC_MSG([  HDF5 support:              ${HAVE_HDF5}])
+LOC_MSG([  JXL support:               ${HAVE_JXL}])
+LOC_MSG([  HDFS support:              ${HDFS_ENABLED}])
+LOC_MSG([  HEIF support:              ${HAVE_HEIF}])
+LOC_MSG([  INFORMIX DataBlade support:${HAVE_IDB}])
+LOC_MSG([  JP2Lura support:           ${HAVE_JP2LURA}])
+LOC_MSG([  JPEG 12 bit:               ${JPEG12_ENABLED}])
+LOC_MSG([  JPEG-in-TIFF 12 bit:       ${TIFF_JPEG12_ENABLED}])
+LOC_MSG([  Kakadu support:            ${HAVE_KAKADU}])
+LOC_MSG([  Kea support:               ${HAVE_KEA}])
+LOC_MSG([  LERC support:              ${HAVE_LERC}])
+LOC_MSG([  libbrunsli support:        ${BRUNSLI_ENABLED}])
+LOC_MSG([  libdeflate support:        ${LIBDEFLATE_SETTING}])
+LOC_MSG([  LIBGEOTIFF support:        ${GEOTIFF_SETTING}])
+LOC_MSG([  LIBGIF support:            ${GIF_SETTING}])
+LOC_MSG([  LIBJPEG support:           ${JPEG_SETTING}])
+LOC_MSG([  LIBLZMA support:           ${LIBLZMA_SETTING}])
+LOC_MSG([  LIBPNG support:            ${PNG_SETTING}])
+LOC_MSG([  LIBTIFF support:           ${TIFF_SETTING} (BigTIFF=${HAVE_BIGTIFF})])
+LOC_MSG([  libxml2 support:           ${HAVE_LIBXML2}])
+LOC_MSG([  LIBZ support:              ${LIBZ_SETTING}])
+LOC_MSG([  LZ4 support:               ${HAVE_LZ4}])
+LOC_MSG([  MongoCXX v3 support:       ${MONGOCXXV3_ENABLED}])
+LOC_MSG([  MrSID support:             ${HAVE_MRSID}])
+LOC_MSG([  MSG support:               ${HAVE_MSG}])
+LOC_MSG([  MySQL support:             ${HAVE_MYSQL}])
+if test "$NETCDF_SETTING" = "yes" ; then
+  LOC_MSG([  NetCDF has netcdf_mem.h:   ${NETCDF_MEM}])
+fi
+LOC_MSG([  NetCDF support:            ${NETCDF_SETTING}])
+LOC_MSG([  OCI support:               ${HAVE_OCI}])
+LOC_MSG([  ODBC support:              ${ODBC_SETTING}])
+LOC_MSG([  OGDI support:              ${HAVE_OGDI}])
+LOC_MSG([  OpenCL support:            ${OPENCL_SETTING}])
+LOC_MSG([  OpenJPEG support:          ${HAVE_OPENJPEG}])
+LOC_MSG([  PCIDSK support:            ${PCIDSK_SETTING}])
+LOC_MSG([  PCRaster support:          ${PCRASTER_SETTING}])
+LOC_MSG([  PCRE support:              ${HAVE_PCRE}])
+LOC_MSG([  PCRE2 support:             ${HAVE_PCRE2}])
+LOC_MSG([  PDFium support:            ${HAVE_PDFIUM}])
+LOC_MSG([  Podofo support:            ${HAVE_PODOFO}])
+LOC_MSG([  Poppler support:           ${HAVE_POPPLER}])
+LOC_MSG([  PostgreSQL support:        ${HAVE_PG}])
+LOC_MSG([  QHull support:             ${QHULL_SETTING}])
+LOC_MSG([  Rasdaman support:          ${RASDAMAN_ENABLED}])
+LOC_MSG([  RasterLite2 support:       ${HAVE_RASTERLITE2}])
+LOC_MSG([  RDB support:               ${RDB_SETTING}])
+LOC_MSG([  SAP HANA support:          ${HAVE_HANA}])
+LOC_MSG([  SFCGAL support:            ${HAVE_SFCGAL}])
+LOC_MSG([  SOSI support:              ${SOSI_ENABLED}])
+LOC_MSG([  SpatiaLite support:        ${HAVE_SPATIALITE}])
+if test "x$SPATIALITE_SONAME" != "x"; then
+  LOC_MSG([  SpatiaLite shared obj name:${SPATIALITE_SONAME}])
+fi
+LOC_MSG([  SQLite support:            ${HAVE_SQLITE}])
+LOC_MSG([  Teigha (DWG and DGNv8):    ${HAVE_TEIGHA}])
+LOC_MSG([  TileDB support:            ${TILEDB_SETTING}])
+LOC_MSG([  userfaultfd support:       ${ENABLE_UFFD}])
+LOC_MSG([  WebP support:              ${WEBP_SETTING}])
+LOC_MSG([  Xerces-C support:          ${HAVE_XERCES}])
+LOC_MSG([  ZSTD support:              ${ZSTD_SETTING}])
+
+LOC_MSG()
+if test ! -z "`uname | grep Darwin`" ; then
+  LOC_MSG([  Mac OS X Framework :       ${MACOSX_FRAMEWORK}])
+fi
+LOC_MSG()
+if test -z "$BINDINGS"; then
+    WHAT_BINDINGS="no"
+else
+    WHAT_BINDINGS="$BINDINGS"
+fi
+LOC_MSG([  misc. gdal formats:       ${GDALFORMATS_ENABLED}])
+LOC_MSG([  misc. ogr formats:        ${OGRFORMATS_ENABLED}])
+LOC_MSG()
+LOC_MSG([  disabled gdal formats:    ${GDALFORMATS_DISABLED}])
+LOC_MSG([  disabled ogr formats:     ${OGRFORMATS_DISABLED}])
+LOC_MSG()
+LOC_MSG([  SWIG Bindings:             ${WHAT_BINDINGS}])
+LOC_MSG()
+LOC_MSG([  PROJ >= 6:                 yes])
+LOC_MSG([  enable GNM building:       ${GNM_ENABLED}])
+LOC_MSG([  enable pthread support:    ${PTHREAD_ENABLED}])
+LOC_MSG([  enable POSIX iconv support:${am_cv_func_iconv}])
+LOC_MSG([  hide internal symbols:     ${HAVE_HIDE_INTERNAL_SYMBOLS}])
+LOC_MSG()
+
+if test "$HAVE_PODOFO" = "yes" -a "$HAVE_POPPLER" = "yes"  -a "$HAVE_PDFIUM" = "yes"; then
+    AC_MSG_WARN([--with-podofo, --with-poppler and --with-pdfium available. This is unusual setup, but will work. Pdfium will be used by default...])
+elif test "$HAVE_PODOFO" = "yes" -a "$HAVE_POPPLER" = "yes" ; then
+    AC_MSG_WARN([--with-podofo and --with-poppler are both available. This is unusual setup, but will work. Poppler will be used by default...])
+elif test "$HAVE_POPPLER" = "yes" -a "$HAVE_PDFIUM" = "yes" ; then
+    AC_MSG_WARN([--with-poppler and --with-pdfium are both available. This is unusual setup, but will work. Pdfium will be used by default...])
+elif test "$HAVE_PODOFO" = "yes" -a "$HAVE_PDFIUM" = "yes" ; then
+    AC_MSG_WARN([--with-podofo and --with-pdfium are both available. This is unusual setup, but will work. Pdfium will be used by default...])
+fi
+
+if test "$HAVE_LIBXML2" = "yes" -a "$FGDB_ENABLED" = "yes"; then
+    AC_MSG_WARN([--with-libxml2 and --with-fgdb are both available. There might be some incompatibility between system libxml2 and the embedded copy within libFileGDBAPI])
+fi
+
+if test "$HAVE_CRYPTOPP" = "yes" -a "$HAVE_OPENSSL_CRYPTO" = "yes"; then
+    AC_MSG_WARN([--with-crypto and --with-cryptopp available. This is unusual setup, but will work.])
+fi
+
+if test "$HAVE_TEIGHA" = "yes" -a "$ECW_54" = "yes"; then
+    AC_MSG_WARN([Both Teigha SDK and ECW SDK >= 5.4 found. This was found to cause crashes in ECW driver.])
+fi
+
+AC_MSG_NOTICE([])
+AC_MSG_NOTICE([])
+AC_MSG_WARN([Starting with GDAL 3.5, the autoconf build system is deprecated in favor of the CMake build system. The autoconf build system will be completely removed in GDAL 3.6])
diff -Nru gdal-3.5.0-orig/frmts/openjpeg/openjpegdataset.cpp.orig gdal-3.5.0-patched/frmts/openjpeg/openjpegdataset.cpp.orig
--- gdal-3.5.0-orig/frmts/openjpeg/openjpegdataset.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.5.0-patched/frmts/openjpeg/openjpegdataset.cpp.orig	2022-09-14 04:26:13.036347492 -0400
@@ -0,0 +1,4360 @@
+/******************************************************************************
+ *
+ * Project:  JPEG2000 driver based on OpenJPEG library
+ * Purpose:  JPEG2000 driver based on OpenJPEG library
+ * Author:   Even Rouault, <even dot rouault at spatialys dot com>
+ *
+ ******************************************************************************
+ * Copyright (c) 2010-2014, Even Rouault <even dot rouault at spatialys dot com>
+ * Copyright (c) 2015, European Union (European Environment Agency)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ ****************************************************************************/
+
+/* This file is to be used with openjpeg 2.1 or later */
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunknown-pragmas"
+#pragma clang diagnostic ignored "-Wdocumentation"
+#endif
+
+#include <openjpeg.h>
+#include <opj_config.h>
+
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
+#define IS_OPENJPEG_OR_LATER(major,minor,patch) \
+    ((OPJ_VERSION_MAJOR * 10000 + OPJ_VERSION_MINOR * 100 + OPJ_VERSION_BUILD) >= \
+        ((major)*10000+(minor)*100+(patch)))
+
+#include <cassert>
+#include <vector>
+
+#include "cpl_atomic_ops.h"
+#include "cpl_multiproc.h"
+#include "cpl_string.h"
+#include "cpl_worker_thread_pool.h"
+#include "gdal_frmts.h"
+#include "gdaljp2abstractdataset.h"
+#include "gdaljp2metadata.h"
+#include "vrt/vrtdataset.h"
+
+#include <algorithm>
+
+//#define DEBUG_IO
+
+CPL_CVSID("$Id$")
+
+/************************************************************************/
+/*                  JP2OpenJPEGDataset_ErrorCallback()                  */
+/************************************************************************/
+
+static void JP2OpenJPEGDataset_ErrorCallback(const char *pszMsg, CPL_UNUSED void *unused)
+{
+    CPLError(CE_Failure, CPLE_AppDefined, "%s", pszMsg);
+}
+
+/************************************************************************/
+/*               JP2OpenJPEGDataset_WarningCallback()                   */
+/************************************************************************/
+
+static void JP2OpenJPEGDataset_WarningCallback(const char *pszMsg, CPL_UNUSED void *unused)
+{
+    if( strcmp(pszMsg, "No incltree created.\n") == 0 ||
+        strcmp(pszMsg, "No imsbtree created.\n") == 0 ||
+        strcmp(pszMsg,
+               "tgt_create tree->numnodes == 0, no tree created.\n") == 0 )
+    {
+        // Ignore warnings related to empty tag-trees. There's nothing wrong
+        // about that.
+        // Fixed submitted upstream with
+        // https://github.com/uclouvain/openjpeg/pull/893
+        return;
+    }
+    if( strcmp(pszMsg, "Empty SOT marker detected: Psot=12.\n") == 0 )
+    {
+        static int bWarningEmitted = FALSE;
+        if( bWarningEmitted )
+            return;
+        bWarningEmitted = TRUE;
+    }
+    if( strcmp(pszMsg, "JP2 box which are after the codestream will not be read by this function.\n") != 0 )
+    {
+        std::string osMsg(pszMsg);
+        if( !osMsg.empty() && osMsg.back() == '\n' )
+            osMsg.resize(osMsg.size() - 1);
+        CPLError(CE_Warning, CPLE_AppDefined, "%s", osMsg.c_str());
+    }
+}
+
+/************************************************************************/
+/*                 JP2OpenJPEGDataset_InfoCallback()                    */
+/************************************************************************/
+
+static void JP2OpenJPEGDataset_InfoCallback(const char *pszMsg, CPL_UNUSED void *unused)
+{
+    std::string osMsg(pszMsg);
+    if( !osMsg.empty() && osMsg.back() == '\n' )
+        osMsg.resize(osMsg.size() - 1);
+    CPLDebug("OPENJPEG", "info: %s", osMsg.c_str());
+}
+
+typedef struct
+{
+    VSILFILE*    fp;
+    vsi_l_offset nBaseOffset;
+} JP2OpenJPEGFile;
+
+/************************************************************************/
+/*                      JP2OpenJPEGDataset_Read()                       */
+/************************************************************************/
+
+static OPJ_SIZE_T JP2OpenJPEGDataset_Read(void* pBuffer, OPJ_SIZE_T nBytes,
+                                       void *pUserData)
+{
+    JP2OpenJPEGFile* psJP2OpenJPEGFile = (JP2OpenJPEGFile* )pUserData;
+    OPJ_SIZE_T nRet = static_cast<OPJ_SIZE_T>(VSIFReadL(pBuffer, 1, nBytes, psJP2OpenJPEGFile->fp));
+#ifdef DEBUG_IO
+    CPLDebug("OPENJPEG", "JP2OpenJPEGDataset_Read(" CPL_FRMT_GUIB ") = " CPL_FRMT_GUIB,
+             static_cast<GUIntBig>(nBytes), static_cast<GUIntBig>(nRet));
+#endif
+    if (nRet == 0)
+        nRet = static_cast<OPJ_SIZE_T>(-1);
+
+    return nRet;
+}
+
+/************************************************************************/
+/*                      JP2OpenJPEGDataset_Write()                      */
+/************************************************************************/
+
+static OPJ_SIZE_T JP2OpenJPEGDataset_Write(void* pBuffer, OPJ_SIZE_T nBytes,
+                                       void *pUserData)
+{
+    JP2OpenJPEGFile* psJP2OpenJPEGFile = (JP2OpenJPEGFile* )pUserData;
+    OPJ_SIZE_T nRet = static_cast<OPJ_SIZE_T>(VSIFWriteL(pBuffer, 1, nBytes, psJP2OpenJPEGFile->fp));
+#ifdef DEBUG_IO
+    CPLDebug("OPENJPEG", "JP2OpenJPEGDataset_Write(" CPL_FRMT_GUIB ") = " CPL_FRMT_GUIB,
+             static_cast<GUIntBig>(nBytes), static_cast<GUIntBig>(nRet));
+#endif
+    if( nRet != nBytes )
+        return static_cast<OPJ_SIZE_T>(-1);
+    return nRet;
+}
+
+/************************************************************************/
+/*                       JP2OpenJPEGDataset_Seek()                      */
+/************************************************************************/
+
+static OPJ_BOOL JP2OpenJPEGDataset_Seek(OPJ_OFF_T nBytes, void * pUserData)
+{
+    JP2OpenJPEGFile* psJP2OpenJPEGFile = (JP2OpenJPEGFile* )pUserData;
+#ifdef DEBUG_IO
+    CPLDebug("OPENJPEG", "JP2OpenJPEGDataset_Seek(" CPL_FRMT_GUIB ")",
+             static_cast<GUIntBig>(nBytes));
+#endif
+    return VSIFSeekL(psJP2OpenJPEGFile->fp, psJP2OpenJPEGFile->nBaseOffset +nBytes,
+                     SEEK_SET) == 0;
+}
+
+/************************************************************************/
+/*                     JP2OpenJPEGDataset_Skip()                        */
+/************************************************************************/
+
+static OPJ_OFF_T JP2OpenJPEGDataset_Skip(OPJ_OFF_T nBytes, void * pUserData)
+{
+    JP2OpenJPEGFile* psJP2OpenJPEGFile = (JP2OpenJPEGFile* )pUserData;
+    vsi_l_offset nOffset = VSIFTellL(psJP2OpenJPEGFile->fp);
+    nOffset += nBytes;
+#ifdef DEBUG_IO
+    CPLDebug("OPENJPEG", "JP2OpenJPEGDataset_Skip(" CPL_FRMT_GUIB " -> " CPL_FRMT_GUIB ")",
+             static_cast<GUIntBig>(nBytes), static_cast<GUIntBig>(nOffset));
+#endif
+    VSIFSeekL(psJP2OpenJPEGFile->fp, nOffset, SEEK_SET);
+    return nBytes;
+}
+
+/************************************************************************/
+/* ==================================================================== */
+/*                           JP2OpenJPEGDataset                         */
+/* ==================================================================== */
+/************************************************************************/
+
+class JP2OpenJPEGRasterBand;
+
+class JP2OpenJPEGDataset final: public GDALJP2AbstractDataset
+{
+    friend class JP2OpenJPEGRasterBand;
+
+    std::string  m_osFilename;
+    VSILFILE   *fp = nullptr; /* Large FILE API */
+    vsi_l_offset nCodeStreamStart = 0;
+    vsi_l_offset nCodeStreamLength = 0;
+
+    OPJ_COLOR_SPACE eColorSpace = OPJ_CLRSPC_UNKNOWN;
+    int         nRedIndex = 0;
+    int         nGreenIndex = 1;
+    int         nBlueIndex = 2;
+    int         nAlphaIndex = -1;
+
+    int         bIs420 = FALSE;
+
+    int         nParentXSize = 0;
+    int         nParentYSize = 0;
+    int         iLevel = 0;
+    int         nOverviewCount = 0;
+    JP2OpenJPEGDataset** papoOverviewDS = nullptr;
+    bool        bUseSetDecodeArea = false;
+    bool        bSingleTiled = false;
+#if IS_OPENJPEG_OR_LATER(2,3,0)
+    opj_codec_t**    m_ppCodec = nullptr;
+    opj_stream_t **  m_ppStream = nullptr;
+    opj_image_t **   m_ppsImage = nullptr;
+    JP2OpenJPEGFile* m_psJP2OpenJPEGFile = nullptr;
+    int*             m_pnLastLevel = nullptr;
+#endif
+    int         m_nX0 = 0;
+    int         m_nY0 = 0;
+
+    int         nThreads = -1;
+    int         m_nBlocksToLoad = 0;
+    int         GetNumThreads();
+    int         bEnoughMemoryToLoadOtherBands = TRUE;
+    int         bRewrite = FALSE;
+    int         bHasGeoreferencingAtOpening = FALSE;
+
+#if IS_OPENJPEG_OR_LATER(2,5,0)
+    bool        m_bStrict = true;
+#endif
+
+  protected:
+    virtual int         CloseDependentDatasets() override;
+
+  public:
+                JP2OpenJPEGDataset();
+    virtual ~JP2OpenJPEGDataset();
+
+    static int Identify( GDALOpenInfo * poOpenInfo );
+    static GDALDataset  *Open( GDALOpenInfo * );
+    static GDALDataset  *CreateCopy( const char * pszFilename,
+                                           GDALDataset *poSrcDS,
+                                           int bStrict, char ** papszOptions,
+                                           GDALProgressFunc pfnProgress,
+                                           void * pProgressData );
+
+    CPLErr SetSpatialRef(const OGRSpatialReference* poSRS) override;
+
+    virtual CPLErr SetGeoTransform( double* ) override;
+
+    CPLErr SetGCPs( int nGCPCountIn, const GDAL_GCP *pasGCPListIn,
+                    const OGRSpatialReference* poSRS ) override ;
+
+    virtual CPLErr      SetMetadata( char ** papszMetadata,
+                             const char * pszDomain = "" ) override;
+    virtual CPLErr      SetMetadataItem( const char * pszName,
+                                 const char * pszValue,
+                                 const char * pszDomain = "" ) override;
+
+    virtual CPLErr  IRasterIO( GDALRWFlag eRWFlag,
+                               int nXOff, int nYOff, int nXSize, int nYSize,
+                               void * pData, int nBufXSize, int nBufYSize,
+                               GDALDataType eBufType,
+                               int nBandCount, int *panBandMap,
+                               GSpacing nPixelSpace, GSpacing nLineSpace,
+                               GSpacing nBandSpace,
+                               GDALRasterIOExtraArg* psExtraArg) override;
+
+    CPLErr IBuildOverviews( const char *pszResampling,
+                                       int nOverviews, int *panOverviewList,
+                                       int nListBands, int *panBandList,
+                                       GDALProgressFunc pfnProgress,
+                                       void *pProgressData ) override;
+
+    static void         WriteBox(VSILFILE* fp, GDALJP2Box* poBox);
+    static void         WriteGDALMetadataBox( VSILFILE* fp, GDALDataset* poSrcDS,
+                                       char** papszOptions );
+    static void         WriteXMLBoxes( VSILFILE* fp, GDALDataset* poSrcDS,
+                                       char** papszOptions );
+    static void         WriteXMPBox( VSILFILE* fp, GDALDataset* poSrcDS,
+                                     char** papszOptions );
+    static void         WriteIPRBox( VSILFILE* fp, GDALDataset* poSrcDS,
+                                     char** papszOptions );
+
+    CPLErr      ReadBlock( int nBand, VSILFILE* fp,
+                           int nBlockXOff, int nBlockYOff, void * pImage,
+                           int nBandCount, int *panBandMap );
+
+    int         PreloadBlocks( JP2OpenJPEGRasterBand* poBand,
+                               int nXOff, int nYOff, int nXSize, int nYSize,
+                               int nBandCount, int *panBandMap );
+
+    static void JP2OpenJPEGReadBlockInThread(void* userdata);
+};
+
+/************************************************************************/
+/* ==================================================================== */
+/*                         JP2OpenJPEGRasterBand                        */
+/* ==================================================================== */
+/************************************************************************/
+
+class JP2OpenJPEGRasterBand final: public GDALPamRasterBand
+{
+    friend class JP2OpenJPEGDataset;
+    int             bPromoteTo8Bit;
+    GDALColorTable* poCT;
+
+  public:
+
+                JP2OpenJPEGRasterBand( JP2OpenJPEGDataset * poDS, int nBand,
+                                       GDALDataType eDataType, int nBits,
+                                       int bPromoteTo8Bit,
+                                       int nBlockXSize, int nBlockYSize );
+    virtual ~JP2OpenJPEGRasterBand();
+
+    virtual CPLErr          IReadBlock( int, int, void * ) override;
+    virtual CPLErr          IRasterIO( GDALRWFlag eRWFlag,
+                                  int nXOff, int nYOff, int nXSize, int nYSize,
+                                  void * pData, int nBufXSize, int nBufYSize,
+                                  GDALDataType eBufType,
+                                  GSpacing nPixelSpace, GSpacing nLineSpace,
+                                  GDALRasterIOExtraArg* psExtraArg) override;
+
+    virtual GDALColorInterp GetColorInterpretation() override;
+    virtual GDALColorTable* GetColorTable() override { return poCT; }
+
+    virtual int             GetOverviewCount() override;
+    virtual GDALRasterBand* GetOverview(int iOvrLevel) override;
+
+    virtual int HasArbitraryOverviews() override { return poCT == nullptr; }
+};
+
+/************************************************************************/
+/*                        JP2OpenJPEGRasterBand()                       */
+/************************************************************************/
+
+JP2OpenJPEGRasterBand::JP2OpenJPEGRasterBand( JP2OpenJPEGDataset *poDSIn, int nBandIn,
+                                              GDALDataType eDataTypeIn, int nBits,
+                                              int bPromoteTo8BitIn,
+                                              int nBlockXSizeIn, int nBlockYSizeIn )
+
+{
+    this->eDataType = eDataTypeIn;
+    this->nBlockXSize = nBlockXSizeIn;
+    this->nBlockYSize = nBlockYSizeIn;
+    this->bPromoteTo8Bit = bPromoteTo8BitIn;
+    poCT = nullptr;
+
+    if( (nBits % 8) != 0 )
+        GDALRasterBand::SetMetadataItem("NBITS",
+                        CPLString().Printf("%d",nBits),
+                        "IMAGE_STRUCTURE" );
+    GDALRasterBand::SetMetadataItem("COMPRESSION", "JPEG2000",
+                    "IMAGE_STRUCTURE" );
+    this->poDS = poDSIn;
+    this->nBand = nBandIn;
+}
+
+/************************************************************************/
+/*                      ~JP2OpenJPEGRasterBand()                        */
+/************************************************************************/
+
+JP2OpenJPEGRasterBand::~JP2OpenJPEGRasterBand()
+{
+    delete poCT;
+}
+
+/************************************************************************/
+/*                            CLAMP_0_255()                             */
+/************************************************************************/
+
+static CPL_INLINE GByte CLAMP_0_255(int val)
+{
+    if (val < 0)
+        return 0;
+    else if (val > 255)
+        return 255;
+    else
+        return (GByte)val;
+}
+
+/************************************************************************/
+/*                             IReadBlock()                             */
+/************************************************************************/
+
+CPLErr JP2OpenJPEGRasterBand::IReadBlock( int nBlockXOff, int nBlockYOff,
+                                          void * pImage )
+{
+    JP2OpenJPEGDataset *poGDS = (JP2OpenJPEGDataset *) poDS;
+
+#ifdef DEBUG_VERBOSE
+    int nXOff = nBlockXOff * nBlockXSize;
+    int nYOff = nBlockYOff * nBlockYSize;
+    int nXSize = std::min( nBlockXSize, nRasterXSize - nXOff );
+    int nYSize = std::min( nBlockYSize, nRasterYSize - nYOff );
+    if( poGDS->iLevel == 0 )
+    {
+        CPLDebug("OPENJPEG",
+                 "ds.GetRasterBand(%d).ReadRaster(%d,%d,%d,%d)",
+                 nBand, nXOff, nYOff, nXSize, nYSize);
+    }
+    else
+    {
+        CPLDebug("OPENJPEG",
+                 "ds.GetRasterBand(%d).GetOverview(%d).ReadRaster(%d,%d,%d,%d)",
+                 nBand, poGDS->iLevel - 1, nXOff, nYOff, nXSize, nYSize);
+    }
+#endif
+
+    if ( poGDS->bEnoughMemoryToLoadOtherBands )
+        return poGDS->ReadBlock(nBand, poGDS->fp, nBlockXOff, nBlockYOff, pImage,
+                                poGDS->nBands, nullptr);
+    else
+        return poGDS->ReadBlock(nBand, poGDS->fp, nBlockXOff, nBlockYOff, pImage,
+                                1, &nBand);
+}
+
+/************************************************************************/
+/*                             IRasterIO()                              */
+/************************************************************************/
+
+CPLErr JP2OpenJPEGRasterBand::IRasterIO( GDALRWFlag eRWFlag,
+                                         int nXOff, int nYOff, int nXSize, int nYSize,
+                                         void * pData, int nBufXSize, int nBufYSize,
+                                         GDALDataType eBufType,
+                                         GSpacing nPixelSpace, GSpacing nLineSpace,
+                                         GDALRasterIOExtraArg* psExtraArg )
+{
+    JP2OpenJPEGDataset *poGDS = (JP2OpenJPEGDataset *) poDS;
+
+    if( eRWFlag != GF_Read )
+        return CE_Failure;
+
+/* ==================================================================== */
+/*      Do we have overviews that would be appropriate to satisfy       */
+/*      this request?                                                   */
+/* ==================================================================== */
+    if( (nBufXSize < nXSize || nBufYSize < nYSize)
+        && GetOverviewCount() > 0 )
+    {
+        int bTried;
+        CPLErr eErr = TryOverviewRasterIO( eRWFlag,
+                                    nXOff, nYOff, nXSize, nYSize,
+                                    pData, nBufXSize, nBufYSize,
+                                    eBufType,
+                                    nPixelSpace, nLineSpace,
+                                    psExtraArg,
+                                    &bTried );
+        if( bTried )
+            return eErr;
+    }
+
+    int nRet = poGDS->PreloadBlocks(this, nXOff, nYOff, nXSize, nYSize, 0, nullptr);
+    if( nRet < 0 )
+        return CE_Failure;
+    poGDS->bEnoughMemoryToLoadOtherBands = nRet;
+
+    CPLErr eErr = GDALPamRasterBand::IRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,
+                                         pData, nBufXSize, nBufYSize, eBufType,
+                                         nPixelSpace, nLineSpace, psExtraArg );
+
+    // cppcheck-suppress redundantAssignment
+    poGDS->bEnoughMemoryToLoadOtherBands = TRUE;
+    return eErr;
+}
+
+/************************************************************************/
+/*                            GetNumThreads()                           */
+/************************************************************************/
+
+int JP2OpenJPEGDataset::GetNumThreads()
+{
+    if( nThreads >= 1 )
+        return nThreads;
+
+    const char* pszThreads = CPLGetConfigOption("GDAL_NUM_THREADS", "ALL_CPUS");
+    if (EQUAL(pszThreads, "ALL_CPUS"))
+        nThreads = CPLGetNumCPUs();
+    else
+        nThreads = atoi(pszThreads);
+    if (nThreads > 128)
+        nThreads = 128;
+    if (nThreads <= 0)
+        nThreads = 1;
+    return nThreads;
+}
+
+/************************************************************************/
+/*                   JP2OpenJPEGReadBlockInThread()                     */
+/************************************************************************/
+
+class JobStruct
+{
+public:
+
+    JP2OpenJPEGDataset* poGDS;
+    int                 nBand;
+    std::vector< std::pair<int, int> > oPairs;
+    volatile int        nCurPair;
+    int                 nBandCount;
+    int                *panBandMap;
+    volatile bool       bSuccess;
+};
+
+void JP2OpenJPEGDataset::JP2OpenJPEGReadBlockInThread(void* userdata)
+{
+    int nPair;
+    JobStruct* poJob = (JobStruct*) userdata;
+
+    JP2OpenJPEGDataset* poGDS = poJob->poGDS;
+    int nBand = poJob->nBand;
+    int nPairs = (int)poJob->oPairs.size();
+    int nBandCount = poJob->nBandCount;
+    int* panBandMap = poJob->panBandMap;
+    VSILFILE* fp = VSIFOpenL(poGDS->m_osFilename.c_str(), "rb");
+    if( fp == nullptr )
+    {
+        CPLDebug("OPENJPEG", "Cannot open %s", poGDS->m_osFilename.c_str());
+        poJob->bSuccess = false;
+        //VSIFree(pDummy);
+        return;
+    }
+
+    while( (nPair = CPLAtomicInc(&(poJob->nCurPair))) < nPairs &&
+            poJob->bSuccess )
+    {
+        int nBlockXOff = poJob->oPairs[nPair].first;
+        int nBlockYOff = poJob->oPairs[nPair].second;
+        poGDS->AcquireMutex();
+        GDALRasterBlock* poBlock = poGDS->GetRasterBand(nBand)->
+                GetLockedBlockRef(nBlockXOff,nBlockYOff, TRUE);
+        poGDS->ReleaseMutex();
+        if (poBlock == nullptr)
+        {
+            poJob->bSuccess = false;
+            break;
+        }
+
+        void* pDstBuffer = poBlock->GetDataRef();
+        if( poGDS->ReadBlock(nBand, fp, nBlockXOff, nBlockYOff, pDstBuffer,
+                             nBandCount, panBandMap) != CE_None )
+        {
+            poJob->bSuccess = false;
+        }
+
+        poBlock->DropLock();
+    }
+
+    VSIFCloseL(fp);
+    //VSIFree(pDummy);
+}
+
+/************************************************************************/
+/*                           PreloadBlocks()                            */
+/************************************************************************/
+
+int JP2OpenJPEGDataset::PreloadBlocks(JP2OpenJPEGRasterBand* poBand,
+                                      int nXOff, int nYOff, int nXSize, int nYSize,
+                                      int nBandCount, int *panBandMap)
+{
+    int bRet = TRUE;
+    int nXStart = nXOff / poBand->nBlockXSize;
+    int nXEnd = (nXOff + nXSize - 1) / poBand->nBlockXSize;
+    int nYStart = nYOff / poBand->nBlockYSize;
+    int nYEnd = (nYOff + nYSize - 1) / poBand->nBlockYSize;
+    GIntBig nReqMem = (GIntBig)(nXEnd - nXStart + 1) * (nYEnd - nYStart + 1) *
+                      poBand->nBlockXSize * poBand->nBlockYSize * (GDALGetDataTypeSize(poBand->eDataType) / 8);
+
+    int nMaxThreads = GetNumThreads();
+    if( !bUseSetDecodeArea && nMaxThreads > 1 )
+    {
+        if( nReqMem > GDALGetCacheMax64() / (nBandCount == 0 ? 1 : nBandCount) )
+            return FALSE;
+
+        JobStruct oJob;
+        m_nBlocksToLoad = 0;
+        try
+        {
+            for(int nBlockXOff = nXStart; nBlockXOff <= nXEnd; ++nBlockXOff)
+            {
+                for(int nBlockYOff = nYStart; nBlockYOff <= nYEnd; ++nBlockYOff)
+                {
+                    GDALRasterBlock* poBlock = poBand->TryGetLockedBlockRef(nBlockXOff,nBlockYOff);
+                    if (poBlock != nullptr)
+                    {
+                        poBlock->DropLock();
+                        continue;
+                    }
+                    oJob.oPairs.push_back( std::pair<int,int>(nBlockXOff, nBlockYOff) );
+                    m_nBlocksToLoad ++;
+                }
+            }
+        }
+        catch( const std::bad_alloc& )
+        {
+            CPLError(CE_Failure, CPLE_OutOfMemory, "Out of memory error");
+            m_nBlocksToLoad = 0;
+            return -1;
+        }
+
+        if( m_nBlocksToLoad > 1 )
+        {
+            const int l_nThreads = std::min(m_nBlocksToLoad, nMaxThreads);
+            CPLJoinableThread** pahThreads = (CPLJoinableThread**) VSI_CALLOC_VERBOSE( sizeof(CPLJoinableThread*), l_nThreads );
+            if( pahThreads == nullptr )
+            {
+                m_nBlocksToLoad = 0;
+                return -1;
+            }
+            int i;
+
+            CPLDebug("OPENJPEG", "%d blocks to load (%d threads)", m_nBlocksToLoad, l_nThreads);
+
+            oJob.poGDS = this;
+            oJob.nBand = poBand->GetBand();
+            oJob.nCurPair = -1;
+            if( nBandCount > 0 )
+            {
+                oJob.nBandCount = nBandCount;
+                oJob.panBandMap = panBandMap;
+            }
+            else
+            {
+                if( nReqMem <= GDALGetCacheMax64() / nBands )
+                {
+                    oJob.nBandCount = nBands;
+                    oJob.panBandMap = nullptr;
+                }
+                else
+                {
+                    bRet = FALSE;
+                    oJob.nBandCount = 1;
+                    oJob.panBandMap = &oJob.nBand;
+                }
+            }
+            oJob.bSuccess = true;
+
+            /* Flushes all dirty blocks from cache to disk to avoid them */
+            /* to be flushed randomly, and simultaneously, from our worker threads, */
+            /* which might cause races in the output driver. */
+            /* This is a workaround to a design defect of the block cache */
+            GDALRasterBlock::FlushDirtyBlocks();
+
+            for(i=0;i<l_nThreads;i++)
+            {
+                pahThreads[i] = CPLCreateJoinableThread(JP2OpenJPEGReadBlockInThread, &oJob);
+                if( pahThreads[i] == nullptr )
+                    oJob.bSuccess = false;
+            }
+            TemporarilyDropReadWriteLock();
+            for(i=0;i<l_nThreads;i++)
+                CPLJoinThread( pahThreads[i] );
+            ReacquireReadWriteLock();
+            CPLFree(pahThreads);
+            if( !oJob.bSuccess )
+            {
+                m_nBlocksToLoad = 0;
+                return -1;
+            }
+            m_nBlocksToLoad = 0;
+        }
+    }
+
+    return bRet;
+}
+
+/************************************************************************/
+/*                             IRasterIO()                              */
+/************************************************************************/
+
+CPLErr  JP2OpenJPEGDataset::IRasterIO( GDALRWFlag eRWFlag,
+                               int nXOff, int nYOff, int nXSize, int nYSize,
+                               void * pData, int nBufXSize, int nBufYSize,
+                               GDALDataType eBufType,
+                               int nBandCount, int *panBandMap,
+                               GSpacing nPixelSpace, GSpacing nLineSpace,
+                               GSpacing nBandSpace,
+                               GDALRasterIOExtraArg* psExtraArg)
+{
+    if( eRWFlag != GF_Read )
+        return CE_Failure;
+
+    if( nBandCount < 1 )
+        return CE_Failure;
+
+    JP2OpenJPEGRasterBand* poBand = (JP2OpenJPEGRasterBand*) GetRasterBand(panBandMap[0]);
+
+/* ==================================================================== */
+/*      Do we have overviews that would be appropriate to satisfy       */
+/*      this request?                                                   */
+/* ==================================================================== */
+
+    if( (nBufXSize < nXSize || nBufYSize < nYSize)
+        && poBand->GetOverviewCount() > 0 )
+    {
+        int bTried;
+        CPLErr eErr = TryOverviewRasterIO( eRWFlag,
+                                    nXOff, nYOff, nXSize, nYSize,
+                                    pData, nBufXSize, nBufYSize,
+                                    eBufType,
+                                    nBandCount, panBandMap,
+                                    nPixelSpace, nLineSpace,
+                                    nBandSpace,
+                                    psExtraArg,
+                                    &bTried );
+        if( bTried )
+            return eErr;
+    }
+
+    bEnoughMemoryToLoadOtherBands = PreloadBlocks(poBand, nXOff, nYOff, nXSize, nYSize, nBandCount, panBandMap);
+
+    CPLErr eErr = GDALPamDataset::IRasterIO(   eRWFlag,
+                                        nXOff, nYOff, nXSize, nYSize,
+                                        pData, nBufXSize, nBufYSize,
+                                        eBufType,
+                                        nBandCount, panBandMap,
+                                        nPixelSpace, nLineSpace, nBandSpace,
+                                        psExtraArg );
+
+    bEnoughMemoryToLoadOtherBands = TRUE;
+    return eErr;
+}
+
+
+/************************************************************************/
+/*                          IBuildOverviews()                           */
+/************************************************************************/
+
+CPLErr JP2OpenJPEGDataset::IBuildOverviews( const char *pszResampling,
+                                       int nOverviews, int *panOverviewList,
+                                       int nListBands, int *panBandList,
+                                       GDALProgressFunc pfnProgress,
+                                       void *pProgressData )
+
+{
+    // In order for building external overviews to work properly, we
+    // discard any concept of internal overviews when the user
+    // first requests to build external overviews.
+    for( int i = 0; i < nOverviewCount; i++ )
+    {
+        delete papoOverviewDS[i];
+    }
+    CPLFree(papoOverviewDS);
+    papoOverviewDS = nullptr;
+    nOverviewCount = 0;
+
+    return GDALPamDataset::IBuildOverviews(pszResampling,
+                                           nOverviews, panOverviewList,
+                                           nListBands, panBandList,
+                                           pfnProgress, pProgressData);
+}
+
+
+/************************************************************************/
+/*                    JP2OpenJPEGCreateReadStream()                     */
+/************************************************************************/
+
+static opj_stream_t* JP2OpenJPEGCreateReadStream(JP2OpenJPEGFile* psJP2OpenJPEGFile,
+                                                 vsi_l_offset nSize)
+{
+    opj_stream_t *pStream = opj_stream_create(1024, TRUE); // Default 1MB is way too big for some datasets
+    if( pStream == nullptr )
+        return nullptr;
+
+    VSIFSeekL(psJP2OpenJPEGFile->fp, psJP2OpenJPEGFile->nBaseOffset, SEEK_SET);
+    opj_stream_set_user_data_length(pStream, nSize);
+
+    opj_stream_set_read_function(pStream, JP2OpenJPEGDataset_Read);
+    opj_stream_set_seek_function(pStream, JP2OpenJPEGDataset_Seek);
+    opj_stream_set_skip_function(pStream, JP2OpenJPEGDataset_Skip);
+    opj_stream_set_user_data(pStream, psJP2OpenJPEGFile, nullptr);
+
+    return pStream;
+}
+
+/************************************************************************/
+/*                             ReadBlock()                              */
+/************************************************************************/
+
+CPLErr JP2OpenJPEGDataset::ReadBlock( int nBand, VSILFILE* fpIn,
+                                      int nBlockXOff, int nBlockYOff, void * pImage,
+                                      int nBandCount, int* panBandMap )
+{
+    CPLErr          eErr = CE_None;
+    opj_codec_t*    pCodec = nullptr;
+    opj_stream_t *  pStream = nullptr;
+    opj_image_t *   psImage = nullptr;
+    JP2OpenJPEGFile sJP2OpenJPEGFile; // keep it in this scope
+
+    JP2OpenJPEGRasterBand* poBand = (JP2OpenJPEGRasterBand*) GetRasterBand(nBand);
+    int nBlockXSize = poBand->nBlockXSize;
+    int nBlockYSize = poBand->nBlockYSize;
+    GDALDataType eDataType = poBand->eDataType;
+
+    int nDataTypeSize = (GDALGetDataTypeSize(eDataType) / 8);
+
+    int nTileNumber = nBlockXOff + nBlockYOff * poBand->nBlocksPerRow;
+    const int nWidthToRead =
+        std::min(nBlockXSize, nRasterXSize - nBlockXOff * nBlockXSize);
+    const int nHeightToRead =
+        std::min(nBlockYSize, nRasterYSize - nBlockYOff * nBlockYSize);
+
+#if IS_OPENJPEG_OR_LATER(2,3,0)
+    if( m_ppCodec &&
+        CPLTestBool(CPLGetConfigOption("USE_OPENJPEG_SINGLE_TILE_OPTIM", "YES")) )
+    {
+        if( (*m_pnLastLevel == -1 || *m_pnLastLevel == iLevel) &&
+            *m_ppCodec != nullptr && *m_ppStream != nullptr && *m_ppsImage != nullptr )
+        {
+            pCodec = *m_ppCodec;
+            pStream = *m_ppStream;
+            psImage = *m_ppsImage;
+        }
+        else
+        {
+            // For some reason, we need to "reboot" all the machinery if
+            // changing of overview level. Should be fixed in openjpeg
+            if( *m_ppCodec )
+                opj_destroy_codec(*m_ppCodec);
+            if( *m_ppStream)
+                opj_stream_destroy(*m_ppStream);
+            if( *m_ppsImage)
+                opj_image_destroy(*m_ppsImage);
+            *m_ppCodec = nullptr;
+            *m_ppStream = nullptr;
+            *m_ppsImage = nullptr;
+        }
+    }
+    *m_pnLastLevel = iLevel;
+
+    if( pCodec == nullptr )
+#endif
+    {
+        pCodec = opj_create_decompress(OPJ_CODEC_J2K);
+        if( pCodec == nullptr )
+        {
+            CPLError(CE_Failure, CPLE_AppDefined, "opj_create_decompress() failed");
+            eErr = CE_Failure;
+            goto end;
+        }
+
+        opj_set_info_handler(pCodec, JP2OpenJPEGDataset_InfoCallback,nullptr);
+        opj_set_warning_handler(pCodec, JP2OpenJPEGDataset_WarningCallback, nullptr);
+        opj_set_error_handler(pCodec, JP2OpenJPEGDataset_ErrorCallback,nullptr);
+
+        opj_dparameters_t parameters;
+        opj_set_default_decoder_parameters(&parameters);
+
+        if (! opj_setup_decoder(pCodec,&parameters))
+        {
+            CPLError(CE_Failure, CPLE_AppDefined, "opj_setup_decoder() failed");
+            eErr = CE_Failure;
+            goto end;
+        }
+
+#if IS_OPENJPEG_OR_LATER(2,5,0)
+        if( !m_bStrict )
+        {
+            opj_decoder_set_strict_mode(pCodec, false);
+        }
+#endif
+
+#if IS_OPENJPEG_OR_LATER(2,3,0)
+        if( m_psJP2OpenJPEGFile )
+        {
+            pStream = JP2OpenJPEGCreateReadStream( m_psJP2OpenJPEGFile, nCodeStreamLength);
+        }
+        else
+#endif
+        {
+            sJP2OpenJPEGFile.fp = fpIn;
+            sJP2OpenJPEGFile.nBaseOffset = nCodeStreamStart;
+            pStream = JP2OpenJPEGCreateReadStream(&sJP2OpenJPEGFile, nCodeStreamLength);
+        }
+        if( pStream == nullptr )
+        {
+            CPLError(CE_Failure, CPLE_AppDefined, "JP2OpenJPEGCreateReadStream() failed");
+            eErr = CE_Failure;
+            goto end;
+        }
+
+#if IS_OPENJPEG_OR_LATER(2,2,0)
+        if( getenv("OPJ_NUM_THREADS") == nullptr )
+        {
+            if( m_nBlocksToLoad <= 1 )
+                opj_codec_set_threads(pCodec, GetNumThreads());
+            else
+                opj_codec_set_threads(pCodec, GetNumThreads() / m_nBlocksToLoad);
+        }
+#endif
+
+        if(!opj_read_header(pStream,pCodec,&psImage))
+        {
+            CPLError(CE_Failure, CPLE_AppDefined, "opj_read_header() failed (psImage=%p)", psImage);
+#if IS_OPENJPEG_OR_LATER(2,2,0)
+            // Hopefully the situation is better on openjpeg 2.2 regarding cleanup
+            eErr = CE_Failure;
+            goto end;
+#else
+            // We may leak objects, but the cleanup of openjpeg can cause
+            // double frees sometimes...
+            return CE_Failure;
+#endif
+        }
+    }
+
+    if (!opj_set_decoded_resolution_factor( pCodec, iLevel ))
+    {
+        CPLError(CE_Failure, CPLE_AppDefined, "opj_set_decoded_resolution_factor() failed");
+        eErr = CE_Failure;
+        goto end;
+    }
+
+    if (bUseSetDecodeArea)
+    {
+        /* We need to explicitly set the resolution factor on the image */
+        /* otherwise opj_set_decode_area() will assume we decode at full */
+        /* resolution. */
+        /* If using parameters.cp_reduce instead of opj_set_decoded_resolution_factor() */
+        /* we wouldn't need to do that, as opj_read_header() would automatically */
+        /* assign the comps[].factor to the appropriate value */
+        for(unsigned int iBand = 0; iBand < psImage->numcomps; iBand ++)
+        {
+            psImage->comps[iBand].factor = iLevel;
+        }
+        /* The decode area must be expressed in grid reference, ie at full*/
+        /* scale */
+        if (!opj_set_decode_area(pCodec,psImage,
+                                 m_nX0 + static_cast<int>(static_cast<GIntBig>(nBlockXOff*nBlockXSize) * nParentXSize / nRasterXSize),
+                                 m_nY0 + static_cast<int>(static_cast<GIntBig>(nBlockYOff*nBlockYSize) * nParentYSize / nRasterYSize),
+                                 m_nX0 + static_cast<int>(static_cast<GIntBig>(nBlockXOff*nBlockXSize+nWidthToRead) * nParentXSize / nRasterXSize),
+                                 m_nY0 + static_cast<int>(static_cast<GIntBig>(nBlockYOff*nBlockYSize+nHeightToRead) * nParentYSize / nRasterYSize)))
+        {
+            CPLError(CE_Failure, CPLE_AppDefined, "opj_set_decode_area() failed");
+            eErr = CE_Failure;
+            goto end;
+        }
+        if (!opj_decode(pCodec,pStream, psImage))
+        {
+            CPLError(CE_Failure, CPLE_AppDefined, "opj_decode() failed");
+            eErr = CE_Failure;
+            goto end;
+        }
+    }
+    else
+    {
+        if (!opj_get_decoded_tile( pCodec, pStream, psImage, nTileNumber ))
+        {
+            CPLError(CE_Failure, CPLE_AppDefined, "opj_get_decoded_tile() failed");
+            eErr = CE_Failure;
+            goto end;
+        }
+    }
+
+    for(unsigned int iBand = 0; iBand < psImage->numcomps; iBand ++)
+    {
+        if( psImage->comps[iBand].data == nullptr )
+        {
+            CPLError(CE_Failure, CPLE_AppDefined,
+                     "psImage->comps[%d].data == nullptr", iBand);
+            eErr = CE_Failure;
+            goto end;
+        }
+    }
+
+    for(int xBand = 0; xBand < nBandCount; xBand ++)
+    {
+        GDALRasterBlock *poBlock = nullptr;
+        int iBand = (panBandMap) ? panBandMap[xBand] : xBand + 1;
+        int bPromoteTo8Bit = ((JP2OpenJPEGRasterBand*)GetRasterBand(iBand))->bPromoteTo8Bit;
+
+        void* pDstBuffer = nullptr;
+        if (iBand == nBand)
+            pDstBuffer = pImage;
+        else
+        {
+            AcquireMutex();
+            poBlock = ((JP2OpenJPEGRasterBand*)GetRasterBand(iBand))->
+                TryGetLockedBlockRef(nBlockXOff,nBlockYOff);
+            if (poBlock != nullptr)
+            {
+                ReleaseMutex();
+                poBlock->DropLock();
+                continue;
+            }
+
+            poBlock = GetRasterBand(iBand)->
+                GetLockedBlockRef(nBlockXOff,nBlockYOff, TRUE);
+            ReleaseMutex();
+            if (poBlock == nullptr)
+            {
+                continue;
+            }
+
+            pDstBuffer = poBlock->GetDataRef();
+        }
+
+        if (bIs420)
+        {
+            if( (int)psImage->comps[0].w < nWidthToRead ||
+                (int)psImage->comps[0].h < nHeightToRead ||
+                psImage->comps[1].w != (psImage->comps[0].w + 1) / 2 ||
+                psImage->comps[1].h != (psImage->comps[0].h + 1) / 2 ||
+                psImage->comps[2].w != (psImage->comps[0].w + 1) / 2 ||
+                psImage->comps[2].h != (psImage->comps[0].h + 1) / 2 ||
+                (nBands == 4 && (
+                    (int)psImage->comps[3].w < nWidthToRead ||
+                    (int)psImage->comps[3].h < nHeightToRead)) )
+            {
+                CPLError(CE_Failure, CPLE_AssertionFailed,
+                         "Assertion at line %d of %s failed",
+                         __LINE__, __FILE__);
+                if (poBlock != nullptr)
+                    poBlock->DropLock();
+                eErr = CE_Failure;
+                goto end;
+            }
+
+            GByte* pDst = (GByte*)pDstBuffer;
+            if( iBand == 4 )
+            {
+                const OPJ_INT32* pSrcA = psImage->comps[3].data;
+                for(GPtrDiff_t j=0;j<nHeightToRead;j++)
+                {
+                    memcpy(pDst + j*nBlockXSize,
+                            pSrcA + j * psImage->comps[0].w,
+                            nWidthToRead);
+                }
+            }
+            else
+            {
+                const OPJ_INT32* pSrcY = psImage->comps[0].data;
+                const OPJ_INT32* pSrcCb = psImage->comps[1].data;
+                const OPJ_INT32* pSrcCr = psImage->comps[2].data;
+                for(GPtrDiff_t j=0;j<nHeightToRead;j++)
+                {
+                    for(int i=0;i<nWidthToRead;i++)
+                    {
+                        int Y = pSrcY[j * psImage->comps[0].w + i];
+                        int Cb = pSrcCb[(j/2) * psImage->comps[1].w + (i/2)];
+                        int Cr = pSrcCr[(j/2) * psImage->comps[2].w + (i/2)];
+                        if (iBand == 1)
+                            pDst[j * nBlockXSize + i] = CLAMP_0_255((int)(Y + 1.402 * (Cr - 128)));
+                        else if (iBand == 2)
+                            pDst[j * nBlockXSize + i] = CLAMP_0_255((int)(Y - 0.34414 * (Cb - 128) - 0.71414 * (Cr - 128)));
+                        else if (iBand == 3)
+                            pDst[j * nBlockXSize + i] = CLAMP_0_255((int)(Y + 1.772 * (Cb - 128)));
+                    }
+                }
+            }
+
+            if( bPromoteTo8Bit )
+            {
+                for(GPtrDiff_t j=0;j<nHeightToRead;j++)
+                {
+                    for(int i=0;i<nWidthToRead;i++)
+                    {
+                        pDst[j * nBlockXSize + i] *= 255;
+                    }
+                }
+            }
+        }
+        else
+        {
+            if( (int)psImage->comps[iBand-1].w < nWidthToRead ||
+                (int)psImage->comps[iBand-1].h < nHeightToRead )
+            {
+                CPLError(CE_Failure, CPLE_AssertionFailed,
+                         "Assertion at line %d of %s failed",
+                         __LINE__, __FILE__);
+                if (poBlock != nullptr)
+                    poBlock->DropLock();
+                eErr = CE_Failure;
+                goto end;
+            }
+
+            if( bPromoteTo8Bit )
+            {
+                for(GPtrDiff_t j=0;j<nHeightToRead;j++)
+                {
+                    for(int i=0;i<nWidthToRead;i++)
+                    {
+                        psImage->comps[iBand-1].data[j * psImage->comps[iBand-1].w + i] *= 255;
+                    }
+                }
+            }
+
+            if ((int)psImage->comps[iBand-1].w == nBlockXSize &&
+                (int)psImage->comps[iBand-1].h == nBlockYSize)
+            {
+                GDALCopyWords64(psImage->comps[iBand-1].data, GDT_Int32, 4,
+                            pDstBuffer, eDataType, nDataTypeSize, static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize);
+            }
+            else
+            {
+                for(GPtrDiff_t j=0;j<nHeightToRead;j++)
+                {
+                    GDALCopyWords(psImage->comps[iBand-1].data + j * psImage->comps[iBand-1].w, GDT_Int32, 4,
+                                (GByte*)pDstBuffer + j * nBlockXSize * nDataTypeSize, eDataType, nDataTypeSize,
+                                nWidthToRead);
+                }
+            }
+        }
+
+        if (poBlock != nullptr)
+            poBlock->DropLock();
+    }
+
+end:
+#if IS_OPENJPEG_OR_LATER(2,3,0)
+    if( m_ppCodec != nullptr &&
+        CPLTestBool(CPLGetConfigOption("USE_OPENJPEG_SINGLE_TILE_OPTIM", "YES")) )
+    {
+        *m_ppCodec = pCodec;
+        *m_ppStream = pStream;
+        *m_ppsImage = psImage;
+    }
+    else
+#endif
+    {
+        if( pCodec && pStream )
+            opj_end_decompress(pCodec,pStream);
+        if( pStream )
+            opj_stream_destroy(pStream);
+        if( pCodec )
+            opj_destroy_codec(pCodec);
+        if( psImage )
+            opj_image_destroy(psImage);
+    }
+
+    return eErr;
+}
+
+/************************************************************************/
+/*                         GetOverviewCount()                           */
+/************************************************************************/
+
+int JP2OpenJPEGRasterBand::GetOverviewCount()
+{
+    JP2OpenJPEGDataset *poGDS = cpl::down_cast<JP2OpenJPEGDataset*>(poDS);
+    if( !poGDS->AreOverviewsEnabled() )
+        return 0;
+
+    if( GDALPamRasterBand::GetOverviewCount() > 0 )
+        return GDALPamRasterBand::GetOverviewCount();
+
+    return poGDS->nOverviewCount;
+}
+
+/************************************************************************/
+/*                            GetOverview()                             */
+/************************************************************************/
+
+GDALRasterBand* JP2OpenJPEGRasterBand::GetOverview(int iOvrLevel)
+{
+    if( GDALPamRasterBand::GetOverviewCount() > 0 )
+        return GDALPamRasterBand::GetOverview(iOvrLevel);
+
+    JP2OpenJPEGDataset *poGDS = (JP2OpenJPEGDataset *) poDS;
+    if (iOvrLevel < 0 || iOvrLevel >= poGDS->nOverviewCount)
+        return nullptr;
+
+    return poGDS->papoOverviewDS[iOvrLevel]->GetRasterBand(nBand);
+}
+
+/************************************************************************/
+/*                       GetColorInterpretation()                       */
+/************************************************************************/
+
+GDALColorInterp JP2OpenJPEGRasterBand::GetColorInterpretation()
+{
+    JP2OpenJPEGDataset *poGDS = (JP2OpenJPEGDataset *) poDS;
+
+    if( poCT )
+        return GCI_PaletteIndex;
+
+    if( nBand == poGDS->nAlphaIndex + 1 )
+        return GCI_AlphaBand;
+
+    if (poGDS->nBands <= 2 && poGDS->eColorSpace == OPJ_CLRSPC_GRAY)
+        return GCI_GrayIndex;
+    else if (poGDS->eColorSpace == OPJ_CLRSPC_SRGB ||
+             poGDS->eColorSpace == OPJ_CLRSPC_SYCC)
+    {
+        if( nBand == poGDS->nRedIndex + 1 )
+            return GCI_RedBand;
+        if( nBand == poGDS->nGreenIndex + 1 )
+            return GCI_GreenBand;
+        if( nBand == poGDS->nBlueIndex + 1 )
+            return GCI_BlueBand;
+    }
+
+    return GCI_Undefined;
+}
+
+/************************************************************************/
+/* ==================================================================== */
+/*                           JP2OpenJPEGDataset                         */
+/* ==================================================================== */
+/************************************************************************/
+
+/************************************************************************/
+/*                        JP2OpenJPEGDataset()                          */
+/************************************************************************/
+
+JP2OpenJPEGDataset::JP2OpenJPEGDataset()
+{
+}
+
+/************************************************************************/
+/*                         ~JP2OpenJPEGDataset()                        */
+/************************************************************************/
+
+JP2OpenJPEGDataset::~JP2OpenJPEGDataset()
+
+{
+    FlushCache(true);
+
+#if IS_OPENJPEG_OR_LATER(2,3,0)
+    if( iLevel == 0 )
+    {
+        if( m_ppCodec )
+            opj_destroy_codec(*m_ppCodec);
+        delete m_ppCodec;
+        if( m_ppStream )
+            opj_stream_destroy(*m_ppStream);
+        delete m_ppStream;
+        if( m_ppsImage )
+            opj_image_destroy(*m_ppsImage);
+        delete m_ppsImage;
+        CPLFree(m_psJP2OpenJPEGFile);
+        delete m_pnLastLevel;
+    }
+#endif
+
+    if( iLevel == 0 && fp != nullptr )
+    {
+        if( bRewrite )
+        {
+            GDALJP2Box oBox( fp );
+            vsi_l_offset nOffsetJP2C = 0;
+            vsi_l_offset nLengthJP2C = 0;
+            vsi_l_offset nOffsetXML = 0;
+            vsi_l_offset nOffsetASOC = 0;
+            vsi_l_offset nOffsetUUID = 0;
+            vsi_l_offset nOffsetIHDR = 0;
+            vsi_l_offset nLengthIHDR = 0;
+            int bMSIBox = FALSE;
+            int bGMLData = FALSE;
+            int bUnsupportedConfiguration = FALSE;
+            if( oBox.ReadFirst() )
+            {
+                while( strlen(oBox.GetType()) > 0 )
+                {
+                    if( EQUAL(oBox.GetType(),"jp2c") )
+                    {
+                        if( nOffsetJP2C == 0 )
+                        {
+                            nOffsetJP2C = VSIFTellL(fp);
+                            nLengthJP2C = oBox.GetDataLength();
+                        }
+                        else
+                            bUnsupportedConfiguration = TRUE;
+                    }
+                    else if( EQUAL(oBox.GetType(),"jp2h") )
+                    {
+                        GDALJP2Box oSubBox( fp );
+                        if( oSubBox.ReadFirstChild( &oBox ) &&
+                            EQUAL(oSubBox.GetType(),"ihdr") )
+                        {
+                            nOffsetIHDR = VSIFTellL(fp);
+                            nLengthIHDR = oSubBox.GetDataLength();
+                        }
+                    }
+                    else if( EQUAL(oBox.GetType(),"xml ") )
+                    {
+                        if( nOffsetXML == 0 )
+                            nOffsetXML = VSIFTellL(fp);
+                    }
+                    else if( EQUAL(oBox.GetType(),"asoc") )
+                    {
+                        if( nOffsetASOC == 0 )
+                            nOffsetASOC = VSIFTellL(fp);
+
+                        GDALJP2Box oSubBox( fp );
+                        if( oSubBox.ReadFirstChild( &oBox ) &&
+                            EQUAL(oSubBox.GetType(),"lbl ") )
+                        {
+                            char *pszLabel = (char *) oSubBox.ReadBoxData();
+                            if( pszLabel != nullptr && EQUAL(pszLabel,"gml.data") )
+                            {
+                                bGMLData = TRUE;
+                            }
+                            else
+                                bUnsupportedConfiguration = TRUE;
+                            CPLFree( pszLabel );
+                        }
+                        else
+                            bUnsupportedConfiguration = TRUE;
+                    }
+                    else if( EQUAL(oBox.GetType(),"uuid") )
+                    {
+                        if( nOffsetUUID == 0 )
+                            nOffsetUUID = VSIFTellL(fp);
+                        if( GDALJP2Metadata::IsUUID_MSI(oBox.GetUUID()) )
+                            bMSIBox = TRUE;
+                        else if( !GDALJP2Metadata::IsUUID_XMP(oBox.GetUUID()) )
+                            bUnsupportedConfiguration = TRUE;
+                    }
+                    else if( !EQUAL(oBox.GetType(),"jP  ") &&
+                             !EQUAL(oBox.GetType(),"ftyp") &&
+                             !EQUAL(oBox.GetType(),"rreq") &&
+                             !EQUAL(oBox.GetType(),"jp2h") &&
+                             !EQUAL(oBox.GetType(),"jp2i") )
+                    {
+                        bUnsupportedConfiguration = TRUE;
+                    }
+
+                    if (bUnsupportedConfiguration || !oBox.ReadNext())
+                        break;
+                }
+            }
+
+            const char* pszGMLJP2;
+            int bGeoreferencingCompatOfGMLJP2 =
+                       (!m_oSRS.IsEmpty() &&
+                        bGeoTransformValid && nGCPCount == 0);
+            if( bGeoreferencingCompatOfGMLJP2 &&
+                ((bHasGeoreferencingAtOpening && bGMLData) ||
+                 (!bHasGeoreferencingAtOpening)) )
+                pszGMLJP2 = "GMLJP2=YES";
+            else
+                pszGMLJP2 = "GMLJP2=NO";
+
+            const char* pszGeoJP2;
+            int bGeoreferencingCompatOfGeoJP2 =
+                    (!m_oSRS.IsEmpty() ||
+                    nGCPCount != 0 || bGeoTransformValid);
+            if( bGeoreferencingCompatOfGeoJP2 &&
+                ((bHasGeoreferencingAtOpening && bMSIBox) ||
+                 (!bHasGeoreferencingAtOpening) || nGCPCount > 0) )
+                pszGeoJP2 = "GeoJP2=YES";
+            else
+                pszGeoJP2 = "GeoJP2=NO";
+
+            /* Test that the length of the JP2C box is not 0 */
+            int bJP2CBoxOKForRewriteInPlace = TRUE;
+            if( nOffsetJP2C > 16 && !bUnsupportedConfiguration )
+            {
+                VSIFSeekL(fp, nOffsetJP2C - 8, SEEK_SET);
+                GByte abyBuffer[8];
+                VSIFReadL(abyBuffer, 1, 8, fp);
+                if( STARTS_WITH_CI((const char*)abyBuffer + 4, "jp2c") &&
+                    abyBuffer[0] == 0 && abyBuffer[1] == 0 &&
+                    abyBuffer[2] == 0 && abyBuffer[3] == 0 )
+                {
+                    if( (vsi_l_offset)(GUInt32)(nLengthJP2C + 8) == (nLengthJP2C + 8) )
+                    {
+                        CPLDebug("OPENJPEG", "Patching length of JP2C box with real length");
+                        VSIFSeekL(fp, nOffsetJP2C - 8, SEEK_SET);
+                        GUInt32 nLength = (GUInt32)nLengthJP2C + 8;
+                        CPL_MSBPTR32(&nLength);
+                        VSIFWriteL(&nLength, 1, 4, fp);
+                    }
+                    else
+                        bJP2CBoxOKForRewriteInPlace = FALSE;
+                }
+            }
+
+            if( nOffsetJP2C == 0 || bUnsupportedConfiguration )
+            {
+                CPLError(CE_Failure, CPLE_AppDefined,
+                         "Cannot rewrite file due to unsupported JP2 box configuration");
+                VSIFCloseL( fp );
+            }
+            else if( bJP2CBoxOKForRewriteInPlace &&
+                     (nOffsetXML == 0 || nOffsetXML > nOffsetJP2C) &&
+                     (nOffsetASOC == 0 || nOffsetASOC > nOffsetJP2C) &&
+                     (nOffsetUUID == 0 || nOffsetUUID > nOffsetJP2C) )
+            {
+                CPLDebug("OPENJPEG", "Rewriting boxes after codestream");
+
+                /* Update IPR flag */
+                if( nLengthIHDR == 14 )
+                {
+                    VSIFSeekL( fp, nOffsetIHDR + nLengthIHDR - 1, SEEK_SET );
+                    GByte bIPR = GetMetadata("xml:IPR") != nullptr;
+                    VSIFWriteL( &bIPR, 1, 1, fp );
+                }
+
+                VSIFSeekL( fp, nOffsetJP2C + nLengthJP2C, SEEK_SET );
+
+                GDALJP2Metadata oJP2MD;
+                if( GetGCPCount() > 0 )
+                {
+                    oJP2MD.SetGCPs( GetGCPCount(),
+                                    GetGCPs() );
+                    oJP2MD.SetSpatialRef( GetGCPSpatialRef() );
+                }
+                else
+                {
+                    const OGRSpatialReference* poSRS = GetSpatialRef();
+                    if( poSRS != nullptr )
+                    {
+                        oJP2MD.SetSpatialRef( poSRS );
+                    }
+                    if( bGeoTransformValid )
+                    {
+                        oJP2MD.SetGeoTransform( adfGeoTransform );
+                    }
+                }
+
+                const char* pszAreaOrPoint = GetMetadataItem(GDALMD_AREA_OR_POINT);
+                oJP2MD.bPixelIsPoint = pszAreaOrPoint != nullptr && EQUAL(pszAreaOrPoint, GDALMD_AOP_POINT);
+
+                WriteIPRBox(fp, this, nullptr);
+
+                if( bGeoreferencingCompatOfGMLJP2 && EQUAL(pszGMLJP2, "GMLJP2=YES") )
+                {
+                    GDALJP2Box* poBox = oJP2MD.CreateGMLJP2(nRasterXSize,nRasterYSize);
+                    WriteBox(fp, poBox);
+                    delete poBox;
+                }
+
+                WriteXMLBoxes(fp, this, nullptr);
+                WriteGDALMetadataBox(fp, this, nullptr);
+
+                if( bGeoreferencingCompatOfGeoJP2 && EQUAL(pszGeoJP2, "GeoJP2=YES") )
+                {
+                    GDALJP2Box* poBox = oJP2MD.CreateJP2GeoTIFF();
+                    WriteBox(fp, poBox);
+                    delete poBox;
+                }
+
+                WriteXMPBox(fp, this, nullptr);
+
+                VSIFTruncateL( fp, VSIFTellL(fp) );
+
+                VSIFCloseL( fp );
+            }
+            else
+            {
+                VSIFCloseL( fp );
+
+                CPLDebug("OPENJPEG", "Rewriting whole file");
+
+                const char* apszOptions[] = {
+                    "USE_SRC_CODESTREAM=YES", "CODEC=JP2", "WRITE_METADATA=YES",
+                    nullptr, nullptr, nullptr };
+                apszOptions[3] = pszGMLJP2;
+                apszOptions[4] = pszGeoJP2;
+                CPLString osTmpFilename(CPLSPrintf("%s.tmp", GetDescription()));
+                GDALDataset* poOutDS = CreateCopy( osTmpFilename, this, FALSE,
+                                                (char**)apszOptions, GDALDummyProgress, nullptr );
+                if( poOutDS )
+                {
+                    GDALClose(poOutDS);
+                    VSIRename(osTmpFilename, GetDescription());
+                }
+                else
+                    VSIUnlink(osTmpFilename);
+                VSIUnlink(CPLSPrintf("%s.tmp.aux.xml", GetDescription()));
+            }
+        }
+        else
+            VSIFCloseL( fp );
+    }
+
+    JP2OpenJPEGDataset::CloseDependentDatasets();
+}
+
+/************************************************************************/
+/*                      CloseDependentDatasets()                        */
+/************************************************************************/
+
+int JP2OpenJPEGDataset::CloseDependentDatasets()
+{
+    int bRet = GDALJP2AbstractDataset::CloseDependentDatasets();
+    if ( papoOverviewDS )
+    {
+        for( int i = 0; i < nOverviewCount; i++ )
+            delete papoOverviewDS[i];
+        CPLFree( papoOverviewDS );
+        papoOverviewDS = nullptr;
+        bRet = TRUE;
+    }
+    return bRet;
+}
+
+/************************************************************************/
+/*                           SetSpatialRef()                            */
+/************************************************************************/
+
+CPLErr JP2OpenJPEGDataset::SetSpatialRef( const OGRSpatialReference * poSRS )
+{
+    if( eAccess == GA_Update )
+    {
+        bRewrite = TRUE;
+        m_oSRS.Clear();
+        if( poSRS )
+            m_oSRS = *poSRS;
+        return CE_None;
+    }
+    else
+        return GDALJP2AbstractDataset::SetSpatialRef(poSRS);
+}
+
+/************************************************************************/
+/*                           SetGeoTransform()                          */
+/************************************************************************/
+
+CPLErr JP2OpenJPEGDataset::SetGeoTransform( double *padfGeoTransform )
+{
+    if( eAccess == GA_Update )
+    {
+        bRewrite = TRUE;
+        memcpy(adfGeoTransform, padfGeoTransform, 6* sizeof(double));
+        bGeoTransformValid = !(
+            adfGeoTransform[0] == 0.0 && adfGeoTransform[1] == 1.0 &&
+            adfGeoTransform[2] == 0.0 && adfGeoTransform[3] == 0.0 &&
+            adfGeoTransform[4] == 0.0 && adfGeoTransform[5] == 1.0);
+        return CE_None;
+    }
+    else
+        return GDALJP2AbstractDataset::SetGeoTransform(padfGeoTransform);
+}
+
+/************************************************************************/
+/*                           SetGCPs()                                  */
+/************************************************************************/
+
+CPLErr JP2OpenJPEGDataset::SetGCPs( int nGCPCountIn, const GDAL_GCP *pasGCPListIn,
+                                    const OGRSpatialReference* poSRS )
+{
+    if( eAccess == GA_Update )
+    {
+        bRewrite = TRUE;
+        if( nGCPCount > 0 )
+        {
+            GDALDeinitGCPs( nGCPCount, pasGCPList );
+            CPLFree( pasGCPList );
+        }
+
+        m_oSRS.Clear();
+        if( poSRS )
+            m_oSRS = *poSRS;
+
+        nGCPCount = nGCPCountIn;
+        pasGCPList = GDALDuplicateGCPs( nGCPCount, pasGCPListIn );
+
+        return CE_None;
+    }
+    else
+        return GDALJP2AbstractDataset::SetGCPs(nGCPCountIn, pasGCPListIn,
+                                               poSRS);
+}
+
+/************************************************************************/
+/*                            SetMetadata()                             */
+/************************************************************************/
+
+CPLErr JP2OpenJPEGDataset::SetMetadata( char ** papszMetadata,
+                                        const char * pszDomain )
+{
+    if( eAccess == GA_Update )
+    {
+        bRewrite = TRUE;
+        if( pszDomain == nullptr || EQUAL(pszDomain, "") )
+        {
+            CSLDestroy(m_papszMainMD);
+            m_papszMainMD = CSLDuplicate(papszMetadata);
+        }
+        return GDALDataset::SetMetadata(papszMetadata, pszDomain);
+    }
+    return GDALJP2AbstractDataset::SetMetadata(papszMetadata, pszDomain);
+}
+
+/************************************************************************/
+/*                            SetMetadata()                             */
+/************************************************************************/
+
+CPLErr JP2OpenJPEGDataset::SetMetadataItem( const char * pszName,
+                                            const char * pszValue,
+                                            const char * pszDomain )
+{
+    if( eAccess == GA_Update )
+    {
+        bRewrite = TRUE;
+        if( pszDomain == nullptr || EQUAL(pszDomain, "") )
+        {
+            m_papszMainMD = CSLSetNameValue( GetMetadata(), pszName, pszValue );
+        }
+        return GDALDataset::SetMetadataItem(pszName, pszValue, pszDomain);
+    }
+    return GDALJP2AbstractDataset::SetMetadataItem(pszName, pszValue, pszDomain);
+}
+
+/************************************************************************/
+/*                            Identify()                                */
+/************************************************************************/
+
+static const unsigned char jpc_header[] = {0xff,0x4f,0xff,0x51}; // SOC + RSIZ markers
+static const unsigned char jp2_box_jp[] = {0x6a,0x50,0x20,0x20}; /* 'jP  ' */
+
+int JP2OpenJPEGDataset::Identify( GDALOpenInfo * poOpenInfo )
+
+{
+    if( poOpenInfo->nHeaderBytes >= 16
+        && (memcmp( poOpenInfo->pabyHeader, jpc_header,
+                    sizeof(jpc_header) ) == 0
+            || memcmp( poOpenInfo->pabyHeader + 4, jp2_box_jp,
+                    sizeof(jp2_box_jp) ) == 0
+           ) )
+        return TRUE;
+
+    else
+        return FALSE;
+}
+
+/************************************************************************/
+/*                        JP2OpenJPEGFindCodeStream()                   */
+/************************************************************************/
+
+static vsi_l_offset JP2OpenJPEGFindCodeStream( VSILFILE* fp,
+                                               vsi_l_offset* pnLength )
+{
+    vsi_l_offset nCodeStreamStart = 0;
+    vsi_l_offset nCodeStreamLength = 0;
+
+    VSIFSeekL(fp, 0, SEEK_SET);
+    GByte abyHeader[16];
+    VSIFReadL(abyHeader, 1, 16, fp);
+
+    if (memcmp( abyHeader, jpc_header, sizeof(jpc_header) ) == 0)
+    {
+        VSIFSeekL(fp, 0, SEEK_END);
+        nCodeStreamLength = VSIFTellL(fp);
+    }
+    else if (memcmp( abyHeader + 4, jp2_box_jp, sizeof(jp2_box_jp) ) == 0)
+    {
+        /* Find offset of first jp2c box */
+        GDALJP2Box oBox( fp );
+        if( oBox.ReadFirst() )
+        {
+            while( strlen(oBox.GetType()) > 0 )
+            {
+                if( EQUAL(oBox.GetType(),"jp2c") )
+                {
+                    nCodeStreamStart = VSIFTellL(fp);
+                    nCodeStreamLength = oBox.GetDataLength();
+                    break;
+                }
+
+                if (!oBox.ReadNext())
+                    break;
+            }
+        }
+    }
+    *pnLength = nCodeStreamLength;
+    return nCodeStreamStart;
+}
+
+/************************************************************************/
+/*                                Open()                                */
+/************************************************************************/
+
+GDALDataset *JP2OpenJPEGDataset::Open( GDALOpenInfo * poOpenInfo )
+
+{
+    if (!Identify(poOpenInfo) || poOpenInfo->fpL == nullptr)
+        return nullptr;
+
+    /* Detect which codec to use : J2K or JP2 ? */
+    vsi_l_offset nCodeStreamLength = 0;
+    vsi_l_offset nCodeStreamStart = JP2OpenJPEGFindCodeStream(poOpenInfo->fpL,
+                                                              &nCodeStreamLength);
+
+    if( nCodeStreamStart == 0 && nCodeStreamLength == 0 )
+    {
+        CPLError(CE_Failure, CPLE_AppDefined, "No code-stream in JP2 file");
+        return nullptr;
+    }
+
+    OPJ_CODEC_FORMAT eCodecFormat = (nCodeStreamStart == 0) ? OPJ_CODEC_J2K : OPJ_CODEC_JP2;
+
+    opj_codec_t* pCodec = opj_create_decompress(OPJ_CODEC_J2K);
+    if( pCodec == nullptr )
+        return nullptr;
+
+    opj_set_info_handler(pCodec, JP2OpenJPEGDataset_InfoCallback,nullptr);
+    opj_set_warning_handler(pCodec, JP2OpenJPEGDataset_WarningCallback, nullptr);
+    opj_set_error_handler(pCodec, JP2OpenJPEGDataset_ErrorCallback,nullptr);
+
+    opj_dparameters_t parameters;
+    opj_set_default_decoder_parameters(&parameters);
+
+    if (! opj_setup_decoder(pCodec,&parameters))
+    {
+        opj_destroy_codec(pCodec);
+        return nullptr;
+    }
+
+#if IS_OPENJPEG_OR_LATER(2,3,0)
+    if( getenv("OPJ_NUM_THREADS") == nullptr )
+    {
+        JP2OpenJPEGDataset oTmpDS;
+        opj_codec_set_threads(pCodec, oTmpDS.GetNumThreads());
+    }
+#endif
+
+    JP2OpenJPEGFile* psJP2OpenJPEGFile = static_cast<JP2OpenJPEGFile*>(
+        CPLMalloc(sizeof(JP2OpenJPEGFile)));
+    psJP2OpenJPEGFile->fp = poOpenInfo->fpL;
+    psJP2OpenJPEGFile->nBaseOffset = nCodeStreamStart;
+    opj_stream_t * pStream = JP2OpenJPEGCreateReadStream(psJP2OpenJPEGFile,
+                                                         nCodeStreamLength);
+
+    opj_image_t * psImage = nullptr;
+
+    if( pStream == nullptr )
+    {
+        CPLError(CE_Failure, CPLE_AppDefined, "JP2OpenJPEGCreateReadStream() failed");
+        opj_stream_destroy(pStream);
+        opj_destroy_codec(pCodec);
+        CPLFree(psJP2OpenJPEGFile);
+        return nullptr;
+    }
+
+    if(!opj_read_header(pStream,pCodec,&psImage))
+    {
+        CPLError(CE_Failure, CPLE_AppDefined, "opj_read_header() failed");
+        opj_destroy_codec(pCodec);
+        opj_stream_destroy(pStream);
+        opj_image_destroy(psImage);
+        CPLFree(psJP2OpenJPEGFile);
+        return nullptr;
+    }
+
+    opj_codestream_info_v2_t* pCodeStreamInfo = opj_get_cstr_info(pCodec);
+    OPJ_UINT32 nTileW,nTileH;
+    nTileW = pCodeStreamInfo->tdx;
+    nTileH = pCodeStreamInfo->tdy;
+#ifdef DEBUG
+    OPJ_UINT32  nX0,nY0;
+    OPJ_UINT32 nTilesX,nTilesY;
+    nX0 = pCodeStreamInfo->tx0;
+    nY0 = pCodeStreamInfo->ty0;
+    nTilesX = pCodeStreamInfo->tw;
+    nTilesY = pCodeStreamInfo->th;
+    int mct = pCodeStreamInfo->m_default_tile_info.mct;
+#endif
+    int numResolutions = pCodeStreamInfo->m_default_tile_info.tccp_info[0].numresolutions;
+    opj_destroy_cstr_info(&pCodeStreamInfo);
+
+    if (psImage == nullptr)
+    {
+        opj_destroy_codec(pCodec);
+        opj_stream_destroy(pStream);
+        opj_image_destroy(psImage);
+        CPLFree(psJP2OpenJPEGFile);
+        return nullptr;
+    }
+
+#ifdef DEBUG
+    CPLDebug("OPENJPEG", "nX0 = %u", nX0);
+    CPLDebug("OPENJPEG", "nY0 = %u", nY0);
+    CPLDebug("OPENJPEG", "nTileW = %u", nTileW);
+    CPLDebug("OPENJPEG", "nTileH = %u", nTileH);
+    CPLDebug("OPENJPEG", "nTilesX = %u", nTilesX);
+    CPLDebug("OPENJPEG", "nTilesY = %u", nTilesY);
+    CPLDebug("OPENJPEG", "mct = %d", mct);
+    CPLDebug("OPENJPEG", "psImage->x0 = %u", psImage->x0);
+    CPLDebug("OPENJPEG", "psImage->y0 = %u", psImage->y0);
+    CPLDebug("OPENJPEG", "psImage->x1 = %u", psImage->x1);
+    CPLDebug("OPENJPEG", "psImage->y1 = %u", psImage->y1);
+    CPLDebug("OPENJPEG", "psImage->numcomps = %d", psImage->numcomps);
+    //CPLDebug("OPENJPEG", "psImage->color_space = %d", psImage->color_space);
+    CPLDebug("OPENJPEG", "numResolutions = %d", numResolutions);
+    for(int i=0;i<(int)psImage->numcomps;i++)
+    {
+        CPLDebug("OPENJPEG", "psImage->comps[%d].dx = %u", i, psImage->comps[i].dx);
+        CPLDebug("OPENJPEG", "psImage->comps[%d].dy = %u", i, psImage->comps[i].dy);
+        CPLDebug("OPENJPEG", "psImage->comps[%d].x0 = %u", i, psImage->comps[i].x0);
+        CPLDebug("OPENJPEG", "psImage->comps[%d].y0 = %u", i, psImage->comps[i].y0);
+        CPLDebug("OPENJPEG", "psImage->comps[%d].w = %u", i, psImage->comps[i].w);
+        CPLDebug("OPENJPEG", "psImage->comps[%d].h = %u", i, psImage->comps[i].h);
+        CPLDebug("OPENJPEG", "psImage->comps[%d].resno_decoded = %d", i, psImage->comps[i].resno_decoded);
+        CPLDebug("OPENJPEG", "psImage->comps[%d].factor = %d", i, psImage->comps[i].factor);
+        CPLDebug("OPENJPEG", "psImage->comps[%d].prec = %d", i, psImage->comps[i].prec);
+        CPLDebug("OPENJPEG", "psImage->comps[%d].sgnd = %d", i, psImage->comps[i].sgnd);
+    }
+#endif
+
+    if (psImage->x1 <= psImage->x0 ||
+        psImage->y1 <= psImage->y0 ||
+        psImage->numcomps == 0 ||
+        (psImage->comps[0].w >> 31) != 0 ||
+        (psImage->comps[0].h >> 31) != 0 ||
+        (nTileW >> 31) != 0 ||
+        (nTileH >> 31) != 0 ||
+        psImage->comps[0].w != psImage->x1 - psImage->x0 ||
+        psImage->comps[0].h != psImage->y1 - psImage->y0)
+    {
+        CPLDebug("OPENJPEG", "Unable to handle that image (1)");
+        opj_destroy_codec(pCodec);
+        opj_stream_destroy(pStream);
+        opj_image_destroy(psImage);
+        CPLFree(psJP2OpenJPEGFile);
+        return nullptr;
+    }
+
+    GDALDataType eDataType = GDT_Byte;
+    if (psImage->comps[0].prec > 16)
+    {
+        if (psImage->comps[0].sgnd)
+            eDataType = GDT_Int32;
+        else
+            eDataType = GDT_UInt32;
+    }
+    else if (psImage->comps[0].prec > 8)
+    {
+        if (psImage->comps[0].sgnd)
+            eDataType = GDT_Int16;
+        else
+            eDataType = GDT_UInt16;
+    }
+
+    int bIs420  =  (psImage->color_space != OPJ_CLRSPC_SRGB &&
+                    eDataType == GDT_Byte &&
+                    (psImage->numcomps == 3 || psImage->numcomps == 4) &&
+                    psImage->comps[1].w == psImage->comps[0].w / 2 &&
+                    psImage->comps[1].h == psImage->comps[0].h / 2 &&
+                    psImage->comps[2].w == psImage->comps[0].w / 2 &&
+                    psImage->comps[2].h == psImage->comps[0].h / 2) &&
+                    (psImage->numcomps == 3 ||
+                     (psImage->numcomps == 4 &&
+                      psImage->comps[3].w == psImage->comps[0].w &&
+                      psImage->comps[3].h == psImage->comps[0].h));
+
+    if (bIs420)
+    {
+        CPLDebug("OPENJPEG", "420 format");
+    }
+    else
+    {
+        int iBand;
+        for(iBand = 2; iBand <= (int)psImage->numcomps; iBand ++)
+        {
+            if( psImage->comps[iBand-1].w != psImage->comps[0].w ||
+                psImage->comps[iBand-1].h != psImage->comps[0].h )
+            {
+                CPLDebug("OPENJPEG", "Unable to handle that image (2)");
+                opj_destroy_codec(pCodec);
+                opj_stream_destroy(pStream);
+                opj_image_destroy(psImage);
+                CPLFree(psJP2OpenJPEGFile);
+                return nullptr;
+            }
+        }
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Create a corresponding GDALDataset.                             */
+/* -------------------------------------------------------------------- */
+    JP2OpenJPEGDataset     *poDS;
+    int                 iBand;
+
+    poDS = new JP2OpenJPEGDataset();
+    poDS->m_osFilename = poOpenInfo->pszFilename;
+    if( eCodecFormat == OPJ_CODEC_JP2 )
+        poDS->eAccess = poOpenInfo->eAccess;
+    poDS->eColorSpace = psImage->color_space;
+    poDS->nRasterXSize = psImage->x1 - psImage->x0;
+    poDS->nRasterYSize = psImage->y1 - psImage->y0;
+    poDS->nBands = psImage->numcomps;
+    poDS->fp = poOpenInfo->fpL;
+    poOpenInfo->fpL = nullptr;
+    poDS->nCodeStreamStart = nCodeStreamStart;
+    poDS->nCodeStreamLength = nCodeStreamLength;
+    poDS->bIs420 = bIs420;
+    poDS->bSingleTiled = (poDS->nRasterXSize == (int)nTileW &&
+                          poDS->nRasterYSize == (int)nTileH);
+    poDS->m_nX0 = psImage->x0;
+    poDS->m_nY0 = psImage->y0;
+
+    int nBlockXSize = (int)nTileW;
+    int nBlockYSize = (int)nTileH;
+
+    if( CPLFetchBool(poOpenInfo->papszOpenOptions, "USE_TILE_AS_BLOCK", false) )
+    {
+        poDS->bUseSetDecodeArea = false;
+    }
+
+#if IS_OPENJPEG_OR_LATER(2,5,0)
+    if( !CPLTestBool(CSLFetchNameValueDef(poOpenInfo->papszOpenOptions, "STRICT", "YES")) )
+    {
+        poDS->m_bStrict = false;
+        opj_decoder_set_strict_mode(pCodec, false);
+    }
+#endif
+
+    /* Some Sentinel2 preview datasets are 343x343 large, but with 8x8 blocks */
+    /* Using the tile API for that is super slow, so expose a single block */
+    else if( poDS->nRasterXSize <= 1024 &&  poDS->nRasterYSize <= 1024 &&
+             nTileW < 32 && nTileH < 32 )
+    {
+        poDS->bUseSetDecodeArea = true;
+        nBlockXSize = poDS->nRasterXSize;
+        nBlockYSize = poDS->nRasterYSize;
+    }
+    else
+    {
+        poDS->bUseSetDecodeArea =
+            poDS->bSingleTiled &&
+            (poDS->nRasterXSize > 1024 ||
+            poDS->nRasterYSize > 1024);
+
+        /* Other Sentinel2 preview datasets are 343x343 and 60m are 1830x1830, but they */
+        /* are tiled with tile dimensions 2048x2048. It would be a waste of */
+        /* memory to allocate such big blocks */
+        if( poDS->nRasterXSize < (int)nTileW &&
+            poDS->nRasterYSize < (int)nTileH )
+        {
+            poDS->bUseSetDecodeArea = TRUE;
+            nBlockXSize = poDS->nRasterXSize;
+            nBlockYSize = poDS->nRasterYSize;
+            if (nBlockXSize > 2048) nBlockXSize = 2048;
+            if (nBlockYSize > 2048) nBlockYSize = 2048;
+        }
+        else if (poDS->bUseSetDecodeArea)
+        {
+            // Arbitrary threshold... ~4 million at least needed for the GRIB2
+            // images mentioned below.
+            if( nTileH == 1 && nTileW < 20 * 1024 * 1024 )
+            {
+                // Some GRIB2 JPEG2000 compressed images are a 2D image organized
+                // as a single line image...
+            }
+            else
+            {
+                if (nBlockXSize > 1024) nBlockXSize = 1024;
+                if (nBlockYSize > 1024) nBlockYSize = 1024;
+            }
+        }
+    }
+
+    GDALColorTable* poCT = nullptr;
+
+/* -------------------------------------------------------------------- */
+/*      Look for color table or cdef box                                */
+/* -------------------------------------------------------------------- */
+    if( eCodecFormat == OPJ_CODEC_JP2 )
+    {
+        vsi_l_offset nCurOffset = VSIFTellL(poDS->fp);
+
+        GDALJP2Box oBox( poDS->fp );
+        if( oBox.ReadFirst() )
+        {
+            while( strlen(oBox.GetType()) > 0 )
+            {
+                if( EQUAL(oBox.GetType(),"jp2h") )
+                {
+                    GDALJP2Box oSubBox( poDS->fp );
+
+                    for( oSubBox.ReadFirstChild( &oBox );
+                         strlen(oSubBox.GetType()) > 0;
+                         oSubBox.ReadNextChild( &oBox ) )
+                    {
+                        GIntBig nDataLength = oSubBox.GetDataLength();
+                        if( poCT == nullptr &&
+                            EQUAL(oSubBox.GetType(),"pclr") &&
+                            nDataLength >= 3 &&
+                            nDataLength <= 2 + 1 + 4 + 4 * 256 )
+                        {
+                            GByte* pabyCT = oSubBox.ReadBoxData();
+                            if( pabyCT != nullptr )
+                            {
+                                int nEntries = (pabyCT[0] << 8) | pabyCT[1];
+                                int nComponents = pabyCT[2];
+                                /* CPLDebug("OPENJPEG", "Color table found"); */
+                                if( nEntries <= 256 && nComponents == 3 )
+                                {
+                                    /*CPLDebug("OPENJPEG", "resol[0] = %d", pabyCT[3]);
+                                    CPLDebug("OPENJPEG", "resol[1] = %d", pabyCT[4]);
+                                    CPLDebug("OPENJPEG", "resol[2] = %d", pabyCT[5]);*/
+                                    if( pabyCT[3] == 7 && pabyCT[4] == 7 && pabyCT[5] == 7 &&
+                                        nDataLength == 2 + 1 + 3 + 3 * nEntries )
+                                    {
+                                        poCT = new GDALColorTable();
+                                        for(int i=0;i<nEntries;i++)
+                                        {
+                                            GDALColorEntry sEntry;
+                                            sEntry.c1 = pabyCT[6 + 3 * i];
+                                            sEntry.c2 = pabyCT[6 + 3 * i + 1];
+                                            sEntry.c3 = pabyCT[6 + 3 * i + 2];
+                                            sEntry.c4 = 255;
+                                            poCT->SetColorEntry(i, &sEntry);
+                                        }
+                                    }
+                                }
+                                else if ( nEntries <= 256 && nComponents == 4 )
+                                {
+                                    if( pabyCT[3] == 7 && pabyCT[4] == 7 &&
+                                        pabyCT[5] == 7 && pabyCT[6] == 7 &&
+                                        nDataLength == 2 + 1 + 4 + 4 * nEntries )
+                                    {
+                                        poCT = new GDALColorTable();
+                                        for(int i=0;i<nEntries;i++)
+                                        {
+                                            GDALColorEntry sEntry;
+                                            sEntry.c1 = pabyCT[7 + 4 * i];
+                                            sEntry.c2 = pabyCT[7 + 4 * i + 1];
+                                            sEntry.c3 = pabyCT[7 + 4 * i + 2];
+                                            sEntry.c4 = pabyCT[7 + 4 * i + 3];
+                                            poCT->SetColorEntry(i, &sEntry);
+                                        }
+                                    }
+                                }
+                                CPLFree(pabyCT);
+                            }
+                        }
+                        /* There's a bug/misfeature in openjpeg: the color_space
+                           only gets set at read tile time */
+                        else if( EQUAL(oSubBox.GetType(),"colr") &&
+                                 nDataLength == 7 )
+                        {
+                            GByte* pabyContent = oSubBox.ReadBoxData();
+                            if( pabyContent != nullptr )
+                            {
+                                if( pabyContent[0] == 1 /* enumerated colourspace */ )
+                                {
+                                    GUInt32 enumcs = (pabyContent[3] << 24) |
+                                                     (pabyContent[4] << 16) |
+                                                     (pabyContent[5] << 8) |
+                                                     (pabyContent[6]);
+                                    if( enumcs == 16 )
+                                    {
+                                        poDS->eColorSpace = OPJ_CLRSPC_SRGB;
+                                        CPLDebug("OPENJPEG", "SRGB color space");
+                                    }
+                                    else if( enumcs == 17 )
+                                    {
+                                        poDS->eColorSpace = OPJ_CLRSPC_GRAY;
+                                        CPLDebug("OPENJPEG", "Grayscale color space");
+                                    }
+                                    else if( enumcs == 18 )
+                                    {
+                                        poDS->eColorSpace = OPJ_CLRSPC_SYCC;
+                                        CPLDebug("OPENJPEG", "SYCC color space");
+                                    }
+                                    else if( enumcs == 20 )
+                                    {
+                                        /* Used by J2KP4files/testfiles_jp2/file7.jp2 */
+                                        poDS->eColorSpace = OPJ_CLRSPC_SRGB;
+                                        CPLDebug("OPENJPEG", "e-sRGB color space");
+                                    }
+                                    else if( enumcs == 21 )
+                                    {
+                                        /* Used by J2KP4files/testfiles_jp2/file5.jp2 */
+                                        poDS->eColorSpace = OPJ_CLRSPC_SRGB;
+                                        CPLDebug("OPENJPEG", "ROMM-RGB color space");
+                                    }
+                                    else
+                                    {
+                                        poDS->eColorSpace = OPJ_CLRSPC_UNKNOWN;
+                                        CPLDebug("OPENJPEG", "Unknown color space");
+                                    }
+                                }
+                                CPLFree(pabyContent);
+                            }
+                        }
+                        /* Check if there's an alpha channel or odd channel attribution */
+                        else if( EQUAL(oSubBox.GetType(),"cdef") &&
+                                 nDataLength == 2 + poDS->nBands * 6 )
+                        {
+                            GByte* pabyContent = oSubBox.ReadBoxData();
+                            if( pabyContent != nullptr )
+                            {
+                                int nEntries = (pabyContent[0] << 8) | pabyContent[1];
+                                if( nEntries == poDS->nBands )
+                                {
+                                    poDS->nRedIndex = -1;
+                                    poDS->nGreenIndex = -1;
+                                    poDS->nBlueIndex = -1;
+                                    for(int i=0;i<poDS->nBands;i++)
+                                    {
+                                        int CNi = (pabyContent[2+6*i] << 8) | pabyContent[2+6*i+1];
+                                        int Typi = (pabyContent[2+6*i+2] << 8) | pabyContent[2+6*i+3];
+                                        int Asoci = (pabyContent[2+6*i+4] << 8) | pabyContent[2+6*i+5];
+                                        if( CNi < 0 || CNi >= poDS->nBands )
+                                        {
+                                            CPLError(CE_Failure, CPLE_AppDefined,
+                                                     "Wrong value of CN%d=%d", i, CNi);
+                                            break;
+                                        }
+                                        if( Typi == 0 )
+                                        {
+                                            if( Asoci == 1 )
+                                                poDS->nRedIndex = CNi;
+                                            else if( Asoci == 2 )
+                                                poDS->nGreenIndex = CNi;
+                                            else if( Asoci == 3 )
+                                                poDS->nBlueIndex = CNi;
+                                            else if( Asoci < 0 || (Asoci > poDS->nBands && Asoci != 65535) )
+                                            {
+                                                CPLError(CE_Failure, CPLE_AppDefined,
+                                                     "Wrong value of Asoc%d=%d", i, Asoci);
+                                                break;
+                                            }
+                                        }
+                                        else if( Typi == 1 )
+                                        {
+                                            poDS->nAlphaIndex = CNi;
+                                        }
+                                    }
+                                }
+                                else
+                                {
+                                    CPLDebug("OPENJPEG", "Unsupported cdef content");
+                                }
+                                CPLFree(pabyContent);
+                            }
+                        }
+                    }
+                }
+
+                if (!oBox.ReadNext())
+                    break;
+            }
+        }
+
+        VSIFSeekL(poDS->fp, nCurOffset, SEEK_SET);
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Create band information objects.                                */
+/* -------------------------------------------------------------------- */
+    for( iBand = 1; iBand <= poDS->nBands; iBand++ )
+    {
+        const bool bPromoteTo8Bit =
+            iBand == poDS->nAlphaIndex + 1 &&
+            psImage->comps[(poDS->nAlphaIndex==0 && poDS->nBands > 1) ? 1 : 0].prec == 8 &&
+            psImage->comps[poDS->nAlphaIndex ].prec == 1 &&
+            CPLFetchBool(
+                poOpenInfo->papszOpenOptions, "1BIT_ALPHA_PROMOTION",
+                CPLTestBool(CPLGetConfigOption("JP2OPENJPEG_PROMOTE_1BIT_ALPHA_AS_8BIT", "YES")));
+        if( bPromoteTo8Bit )
+            CPLDebug("JP2OpenJPEG", "Alpha band is promoted from 1 bit to 8 bit");
+
+        JP2OpenJPEGRasterBand* poBand =
+            new JP2OpenJPEGRasterBand( poDS, iBand, eDataType,
+                                        bPromoteTo8Bit ? 8: psImage->comps[iBand-1].prec,
+                                        bPromoteTo8Bit,
+                                        nBlockXSize, nBlockYSize);
+        if( iBand == 1 && poCT != nullptr )
+            poBand->poCT = poCT;
+        poDS->SetBand( iBand, poBand );
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Create overview datasets.                                       */
+/* -------------------------------------------------------------------- */
+    int nW = poDS->nRasterXSize;
+    int nH = poDS->nRasterYSize;
+    poDS->nParentXSize = poDS->nRasterXSize;
+    poDS->nParentYSize = poDS->nRasterYSize;
+
+    /* Lower resolutions are not compatible with a color-table */
+    if( poCT != nullptr )
+        numResolutions = 0;
+
+#if IS_OPENJPEG_OR_LATER(2,3,0)
+    if( poDS->bSingleTiled && poDS->bUseSetDecodeArea )
+    {
+        poDS->m_ppCodec = new opj_codec_t* (pCodec);
+        poDS->m_ppStream = new opj_stream_t* (pStream);
+        poDS->m_ppsImage = new opj_image_t* (psImage);
+        poDS->m_psJP2OpenJPEGFile = psJP2OpenJPEGFile;
+    }
+    poDS->m_pnLastLevel = new int(-1);
+#endif
+
+    while (poDS->nOverviewCount+1 < numResolutions &&
+           (nW > 128 || nH > 128) &&
+           (poDS->bUseSetDecodeArea || ((nTileW % 2) == 0 && (nTileH % 2) == 0)))
+    {
+        // This must be this exact formula per the JPEG2000 standard
+        nW = (nW + 1) / 2;
+        nH = (nH + 1) / 2;
+
+        poDS->papoOverviewDS = (JP2OpenJPEGDataset**) CPLRealloc(
+                    poDS->papoOverviewDS,
+                    (poDS->nOverviewCount + 1) * sizeof(JP2OpenJPEGDataset*));
+        JP2OpenJPEGDataset* poODS = new JP2OpenJPEGDataset();
+        poODS->m_osFilename = poDS->m_osFilename;
+        poODS->nParentXSize = poDS->nRasterXSize;
+        poODS->nParentYSize = poDS->nRasterYSize;
+        poODS->SetDescription( poOpenInfo->pszFilename );
+        poODS->iLevel = poDS->nOverviewCount + 1;
+        poODS->bSingleTiled = poDS->bSingleTiled;
+        poODS->bUseSetDecodeArea = poDS->bUseSetDecodeArea;
+        poODS->nRedIndex = poDS->nRedIndex;
+        poODS->nGreenIndex = poDS->nGreenIndex;
+        poODS->nBlueIndex = poDS->nBlueIndex;
+        poODS->nAlphaIndex = poDS->nAlphaIndex;
+        if (!poDS->bUseSetDecodeArea)
+        {
+            nTileW /= 2;
+            nTileH /= 2;
+            nBlockXSize = (int)nTileW;
+            nBlockYSize = (int)nTileH;
+        }
+        else
+        {
+            nBlockXSize = std::min(nW, (int)nTileW);
+            nBlockYSize = std::min(nH, (int)nTileH);
+        }
+
+        poODS->eColorSpace = poDS->eColorSpace;
+        poODS->nRasterXSize = nW;
+        poODS->nRasterYSize = nH;
+        poODS->nBands = poDS->nBands;
+        poODS->fp = poDS->fp;
+        poODS->nCodeStreamStart = nCodeStreamStart;
+        poODS->nCodeStreamLength = nCodeStreamLength;
+        poODS->bIs420 = bIs420;
+
+#if IS_OPENJPEG_OR_LATER(2,3,0)
+        if( poODS->bSingleTiled && poODS->bUseSetDecodeArea )
+        {
+            poODS->m_ppCodec = poDS->m_ppCodec;
+            poODS->m_ppStream = poDS->m_ppStream;
+            poODS->m_ppsImage = poDS->m_ppsImage;
+            poODS->m_psJP2OpenJPEGFile = poDS->m_psJP2OpenJPEGFile;
+        }
+        poODS->m_pnLastLevel = poDS->m_pnLastLevel;
+#endif
+
+#if IS_OPENJPEG_OR_LATER(2,5,0)
+        poODS->m_bStrict = poDS->m_bStrict;
+#endif
+
+        poODS->m_nX0 = poDS->m_nX0;
+        poODS->m_nY0 = poDS->m_nY0;
+
+        for( iBand = 1; iBand <= poDS->nBands; iBand++ )
+        {
+            const bool bPromoteTo8Bit =
+                iBand == poDS->nAlphaIndex + 1 &&
+                psImage->comps[(poDS->nAlphaIndex==0 && poDS->nBands > 1) ? 1 : 0].prec == 8 &&
+                psImage->comps[poDS->nAlphaIndex].prec == 1 &&
+                CPLFetchBool(
+                    poOpenInfo->papszOpenOptions, "1BIT_ALPHA_PROMOTION",
+                    CPLTestBool(CPLGetConfigOption("JP2OPENJPEG_PROMOTE_1BIT_ALPHA_AS_8BIT", "YES")));
+
+            poODS->SetBand( iBand, new JP2OpenJPEGRasterBand( poODS, iBand, eDataType,
+                                                              bPromoteTo8Bit ? 8: psImage->comps[iBand-1].prec,
+                                                              bPromoteTo8Bit,
+                                                              nBlockXSize, nBlockYSize ) );
+        }
+
+        poDS->papoOverviewDS[poDS->nOverviewCount ++] = poODS;
+    }
+
+#if IS_OPENJPEG_OR_LATER(2,3,0)
+    if( poDS->bSingleTiled && poDS->bUseSetDecodeArea )
+    {
+        // nothing
+    }
+    else
+#endif
+    {
+        opj_destroy_codec(pCodec);
+        opj_stream_destroy(pStream);
+        opj_image_destroy(psImage);
+        CPLFree(psJP2OpenJPEGFile);
+        pCodec = nullptr;
+        pStream = nullptr;
+        psImage = nullptr;
+    }
+
+/* -------------------------------------------------------------------- */
+/*      More metadata.                                                  */
+/* -------------------------------------------------------------------- */
+    if( poDS->nBands > 1 )
+    {
+        poDS->GDALDataset::SetMetadataItem( "INTERLEAVE", "PIXEL", "IMAGE_STRUCTURE" );
+    }
+
+    poOpenInfo->fpL = poDS->fp;
+    vsi_l_offset nCurOffset = VSIFTellL(poDS->fp);
+    poDS->LoadJP2Metadata(poOpenInfo);
+    VSIFSeekL(poDS->fp, nCurOffset, SEEK_SET);
+    poOpenInfo->fpL = nullptr;
+
+    poDS->bHasGeoreferencingAtOpening =
+        (!poDS->m_oSRS.IsEmpty()||
+         poDS->nGCPCount != 0 || poDS->bGeoTransformValid);
+
+/* -------------------------------------------------------------------- */
+/*      Vector layers                                                   */
+/* -------------------------------------------------------------------- */
+    if( poOpenInfo->nOpenFlags & GDAL_OF_VECTOR )
+    {
+        poDS->LoadVectorLayers(
+            CPLFetchBool(poOpenInfo->papszOpenOptions,
+                         "OPEN_REMOTE_GML", false));
+
+        // If file opened in vector-only mode and there's no vector,
+        // return
+        if( (poOpenInfo->nOpenFlags & GDAL_OF_RASTER) == 0 &&
+            poDS->GetLayerCount() == 0 )
+        {
+            delete poDS;
+            return nullptr;
+        }
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Initialize any PAM information.                                 */
+/* -------------------------------------------------------------------- */
+    poDS->SetDescription( poOpenInfo->pszFilename );
+    poDS->TryLoadXML();
+
+/* -------------------------------------------------------------------- */
+/*      Check for overviews.                                            */
+/* -------------------------------------------------------------------- */
+    poDS->oOvManager.Initialize( poDS, poOpenInfo->pszFilename );
+
+    return poDS;
+}
+
+/************************************************************************/
+/*                           WriteBox()                                 */
+/************************************************************************/
+
+void JP2OpenJPEGDataset::WriteBox(VSILFILE* fp, GDALJP2Box* poBox)
+{
+    GUInt32   nLBox;
+    GUInt32   nTBox;
+
+    if( poBox == nullptr )
+        return;
+
+    nLBox = (int) poBox->GetDataLength() + 8;
+    nLBox = CPL_MSBWORD32( nLBox );
+
+    memcpy(&nTBox, poBox->GetType(), 4);
+
+    VSIFWriteL( &nLBox, 4, 1, fp );
+    VSIFWriteL( &nTBox, 4, 1, fp );
+    VSIFWriteL(poBox->GetWritableData(), 1, (int) poBox->GetDataLength(), fp);
+}
+
+/************************************************************************/
+/*                         WriteGDALMetadataBox()                       */
+/************************************************************************/
+
+void JP2OpenJPEGDataset::WriteGDALMetadataBox( VSILFILE* fp,
+                                               GDALDataset* poSrcDS,
+                                               char** papszOptions )
+{
+    GDALJP2Box* poBox = GDALJP2Metadata::CreateGDALMultiDomainMetadataXMLBox(
+        poSrcDS, CPLFetchBool(papszOptions, "MAIN_MD_DOMAIN_ONLY", false));
+    if( poBox )
+        WriteBox(fp, poBox);
+    delete poBox;
+}
+
+/************************************************************************/
+/*                         WriteXMLBoxes()                              */
+/************************************************************************/
+
+void JP2OpenJPEGDataset::WriteXMLBoxes( VSILFILE* fp, GDALDataset* poSrcDS,
+                                         CPL_UNUSED char** papszOptions )
+{
+    int nBoxes = 0;
+    GDALJP2Box** papoBoxes = GDALJP2Metadata::CreateXMLBoxes(poSrcDS, &nBoxes);
+    for(int i=0;i<nBoxes;i++)
+    {
+        WriteBox(fp, papoBoxes[i]);
+        delete papoBoxes[i];
+    }
+    CPLFree(papoBoxes);
+}
+
+/************************************************************************/
+/*                           WriteXMPBox()                              */
+/************************************************************************/
+
+void JP2OpenJPEGDataset::WriteXMPBox ( VSILFILE* fp, GDALDataset* poSrcDS,
+                                       CPL_UNUSED char** papszOptions )
+{
+    GDALJP2Box* poBox = GDALJP2Metadata::CreateXMPBox(poSrcDS);
+    if( poBox )
+        WriteBox(fp, poBox);
+    delete poBox;
+}
+
+/************************************************************************/
+/*                           WriteIPRBox()                              */
+/************************************************************************/
+
+void JP2OpenJPEGDataset::WriteIPRBox ( VSILFILE* fp, GDALDataset* poSrcDS,
+                                       CPL_UNUSED char** papszOptions )
+{
+    GDALJP2Box* poBox = GDALJP2Metadata::CreateIPRBox(poSrcDS);
+    if( poBox )
+        WriteBox(fp, poBox);
+    delete poBox;
+}
+/************************************************************************/
+/*                         FloorPowerOfTwo()                            */
+/************************************************************************/
+
+static int FloorPowerOfTwo(int nVal)
+{
+    int nBits = 0;
+    while( nVal > 1 )
+    {
+        nBits ++;
+        nVal >>= 1;
+    }
+    return 1 << nBits;
+}
+
+/************************************************************************/
+/*                          CreateCopy()                                */
+/************************************************************************/
+
+GDALDataset * JP2OpenJPEGDataset::CreateCopy( const char * pszFilename,
+                                           GDALDataset *poSrcDS,
+                                           CPL_UNUSED int bStrict, char ** papszOptions,
+                                           GDALProgressFunc pfnProgress,
+                                           void * pProgressData )
+
+{
+    int  nBands = poSrcDS->GetRasterCount();
+    int  nXSize = poSrcDS->GetRasterXSize();
+    int  nYSize = poSrcDS->GetRasterYSize();
+
+    if( nBands == 0 || nBands > 16384 )
+    {
+        CPLError( CE_Failure, CPLE_NotSupported,
+                  "Unable to export files with %d bands. Must be >= 1 and <= 16384", nBands );
+        return nullptr;
+    }
+
+    GDALColorTable* poCT = poSrcDS->GetRasterBand(1)->GetColorTable();
+    if (poCT != nullptr && nBands != 1)
+    {
+        CPLError( CE_Failure, CPLE_NotSupported,
+                  "JP2OpenJPEG driver only supports a color table for a single-band dataset");
+        return nullptr;
+    }
+
+    GDALDataType eDataType = poSrcDS->GetRasterBand(1)->GetRasterDataType();
+    int nDataTypeSize = (GDALGetDataTypeSize(eDataType) / 8);
+    if (eDataType != GDT_Byte && eDataType != GDT_Int16 && eDataType != GDT_UInt16
+        && eDataType != GDT_Int32 && eDataType != GDT_UInt32)
+    {
+        CPLError( CE_Failure, CPLE_NotSupported,
+                  "JP2OpenJPEG driver only supports creating Byte, GDT_Int16, GDT_UInt16, GDT_Int32, GDT_UInt32");
+        return nullptr;
+    }
+
+    const bool bInspireTG = CPLFetchBool(papszOptions, "INSPIRE_TG", false);
+
+/* -------------------------------------------------------------------- */
+/*      Analyze creation options.                                       */
+/* -------------------------------------------------------------------- */
+    OPJ_CODEC_FORMAT eCodecFormat = OPJ_CODEC_J2K;
+    const char* pszCodec = CSLFetchNameValueDef(papszOptions, "CODEC", nullptr);
+    if (pszCodec)
+    {
+        if (EQUAL(pszCodec, "JP2"))
+            eCodecFormat = OPJ_CODEC_JP2;
+        else if (EQUAL(pszCodec, "J2K"))
+            eCodecFormat = OPJ_CODEC_J2K;
+        else
+        {
+            CPLError(CE_Warning, CPLE_NotSupported,
+                    "Unsupported value for CODEC : %s. Defaulting to J2K",
+                    pszCodec);
+        }
+    }
+    else
+    {
+        if (strlen(pszFilename) > 4 &&
+            EQUAL(pszFilename + strlen(pszFilename) - 4, ".JP2"))
+        {
+            eCodecFormat = OPJ_CODEC_JP2;
+        }
+    }
+    if( eCodecFormat != OPJ_CODEC_JP2 && bInspireTG )
+    {
+        CPLError(CE_Warning, CPLE_NotSupported,
+                  "INSPIRE_TG=YES mandates CODEC=JP2 (TG requirement 21)");
+        return nullptr;
+    }
+
+    // NOTE: if changing the default block size, the logic in nitfdataset.cpp
+    // CreateCopy() will have to be changed as well.
+    int nBlockXSize =
+        atoi(CSLFetchNameValueDef(papszOptions, "BLOCKXSIZE", "1024"));
+    int nBlockYSize =
+        atoi(CSLFetchNameValueDef(papszOptions, "BLOCKYSIZE", "1024"));
+    if (nBlockXSize <= 0 || nBlockYSize <= 0)
+    {
+        CPLError(CE_Failure, CPLE_NotSupported, "Invalid block size");
+        return nullptr;
+    }
+
+    // By default do not generate tile sizes larger than the dataset
+    // dimensions
+    if( !CPLFetchBool(papszOptions, "BLOCKSIZE_STRICT", false) &&
+        !CPLFetchBool(papszOptions, "@BLOCKSIZE_STRICT", false) )
+    {
+        if (nBlockXSize < 32 || nBlockYSize < 32)
+        {
+            CPLError(CE_Failure, CPLE_NotSupported, "Invalid block size");
+            return nullptr;
+        }
+
+        if (nXSize < nBlockXSize)
+        {
+            CPLDebug("OPENJPEG", "Adjusting block width from %d to %d",
+                     nBlockXSize, nXSize);
+            nBlockXSize = nXSize;
+        }
+        if (nYSize < nBlockYSize)
+        {
+            CPLDebug("OPENJPEG", "Adjusting block width from %d to %d",
+                     nBlockYSize, nYSize);
+            nBlockYSize = nYSize;
+        }
+    }
+
+    OPJ_PROG_ORDER eProgOrder = OPJ_LRCP;
+    const char* pszPROGORDER =
+            CSLFetchNameValueDef(papszOptions, "PROGRESSION", "LRCP");
+    if (EQUAL(pszPROGORDER, "LRCP"))
+        eProgOrder = OPJ_LRCP;
+    else if (EQUAL(pszPROGORDER, "RLCP"))
+        eProgOrder = OPJ_RLCP;
+    else if (EQUAL(pszPROGORDER, "RPCL"))
+        eProgOrder = OPJ_RPCL;
+    else if (EQUAL(pszPROGORDER, "PCRL"))
+        eProgOrder = OPJ_PCRL;
+    else if (EQUAL(pszPROGORDER, "CPRL"))
+        eProgOrder = OPJ_CPRL;
+    else
+    {
+        CPLError(CE_Warning, CPLE_NotSupported,
+                 "Unsupported value for PROGRESSION : %s. Defaulting to LRCP",
+                 pszPROGORDER);
+    }
+
+    const bool bIsIrreversible =
+        !CPLFetchBool(papszOptions, "REVERSIBLE", poCT != nullptr);
+
+    std::vector<double> adfRates;
+    const char* pszQuality = CSLFetchNameValueDef(papszOptions, "QUALITY", nullptr);
+    double dfDefaultQuality = ( poCT != nullptr ) ? 100.0 : 25.0;
+    if (pszQuality)
+    {
+        char **papszTokens = CSLTokenizeStringComplex( pszQuality, ",", FALSE, FALSE );
+        for(int i=0; papszTokens[i] != nullptr; i++ )
+        {
+            double dfQuality = CPLAtof(papszTokens[i]);
+            if (dfQuality > 0 && dfQuality <= 100)
+            {
+                double dfRate = 100 / dfQuality;
+                adfRates.push_back(dfRate);
+            }
+            else
+            {
+                CPLError(CE_Warning, CPLE_NotSupported,
+                         "Unsupported value for QUALITY: %s. Defaulting to single-layer, with quality=%.0f",
+                         papszTokens[i], dfDefaultQuality);
+                adfRates.resize(0);
+                break;
+            }
+        }
+        if( papszTokens[0] == nullptr )
+        {
+            CPLError(CE_Warning, CPLE_NotSupported,
+                     "Unsupported value for QUALITY: %s. Defaulting to single-layer, with quality=%.0f",
+                     pszQuality, dfDefaultQuality);
+        }
+        CSLDestroy(papszTokens);
+    }
+    if( adfRates.empty() )
+    {
+        adfRates.push_back(100. / dfDefaultQuality);
+        assert(!adfRates.empty());
+    }
+
+    if( poCT != nullptr && (bIsIrreversible || adfRates.back() != 1.0) )
+    {
+        CPLError(CE_Warning, CPLE_AppDefined,
+                 "Encoding a dataset with a color table with REVERSIBLE != YES "
+                 "or QUALITY != 100 will likely lead to bad visual results");
+    }
+
+    const int nMaxTileDim = std::max(nBlockXSize, nBlockYSize);
+    int nNumResolutions = 1;
+    /* Pickup a reasonable value compatible with PROFILE_1 requirements */
+    while( (nMaxTileDim >> (nNumResolutions-1)) > 128 )
+        nNumResolutions ++;
+    int nMinProfile1Resolutions = nNumResolutions;
+    const char* pszResolutions = CSLFetchNameValueDef(papszOptions, "RESOLUTIONS", nullptr);
+    if (pszResolutions)
+    {
+        nNumResolutions = atoi(pszResolutions);
+        if (nNumResolutions <= 0 || nNumResolutions >= 32 ||
+            (nMaxTileDim >> nNumResolutions) == 0 )
+        {
+            CPLError(CE_Warning, CPLE_NotSupported,
+                 "Unsupported value for RESOLUTIONS : %s. Defaulting to %d",
+                 pszResolutions, nMinProfile1Resolutions);
+            nNumResolutions = nMinProfile1Resolutions;
+        }
+    }
+
+    int bSOP = CPLTestBool(CSLFetchNameValueDef(papszOptions, "SOP", "FALSE"));
+    int bEPH = CPLTestBool(CSLFetchNameValueDef(papszOptions, "EPH", "FALSE"));
+
+    int nRedBandIndex = -1;
+    int nGreenBandIndex = -1;
+    int nBlueBandIndex = -1;
+    int nAlphaBandIndex = -1;
+    for(int i=0;i<nBands;i++)
+    {
+        GDALColorInterp eInterp = poSrcDS->GetRasterBand(i+1)->GetColorInterpretation();
+        if( eInterp == GCI_RedBand )
+            nRedBandIndex = i;
+        else if( eInterp == GCI_GreenBand )
+            nGreenBandIndex = i;
+        else if( eInterp == GCI_BlueBand )
+            nBlueBandIndex = i;
+        else if( eInterp == GCI_AlphaBand )
+            nAlphaBandIndex = i;
+    }
+    const char* pszAlpha = CSLFetchNameValue(papszOptions, "ALPHA");
+    if( nAlphaBandIndex < 0 && nBands > 1 && pszAlpha != nullptr && CPLTestBool(pszAlpha) )
+    {
+        nAlphaBandIndex = nBands - 1;
+    }
+
+    const char* pszYCBCR420 = CSLFetchNameValue(papszOptions, "YCBCR420");
+    int bYCBCR420 = FALSE;
+    if( pszYCBCR420 && CPLTestBool(pszYCBCR420) )
+    {
+        if ((nBands == 3 || nBands == 4) && eDataType == GDT_Byte &&
+            nRedBandIndex == 0 && nGreenBandIndex == 1 && nBlueBandIndex == 2)
+        {
+            if( ((nXSize % 2) == 0 && (nYSize % 2) == 0 && (nBlockXSize % 2) == 0 && (nBlockYSize % 2) == 0) )
+            {
+                bYCBCR420 = TRUE;
+            }
+            else
+            {
+                CPLError(CE_Warning, CPLE_NotSupported,
+                    "YCBCR420 unsupported when image size and/or tile size are not multiple of 2");
+            }
+        }
+        else
+        {
+            CPLError(CE_Warning, CPLE_NotSupported,
+                    "YCBCR420 unsupported with this image band count and/or data byte");
+        }
+    }
+
+    const char* pszYCC = CSLFetchNameValue(papszOptions, "YCC");
+    int bYCC = ((nBands == 3 || nBands == 4) &&
+            CPLTestBool(CSLFetchNameValueDef(papszOptions, "YCC", "TRUE")));
+
+#if !(IS_OPENJPEG_OR_LATER(2,2,0))
+    /* Depending on the way OpenJPEG <= r2950 is built, YCC with 4 bands might work on
+     * Debug mode, but this relies on unreliable stack buffer overflows, so
+     * better err on the safe side */
+    if( bYCC && nBands > 3 )
+    {
+        if( pszYCC != nullptr )
+        {
+            CPLError(CE_Warning, CPLE_AppDefined,
+                     "OpenJPEG r2950 and below can generate invalid output with "
+                     "MCT YCC transform and more than 3 bands. Disabling YCC");
+        }
+        bYCC = FALSE;
+    }
+#endif
+
+    if( bYCBCR420 && bYCC )
+    {
+        if( pszYCC != nullptr )
+        {
+            CPLError(CE_Warning, CPLE_NotSupported,
+                    "YCC unsupported when YCbCr requesting");
+        }
+        bYCC = FALSE;
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Deal with codeblocks size                                       */
+/* -------------------------------------------------------------------- */
+
+    int nCblockW = atoi(CSLFetchNameValueDef( papszOptions, "CODEBLOCK_WIDTH", "64" ));
+    int nCblockH = atoi(CSLFetchNameValueDef( papszOptions, "CODEBLOCK_HEIGHT", "64" ));
+    if( nCblockW < 4 || nCblockW > 1024 || nCblockH < 4 || nCblockH > 1024 )
+    {
+        CPLError(CE_Warning, CPLE_NotSupported,
+                 "Invalid values for codeblock size. Defaulting to 64x64");
+        nCblockW = 64;
+        nCblockH = 64;
+    }
+    else if( nCblockW * nCblockH > 4096 )
+    {
+        CPLError(CE_Warning, CPLE_NotSupported,
+                 "Invalid values for codeblock size. "
+                 "CODEBLOCK_WIDTH * CODEBLOCK_HEIGHT should be <= 4096. "
+                 "Defaulting to 64x64");
+        nCblockW = 64;
+        nCblockH = 64;
+    }
+    int nCblockW_po2 = FloorPowerOfTwo(nCblockW);
+    int nCblockH_po2 = FloorPowerOfTwo(nCblockH);
+    if( nCblockW_po2 != nCblockW || nCblockH_po2 != nCblockH )
+    {
+        CPLError(CE_Warning, CPLE_NotSupported,
+                 "Non power of two values used for codeblock size. "
+                 "Using to %dx%d",
+                 nCblockW_po2, nCblockH_po2);
+    }
+    nCblockW = nCblockW_po2;
+    nCblockH = nCblockH_po2;
+
+/* -------------------------------------------------------------------- */
+/*      Deal with codestream PROFILE                                    */
+/* -------------------------------------------------------------------- */
+    const char* pszProfile = CSLFetchNameValueDef( papszOptions, "PROFILE", "AUTO" );
+    int bProfile1 = FALSE;
+    if( EQUAL(pszProfile, "UNRESTRICTED") )
+    {
+        bProfile1 = FALSE;
+        if( bInspireTG )
+        {
+            CPLError(CE_Failure, CPLE_NotSupported,
+                    "INSPIRE_TG=YES mandates PROFILE=PROFILE_1 (TG requirement 21)");
+            return nullptr;
+        }
+    }
+    else if( EQUAL(pszProfile, "UNRESTRICTED_FORCED") )
+    {
+        bProfile1 = FALSE;
+    }
+    else if( EQUAL(pszProfile, "PROFILE_1_FORCED") ) /* For debug only: can produce inconsistent codestream */
+    {
+        bProfile1 = TRUE;
+    }
+    else
+    {
+        if( !(EQUAL(pszProfile, "PROFILE_1") || EQUAL(pszProfile, "AUTO")) )
+        {
+            CPLError(CE_Warning, CPLE_NotSupported,
+                     "Unsupported value for PROFILE : %s. Defaulting to AUTO",
+                     pszProfile);
+            pszProfile = "AUTO";
+        }
+
+        bProfile1 = TRUE;
+        const char* pszReq21OrEmpty = bInspireTG ? " (TG requirement 21)" : "";
+        if( (nBlockXSize != nXSize || nBlockYSize != nYSize) &&
+            (nBlockXSize != nBlockYSize || nBlockXSize > 1024 || nBlockYSize > 1024 ) )
+        {
+            bProfile1 = FALSE;
+            if( bInspireTG || EQUAL(pszProfile, "PROFILE_1") )
+            {
+                CPLError(CE_Failure, CPLE_NotSupported,
+                         "Tile dimensions incompatible with PROFILE_1%s. "
+                         "Should be whole image or square with dimension <= 1024.",
+                         pszReq21OrEmpty);
+                return nullptr;
+            }
+        }
+        if( (nMaxTileDim >> (nNumResolutions-1)) > 128 )
+        {
+            bProfile1 = FALSE;
+            if( bInspireTG || EQUAL(pszProfile, "PROFILE_1") )
+            {
+                CPLError(CE_Failure, CPLE_NotSupported,
+                         "Number of resolutions incompatible with PROFILE_1%s. "
+                         "Should be at least %d.",
+                         pszReq21OrEmpty,
+                         nMinProfile1Resolutions);
+                return nullptr;
+            }
+        }
+        if( nCblockW > 64 || nCblockH > 64 )
+        {
+            bProfile1 = FALSE;
+            if( bInspireTG || EQUAL(pszProfile, "PROFILE_1") )
+            {
+                CPLError(CE_Failure, CPLE_NotSupported,
+                         "Codeblock width incompatible with PROFILE_1%s. "
+                         "Codeblock width or height should be <= 64.",
+                         pszReq21OrEmpty);
+                return nullptr;
+            }
+        }
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Work out the precision.                                         */
+/* -------------------------------------------------------------------- */
+    int nBits;
+    if( CSLFetchNameValue( papszOptions, "NBITS" ) != nullptr )
+    {
+        nBits = atoi(CSLFetchNameValue(papszOptions,"NBITS"));
+        if( bInspireTG &&
+            !(nBits == 1 || nBits == 8 || nBits == 16 || nBits == 32) )
+        {
+            CPLError(CE_Failure, CPLE_NotSupported,
+                    "INSPIRE_TG=YES mandates NBITS=1,8,16 or 32 (TG requirement 24)");
+            return nullptr;
+        }
+    }
+    else if( poSrcDS->GetRasterBand(1)->GetMetadataItem( "NBITS", "IMAGE_STRUCTURE" )
+             != nullptr )
+    {
+        nBits = atoi(poSrcDS->GetRasterBand(1)->GetMetadataItem( "NBITS",
+                                                       "IMAGE_STRUCTURE" ));
+        if( bInspireTG &&
+            !(nBits == 1 || nBits == 8 || nBits == 16 || nBits == 32) )
+        {
+            /* Implements "NOTE If the original data do not satisfy this "
+               "requirement, they will be converted in a representation using "
+               "the next higher power of 2" */
+            nBits = GDALGetDataTypeSize(eDataType);
+        }
+    }
+    else
+    {
+        nBits = GDALGetDataTypeSize(eDataType);
+    }
+
+    if( (GDALGetDataTypeSize(eDataType) == 8 && nBits > 8) ||
+        (GDALGetDataTypeSize(eDataType) == 16 && (nBits <= 8 || nBits > 16)) ||
+        (GDALGetDataTypeSize(eDataType) == 32 && (nBits <= 16 || nBits > 32)) )
+    {
+        CPLError(CE_Warning, CPLE_NotSupported,
+                 "Inconsistent NBITS value with data type. Using %d",
+                 GDALGetDataTypeSize(eDataType));
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Georeferencing options                                          */
+/* -------------------------------------------------------------------- */
+
+    bool bGMLJP2Option = CPLFetchBool( papszOptions, "GMLJP2", true );
+    int nGMLJP2Version = 1;
+    const char* pszGMLJP2V2Def = CSLFetchNameValue( papszOptions, "GMLJP2V2_DEF" );
+    if( pszGMLJP2V2Def != nullptr )
+    {
+        bGMLJP2Option = true;
+        nGMLJP2Version = 2;
+        if( bInspireTG )
+        {
+            CPLError(CE_Warning, CPLE_NotSupported,
+                    "INSPIRE_TG=YES is only compatible with GMLJP2 v1");
+            return nullptr;
+        }
+    }
+    const bool bGeoJP2Option = CPLFetchBool( papszOptions, "GeoJP2", true );
+
+    GDALJP2Metadata oJP2MD;
+
+    int bGeoreferencingCompatOfGeoJP2 = FALSE;
+    int bGeoreferencingCompatOfGMLJP2 = FALSE;
+    if( eCodecFormat == OPJ_CODEC_JP2 && (bGMLJP2Option || bGeoJP2Option) )
+    {
+        if( poSrcDS->GetGCPCount() > 0 )
+        {
+            bGeoreferencingCompatOfGeoJP2 = TRUE;
+            oJP2MD.SetGCPs( poSrcDS->GetGCPCount(),
+                            poSrcDS->GetGCPs() );
+            oJP2MD.SetSpatialRef( poSrcDS->GetGCPSpatialRef() );
+        }
+        else
+        {
+            const OGRSpatialReference* poSRS = poSrcDS->GetSpatialRef();
+            if( poSRS != nullptr )
+            {
+                bGeoreferencingCompatOfGeoJP2 = TRUE;
+                oJP2MD.SetSpatialRef( poSRS );
+            }
+            double adfGeoTransform[6];
+            if( poSrcDS->GetGeoTransform( adfGeoTransform ) == CE_None )
+            {
+                bGeoreferencingCompatOfGeoJP2 = TRUE;
+                oJP2MD.SetGeoTransform( adfGeoTransform );
+            }
+            bGeoreferencingCompatOfGMLJP2 =
+                          poSRS != nullptr && !poSRS->IsEmpty() &&
+                          poSrcDS->GetGeoTransform( adfGeoTransform ) == CE_None;
+        }
+        if( poSrcDS->GetMetadata("RPC") != nullptr )
+        {
+            oJP2MD.SetRPCMD(  poSrcDS->GetMetadata("RPC") );
+            bGeoreferencingCompatOfGeoJP2 = TRUE;
+        }
+
+        const char* pszAreaOrPoint = poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT);
+        oJP2MD.bPixelIsPoint = pszAreaOrPoint != nullptr && EQUAL(pszAreaOrPoint, GDALMD_AOP_POINT);
+
+        if( bGMLJP2Option && CPLGetConfigOption("GMLJP2OVERRIDE", nullptr) != nullptr )
+        {
+            // Force V1 since this is the branch in which the hack is
+            // implemented
+            nGMLJP2Version = 1;
+            bGeoreferencingCompatOfGMLJP2 = TRUE;
+        }
+    }
+
+    if( CSLFetchNameValue( papszOptions, "GMLJP2" ) != nullptr && bGMLJP2Option &&
+        !bGeoreferencingCompatOfGMLJP2 )
+    {
+        CPLError(CE_Warning, CPLE_AppDefined,
+                 "GMLJP2 box was explicitly required but cannot be written due "
+                 "to lack of georeferencing and/or unsupported georeferencing for GMLJP2");
+    }
+
+    if( CSLFetchNameValue( papszOptions, "GeoJP2" ) != nullptr && bGeoJP2Option &&
+        !bGeoreferencingCompatOfGeoJP2 )
+    {
+        CPLError(CE_Warning, CPLE_AppDefined,
+                 "GeoJP2 box was explicitly required but cannot be written due "
+                 "to lack of georeferencing");
+    }
+    const bool bGeoBoxesAfter =
+        CPLFetchBool(papszOptions, "GEOBOXES_AFTER_JP2C", bInspireTG);
+    GDALJP2Box* poGMLJP2Box = nullptr;
+    if( eCodecFormat == OPJ_CODEC_JP2 && bGMLJP2Option && bGeoreferencingCompatOfGMLJP2 )
+    {
+        if( nGMLJP2Version == 1)
+            poGMLJP2Box = oJP2MD.CreateGMLJP2(nXSize,nYSize);
+        else
+            poGMLJP2Box = oJP2MD.CreateGMLJP2V2(nXSize,nYSize,pszGMLJP2V2Def,poSrcDS);
+        if( poGMLJP2Box == nullptr )
+            return nullptr;
+    }
+
+    /* ---------------------------------------------------------------- */
+    /* If the input driver is identifed as "GEORASTER" the following    */
+    /* section will try to dump a ORACLE GeoRaster JP2 BLOB into a file */
+    /* ---------------------------------------------------------------- */
+
+    if ( EQUAL( poSrcDS->GetDriverName(), "GEORASTER" ) )
+    {
+        const char* pszGEOR_compress = poSrcDS->GetMetadataItem("COMPRESSION",
+                                                "IMAGE_STRUCTURE");
+
+        if( pszGEOR_compress == nullptr )
+        {
+            pszGEOR_compress = "NONE";
+        }
+
+        /* Check if the JP2 BLOB needs re-shaping */
+
+        bool bGEOR_reshape = false;
+
+        const char* apszIgnoredOptions[] = {
+            "BLOCKXSIZE", "BLOCKYSIZE", "QUALITY", "REVERSIBLE",
+            "RESOLUTIONS", "PROGRESSION", "SOP", "EPH",
+            "YCBCR420", "YCC", "NBITS", "1BIT_ALPHA", "PRECINCTS",
+            "TILEPARTS", "CODEBLOCK_WIDTH", "CODEBLOCK_HEIGHT", "PLT", "TLM",
+            nullptr };
+
+        for( int i = 0; apszIgnoredOptions[i]; i ++)
+        {
+            if( CSLFetchNameValue(papszOptions, apszIgnoredOptions[i]) )
+            {
+                bGEOR_reshape = true;
+            }
+        }
+
+        if( CSLFetchNameValue( papszOptions, "USE_SRC_CODESTREAM" ) )
+        {
+            bGEOR_reshape = false;
+        }
+
+        char** papszGEOR_files = poSrcDS->GetFileList();
+
+        if( EQUAL( pszGEOR_compress, "JP2-F" ) &&
+            CSLCount( papszGEOR_files ) > 0 &&
+            bGEOR_reshape == false )
+        {
+
+            const char* pszVsiOciLob = papszGEOR_files[0];
+
+            VSILFILE *fpBlob = VSIFOpenL( pszVsiOciLob, "r" );
+            if( fpBlob == nullptr )
+            {
+                CPLError(CE_Failure, CPLE_AppDefined, "Cannot open %s",
+                         pszVsiOciLob);
+                delete poGMLJP2Box;
+                return nullptr;
+            }
+            VSILFILE* fp = VSIFOpenL( pszFilename, "w+b" );
+            if( fp == nullptr )
+            {
+                CPLError(CE_Failure, CPLE_AppDefined, "Cannot create %s",
+                         pszFilename);
+                delete poGMLJP2Box;
+                VSIFCloseL(fpBlob);
+                return nullptr;
+            }
+
+            VSIFSeekL( fpBlob, 0, SEEK_END );
+
+            size_t nBlobSize = static_cast<size_t>(VSIFTellL( fpBlob));
+            size_t nChunk = (size_t) ( GDALGetCacheMax() * 0.25 );
+            size_t nSize = 0;
+            size_t nCount = 0;
+
+            void *pBuffer = (GByte*) VSI_MALLOC_VERBOSE( nChunk );
+            if( pBuffer == nullptr )
+            {
+                delete poGMLJP2Box;
+                VSIFCloseL(fpBlob);
+                VSIFCloseL( fp );
+                return nullptr;
+            }
+
+            VSIFSeekL( fpBlob, 0, SEEK_SET );
+
+            while( ( nSize = VSIFReadL( pBuffer, 1, nChunk, fpBlob ) ) > 0 )
+            {
+                VSIFWriteL( pBuffer, 1, nSize, fp );
+                nCount += nSize;
+                pfnProgress( (float) nCount / (float) nBlobSize,
+                                 nullptr, pProgressData );
+            }
+
+            CPLFree( pBuffer );
+            VSIFCloseL( fpBlob );
+
+            VSIFCloseL( fp );
+
+            /* Return the GDALDaset object */
+
+            GDALOpenInfo oOpenInfo(pszFilename, GA_Update);
+            GDALDataset *poDS = JP2OpenJPEGDataset::Open(&oOpenInfo);
+
+            /* Copy essential metadata */
+
+            double adfGeoTransform[6];
+
+            if( poSrcDS->GetGeoTransform( adfGeoTransform ) == CE_None )
+            {
+                poDS->SetGeoTransform( adfGeoTransform );
+            }
+
+            const OGRSpatialReference* poSRS = poSrcDS->GetSpatialRef();
+            if( poSRS )
+            {
+                poDS->SetSpatialRef( poSRS );
+            }
+
+            delete poGMLJP2Box;
+            return poDS;
+        }
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Setup encoder                                                  */
+/* -------------------------------------------------------------------- */
+
+    opj_cparameters_t parameters;
+    opj_set_default_encoder_parameters(&parameters);
+    if (bSOP)
+        parameters.csty |= 0x02;
+    if (bEPH)
+        parameters.csty |= 0x04;
+    parameters.cp_disto_alloc = 1;
+    parameters.tcp_numlayers = (int)adfRates.size();
+    for(int i=0;i<(int)adfRates.size();i++)
+        parameters.tcp_rates[i] = (float) adfRates[i];
+    parameters.cp_tx0 = 0;
+    parameters.cp_ty0 = 0;
+    parameters.tile_size_on = TRUE;
+    parameters.cp_tdx = nBlockXSize;
+    parameters.cp_tdy = nBlockYSize;
+    parameters.irreversible = bIsIrreversible;
+    parameters.numresolution = nNumResolutions;
+    parameters.prog_order = eProgOrder;
+    parameters.tcp_mct = static_cast<char>(bYCC);
+    parameters.cblockw_init = nCblockW;
+    parameters.cblockh_init = nCblockH;
+    parameters.mode = 0;
+
+#if IS_OPENJPEG_OR_LATER(2,3,0)
+    // Was buggy before for some of the options
+    const char* pszCodeBlockStyle = CSLFetchNameValue(papszOptions, "CODEBLOCK_STYLE");
+    if( pszCodeBlockStyle )
+    {
+        if( CPLGetValueType(pszCodeBlockStyle) == CPL_VALUE_INTEGER )
+        {
+            int nVal = atoi(pszCodeBlockStyle);
+            if( nVal >= 0 && nVal <= 63 )
+            {
+                parameters.mode = nVal;
+            }
+            else
+            {
+                CPLError(CE_Warning, CPLE_NotSupported,
+                         "Invalid value for CODEBLOCK_STYLE: %s. "
+                         "Should be >= 0 and <= 63",
+                         pszCodeBlockStyle);
+            }
+        }
+        else
+        {
+            char** papszTokens = CSLTokenizeString2(pszCodeBlockStyle, ", ", 0);
+            for( char** papszIter = papszTokens;
+                        papszIter && *papszIter; ++papszIter )
+            {
+                if( EQUAL(*papszIter, "BYPASS") )
+                {
+                    parameters.mode |= (1 << 0);
+                }
+                else if( EQUAL(*papszIter, "RESET") )
+                {
+                    parameters.mode |= (1 << 1);
+                }
+                else if( EQUAL(*papszIter, "TERMALL") )
+                {
+                    parameters.mode |= (1 << 2);
+                }
+                else if( EQUAL(*papszIter, "VSC") )
+                {
+                    parameters.mode |= (1 << 3);
+                }
+                else if( EQUAL(*papszIter, "PREDICTABLE") )
+                {
+                    parameters.mode |= (1 << 4);
+                }
+                else if( EQUAL(*papszIter, "SEGSYM") )
+                {
+                    parameters.mode |= (1 << 5);
+                }
+                else
+                {
+                    CPLError(CE_Warning, CPLE_NotSupported,
+                             "Unrecognized option for CODEBLOCK_STYLE: %s",
+                             *papszIter);
+                }
+            }
+            CSLDestroy(papszTokens);
+        }
+    }
+#endif
+
+    /* Add precincts */
+    const char* pszPrecincts = CSLFetchNameValueDef(papszOptions, "PRECINCTS",
+        "{512,512},{256,512},{128,512},{64,512},{32,512},{16,512},{8,512},{4,512},{2,512}");
+    char **papszTokens = CSLTokenizeStringComplex( pszPrecincts, "{},", FALSE, FALSE );
+    int nPrecincts = CSLCount(papszTokens) / 2;
+    for(int i=0;i<nPrecincts && i < OPJ_J2K_MAXRLVLS;i++)
+    {
+        int nPCRW = atoi(papszTokens[2*i]);
+        int nPCRH = atoi(papszTokens[2*i+1]);
+        if( nPCRW < 1 || nPCRH < 1 )
+            break;
+        parameters.csty |= 0x01;
+        parameters.res_spec ++;
+        parameters.prcw_init[i] = nPCRW;
+        parameters.prch_init[i] = nPCRH;
+    }
+    CSLDestroy(papszTokens);
+
+    /* Add tileparts setting */
+    const char* pszTileParts = CSLFetchNameValueDef(papszOptions, "TILEPARTS", "DISABLED");
+    if( EQUAL(pszTileParts, "RESOLUTIONS") )
+    {
+        parameters.tp_on = 1;
+        parameters.tp_flag = 'R';
+    }
+    else if( EQUAL(pszTileParts, "LAYERS") )
+    {
+        if( parameters.tcp_numlayers == 1 )
+        {
+            CPLError(CE_Warning, CPLE_AppDefined,
+                     "TILEPARTS=LAYERS has no real interest with single-layer codestream");
+        }
+        parameters.tp_on = 1;
+        parameters.tp_flag = 'L';
+    }
+    else if( EQUAL(pszTileParts, "COMPONENTS") )
+    {
+        parameters.tp_on = 1;
+        parameters.tp_flag = 'C';
+    }
+    else if( !EQUAL(pszTileParts, "DISABLED") )
+    {
+        CPLError(CE_Warning, CPLE_NotSupported,
+                 "Invalid value for TILEPARTS");
+    }
+
+    if( bProfile1 )
+    {
+        parameters.rsiz = OPJ_PROFILE_1;
+    }
+
+    opj_image_cmptparm_t* pasBandParams =
+            (opj_image_cmptparm_t*)CPLMalloc(nBands * sizeof(opj_image_cmptparm_t));
+    int iBand;
+    int bSamePrecision = TRUE;
+    int b1BitAlpha = FALSE;
+    for(iBand=0;iBand<nBands;iBand++)
+    {
+        pasBandParams[iBand].x0 = 0;
+        pasBandParams[iBand].y0 = 0;
+        if (bYCBCR420 && (iBand == 1 || iBand == 2))
+        {
+            pasBandParams[iBand].dx = 2;
+            pasBandParams[iBand].dy = 2;
+            pasBandParams[iBand].w = nXSize / 2;
+            pasBandParams[iBand].h = nYSize / 2;
+        }
+        else
+        {
+            pasBandParams[iBand].dx = 1;
+            pasBandParams[iBand].dy = 1;
+            pasBandParams[iBand].w = nXSize;
+            pasBandParams[iBand].h = nYSize;
+        }
+
+        pasBandParams[iBand].sgnd = (eDataType == GDT_Int16 || eDataType == GDT_Int32);
+        pasBandParams[iBand].prec = nBits;
+
+        const char* pszNBits = poSrcDS->GetRasterBand(iBand+1)->GetMetadataItem(
+            "NBITS", "IMAGE_STRUCTURE");
+        /* Recommendation 38 In the case of an opacity channel, the bit depth should be 1-bit. */
+        if( iBand == nAlphaBandIndex &&
+            ((pszNBits != nullptr && EQUAL(pszNBits, "1")) ||
+              CPLFetchBool(papszOptions, "1BIT_ALPHA", bInspireTG)) )
+        {
+            if( iBand != nBands - 1 && nBits != 1 )
+            {
+                /* Might be a bug in openjpeg, but it seems that if the alpha */
+                /* band is the first one, it would select 1-bit for all channels... */
+                CPLError(CE_Warning, CPLE_NotSupported,
+                         "Cannot output 1-bit alpha channel if it is not the last one");
+            }
+            else
+            {
+                CPLDebug("OPENJPEG", "Using 1-bit alpha channel");
+                pasBandParams[iBand].sgnd = 0;
+                pasBandParams[iBand].prec = 1;
+                bSamePrecision = FALSE;
+                b1BitAlpha = TRUE;
+            }
+        }
+    }
+
+    if( bInspireTG && nAlphaBandIndex >= 0 && !b1BitAlpha )
+    {
+        CPLError(CE_Warning, CPLE_NotSupported,
+                  "INSPIRE_TG=YES recommends 1BIT_ALPHA=YES (Recommendation 38)");
+    }
+
+    /* Always ask OpenJPEG to do codestream only. We will take care */
+    /* of JP2 boxes */
+    opj_codec_t* pCodec = opj_create_compress(OPJ_CODEC_J2K);
+    if (pCodec == nullptr)
+    {
+        CPLError(CE_Failure, CPLE_AppDefined,
+                 "opj_create_compress() failed");
+        CPLFree(pasBandParams);
+        delete poGMLJP2Box;
+        return nullptr;
+    }
+
+    opj_set_info_handler(pCodec, JP2OpenJPEGDataset_InfoCallback,nullptr);
+    opj_set_warning_handler(pCodec, JP2OpenJPEGDataset_WarningCallback,nullptr);
+    opj_set_error_handler(pCodec, JP2OpenJPEGDataset_ErrorCallback,nullptr);
+
+    OPJ_COLOR_SPACE eColorSpace = OPJ_CLRSPC_GRAY;
+
+    if( bYCBCR420 )
+    {
+        eColorSpace = OPJ_CLRSPC_SYCC;
+    }
+    else if( (nBands == 3 || nBands == 4) &&
+             nRedBandIndex >= 0 && nGreenBandIndex >= 0 && nBlueBandIndex >= 0 )
+    {
+        eColorSpace = OPJ_CLRSPC_SRGB;
+    }
+    else if (poCT != nullptr)
+    {
+        eColorSpace = OPJ_CLRSPC_SRGB;
+    }
+
+    opj_image_t* psImage = opj_image_tile_create(nBands,pasBandParams,
+                                                 eColorSpace);
+
+    if (psImage == nullptr)
+    {
+        CPLError(CE_Failure, CPLE_AppDefined,
+                 "opj_image_tile_create() failed");
+        opj_destroy_codec(pCodec);
+        CPLFree(pasBandParams);
+        pasBandParams = nullptr;
+        delete poGMLJP2Box;
+        return nullptr;
+    }
+
+    psImage->x0 = 0;
+    psImage->y0 = 0;
+    psImage->x1 = nXSize;
+    psImage->y1 = nYSize;
+    psImage->color_space = eColorSpace;
+    psImage->numcomps = nBands;
+
+    if (!opj_setup_encoder(pCodec,&parameters,psImage))
+    {
+        CPLError(CE_Failure, CPLE_AppDefined,
+                 "opj_setup_encoder() failed");
+        opj_image_destroy(psImage);
+        opj_destroy_codec(pCodec);
+        CPLFree(pasBandParams);
+        pasBandParams = nullptr;
+        delete poGMLJP2Box;
+        return nullptr;
+    }
+
+#if IS_OPENJPEG_OR_LATER(2,4,0)
+
+    if( getenv("OPJ_NUM_THREADS") == nullptr )
+    {
+        JP2OpenJPEGDataset oTmpDS;
+        opj_codec_set_threads(pCodec, oTmpDS.GetNumThreads());
+    }
+
+    CPLStringList aosOptions;
+    if( CPLTestBool(CSLFetchNameValueDef(papszOptions, "PLT", "FALSE")) )
+    {
+        aosOptions.AddString("PLT=YES");
+    }
+
+#if IS_OPENJPEG_OR_LATER(2,5,0)
+    if( CPLTestBool(CSLFetchNameValueDef(papszOptions, "TLM", "FALSE")) )
+    {
+        aosOptions.AddString("TLM=YES");
+    }
+#endif
+
+    if( !opj_encoder_set_extra_options(pCodec, aosOptions.List()) )
+    {
+        CPLError(CE_Failure, CPLE_AppDefined,
+                "opj_encoder_set_extra_options() failed");
+        opj_image_destroy(psImage);
+        opj_destroy_codec(pCodec);
+        CPLFree(pasBandParams);
+        pasBandParams = nullptr;
+        delete poGMLJP2Box;
+        return nullptr;
+    }
+#endif
+
+/* -------------------------------------------------------------------- */
+/*      Create the dataset.                                             */
+/* -------------------------------------------------------------------- */
+
+    const char* pszAccess = STARTS_WITH_CI(pszFilename, "/vsisubfile/") ? "r+b" : "w+b";
+    VSILFILE* fp = VSIFOpenL(pszFilename, pszAccess);
+    if (fp == nullptr)
+    {
+        CPLError(CE_Failure, CPLE_AppDefined, "Cannot create file");
+        opj_image_destroy(psImage);
+        opj_destroy_codec(pCodec);
+        CPLFree(pasBandParams);
+        pasBandParams = nullptr;
+        delete poGMLJP2Box;
+        return nullptr;
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Add JP2 boxes.                                                  */
+/* -------------------------------------------------------------------- */
+    vsi_l_offset nStartJP2C = 0;
+    int bUseXLBoxes = FALSE;
+
+    if( eCodecFormat == OPJ_CODEC_JP2  )
+    {
+        GDALJP2Box jPBox(fp);
+        jPBox.SetType("jP  ");
+        jPBox.AppendWritableData(4, "\x0D\x0A\x87\x0A");
+        WriteBox(fp, &jPBox);
+
+        GDALJP2Box ftypBox(fp);
+        ftypBox.SetType("ftyp");
+        // http://docs.opengeospatial.org/is/08-085r5/08-085r5.html Req 19
+        const bool bJPXOption = CPLFetchBool( papszOptions, "JPX", true );
+        if( nGMLJP2Version == 2 && bJPXOption )
+            ftypBox.AppendWritableData(4, "jpx "); /* Branding */
+        else
+        ftypBox.AppendWritableData(4, "jp2 "); /* Branding */
+        ftypBox.AppendUInt32(0); /* minimum version */
+        ftypBox.AppendWritableData(4, "jp2 "); /* Compatibility list: first value */
+
+        if( bInspireTG && poGMLJP2Box != nullptr && !bJPXOption )
+        {
+            CPLError(CE_Warning, CPLE_AppDefined,
+                     "INSPIRE_TG=YES implies following GMLJP2 specification which "
+                     "recommends advertise reader requirement 67 feature, and thus JPX capability");
+        }
+        else if( poGMLJP2Box != nullptr && bJPXOption )
+        {
+            /* GMLJP2 uses lbl and asoc boxes, which are JPEG2000 Part II spec */
+            /* advertizing jpx is required per 8.1 of 05-047r3 GMLJP2 */
+            ftypBox.AppendWritableData(4, "jpx "); /* Compatibility list: second value */
+        }
+        WriteBox(fp, &ftypBox);
+
+        const bool bIPR =
+            poSrcDS->GetMetadata("xml:IPR") != nullptr &&
+            CPLFetchBool(papszOptions, "WRITE_METADATA", false);
+
+        /* Reader requirement box */
+        if( poGMLJP2Box != nullptr && bJPXOption )
+        {
+            GDALJP2Box rreqBox(fp);
+            rreqBox.SetType("rreq");
+            rreqBox.AppendUInt8(1); /* ML = 1 byte for mask length */
+
+            rreqBox.AppendUInt8(0x80 | 0x40 | (bIPR ? 0x20 : 0)); /* FUAM */
+            rreqBox.AppendUInt8(0x80); /* DCM */
+
+            rreqBox.AppendUInt16(2 + (bIPR ? 1 : 0)); /* NSF: Number of standard features */
+
+            rreqBox.AppendUInt16((bProfile1) ? 4 : 5); /* SF0 : PROFILE 1 or PROFILE 2 */
+            rreqBox.AppendUInt8(0x80); /* SM0 */
+
+            rreqBox.AppendUInt16(67); /* SF1 : GMLJP2 box */
+            rreqBox.AppendUInt8(0x40); /* SM1 */
+
+            if( bIPR )
+            {
+                rreqBox.AppendUInt16(35); /* SF2 : IPR metadata */
+                rreqBox.AppendUInt8(0x20); /* SM2 */
+            }
+            rreqBox.AppendUInt16(0); /* NVF */
+            WriteBox(fp, &rreqBox);
+        }
+
+        GDALJP2Box ihdrBox(fp);
+        ihdrBox.SetType("ihdr");
+        ihdrBox.AppendUInt32(nYSize);
+        ihdrBox.AppendUInt32(nXSize);
+        ihdrBox.AppendUInt16(static_cast<GUInt16>(nBands));
+        GByte BPC;
+        if( bSamePrecision )
+            BPC = static_cast<GByte>((pasBandParams[0].prec-1) | (pasBandParams[0].sgnd << 7));
+        else
+            BPC = 255;
+        ihdrBox.AppendUInt8(BPC);
+        ihdrBox.AppendUInt8(7); /* C=Compression type: fixed value */
+        ihdrBox.AppendUInt8(0); /* UnkC: 0= colourspace of the image is known */
+                                /*and correctly specified in the Colourspace Specification boxes within the file */
+        ihdrBox.AppendUInt8(bIPR ? 1 : 0); /* IPR: 0=no intellectual property, 1=IPR box */
+
+        GDALJP2Box bpccBox(fp);
+        if( !bSamePrecision )
+        {
+            bpccBox.SetType("bpcc");
+            for(int i=0;i<nBands;i++)
+                bpccBox.AppendUInt8(static_cast<GByte>((pasBandParams[i].prec-1) | (pasBandParams[i].sgnd << 7)));
+        }
+
+        GDALJP2Box colrBox(fp);
+        colrBox.SetType("colr");
+        colrBox.AppendUInt8(1); /* METHOD: 1=Enumerated Colourspace */
+        colrBox.AppendUInt8(0); /* PREC: Precedence. 0=(field reserved for ISO use) */
+        colrBox.AppendUInt8(0); /* APPROX: Colourspace approximation. */
+        GUInt32 enumcs = 16;
+        if( eColorSpace == OPJ_CLRSPC_SRGB )
+            enumcs = 16;
+        else if(  eColorSpace == OPJ_CLRSPC_GRAY )
+            enumcs = 17;
+        else if(  eColorSpace == OPJ_CLRSPC_SYCC )
+            enumcs = 18;
+        colrBox.AppendUInt32(enumcs); /* EnumCS: Enumerated colourspace */
+
+        GDALJP2Box pclrBox(fp);
+        GDALJP2Box cmapBox(fp);
+        int nCTComponentCount = 0;
+        if (poCT != nullptr)
+        {
+            pclrBox.SetType("pclr");
+            const int nEntries = std::min(256, poCT->GetColorEntryCount());
+            nCTComponentCount = atoi(CSLFetchNameValueDef(papszOptions, "CT_COMPONENTS", "0"));
+            if( bInspireTG )
+            {
+                if( nCTComponentCount != 0 && nCTComponentCount != 3 )
+                    CPLError(CE_Warning, CPLE_AppDefined, "Inspire TG mandates 3 components for color table");
+                else
+                    nCTComponentCount = 3;
+            }
+            else if( nCTComponentCount != 3 && nCTComponentCount != 4 )
+            {
+                nCTComponentCount = 3;
+                for(int i=0;i<nEntries;i++)
+                {
+                    const GDALColorEntry* psEntry = poCT->GetColorEntry(i);
+                    if( psEntry->c4 != 255 )
+                    {
+                        CPLDebug("OPENJPEG", "Color table has at least one non-opaque value. "
+                                "This may cause compatibility problems with some readers. "
+                                "In which case use CT_COMPONENTS=3 creation option");
+                        nCTComponentCount = 4;
+                        break;
+                    }
+                }
+            }
+            nRedBandIndex = 0;
+            nGreenBandIndex = 1;
+            nBlueBandIndex = 2;
+            nAlphaBandIndex = (nCTComponentCount == 4) ? 3 : -1;
+
+            pclrBox.AppendUInt16(static_cast<GUInt16>(nEntries));
+            pclrBox.AppendUInt8(static_cast<GByte>(nCTComponentCount)); /* NPC: Number of components */
+            for(int i=0;i<nCTComponentCount;i++)
+            {
+                pclrBox.AppendUInt8(7); /* Bi: unsigned 8 bits */
+            }
+            for(int i=0;i<nEntries;i++)
+            {
+                const GDALColorEntry* psEntry = poCT->GetColorEntry(i);
+                pclrBox.AppendUInt8((GByte)psEntry->c1);
+                pclrBox.AppendUInt8((GByte)psEntry->c2);
+                pclrBox.AppendUInt8((GByte)psEntry->c3);
+                if( nCTComponentCount == 4 )
+                    pclrBox.AppendUInt8((GByte)psEntry->c4);
+            }
+
+            cmapBox.SetType("cmap");
+            for(int i=0;i<nCTComponentCount;i++)
+            {
+                cmapBox.AppendUInt16(0); /* CMPi: code stream component index */
+                cmapBox.AppendUInt8(1); /* MYTPi: 1=palette mapping */
+                cmapBox.AppendUInt8(static_cast<GByte>(i)); /* PCOLi: index component from the map */
+            }
+        }
+
+        GDALJP2Box cdefBox(fp);
+        if( ((nBands == 3 || nBands == 4) &&
+             (eColorSpace == OPJ_CLRSPC_SRGB || eColorSpace == OPJ_CLRSPC_SYCC) &&
+             (nRedBandIndex != 0 || nGreenBandIndex != 1 || nBlueBandIndex != 2)) ||
+            nAlphaBandIndex >= 0)
+        {
+            cdefBox.SetType("cdef");
+            int nComponents = (nCTComponentCount == 4) ? 4 : nBands;
+            cdefBox.AppendUInt16(static_cast<GUInt16>(nComponents));
+            for(int i=0;i<nComponents;i++)
+            {
+                cdefBox.AppendUInt16(static_cast<GUInt16>(i));   /* Component number */
+                if( i != nAlphaBandIndex )
+                {
+                    cdefBox.AppendUInt16(0);   /* Signification: This channel is the colour image data for the associated colour */
+                    if( eColorSpace == OPJ_CLRSPC_GRAY && nComponents == 2)
+                        cdefBox.AppendUInt16(1); /* Colour of the component: associated with a particular colour */
+                    else if ((eColorSpace == OPJ_CLRSPC_SRGB ||
+                            eColorSpace == OPJ_CLRSPC_SYCC) &&
+                            (nComponents == 3 || nComponents == 4) )
+                    {
+                        if( i == nRedBandIndex )
+                            cdefBox.AppendUInt16(1);
+                        else if( i == nGreenBandIndex )
+                            cdefBox.AppendUInt16(2);
+                        else if( i == nBlueBandIndex )
+                            cdefBox.AppendUInt16(3);
+                        else
+                        {
+                            CPLError(CE_Warning, CPLE_AppDefined,
+                                    "Could not associate band %d with a red/green/blue channel",
+                                    i+1);
+                            cdefBox.AppendUInt16(65535);
+                        }
+                    }
+                    else
+                        cdefBox.AppendUInt16(65535); /* Colour of the component: not associated with any particular colour */
+                }
+                else
+                {
+                    cdefBox.AppendUInt16(1);        /* Signification: Non pre-multiplied alpha */
+                    cdefBox.AppendUInt16(0);        /* Colour of the component: This channel is associated as the image as a whole */
+                }
+            }
+        }
+
+        // Add res box if needed
+        GDALJP2Box* poRes = nullptr;
+        if( poSrcDS->GetMetadataItem("TIFFTAG_XRESOLUTION") != nullptr
+            && poSrcDS->GetMetadataItem("TIFFTAG_YRESOLUTION") != nullptr
+            && poSrcDS->GetMetadataItem("TIFFTAG_RESOLUTIONUNIT") != nullptr )
+        {
+            double dfXRes =
+                CPLAtof(poSrcDS->GetMetadataItem("TIFFTAG_XRESOLUTION"));
+            double dfYRes =
+                CPLAtof(poSrcDS->GetMetadataItem("TIFFTAG_YRESOLUTION"));
+            int nResUnit = atoi(poSrcDS->GetMetadataItem("TIFFTAG_RESOLUTIONUNIT"));
+#define PIXELS_PER_INCH 2
+#define PIXELS_PER_CM   3
+
+            if( nResUnit == PIXELS_PER_INCH )
+            {
+                // convert pixels per inch to pixels per cm.
+                dfXRes = dfXRes * 39.37 / 100.0;
+                dfYRes = dfYRes * 39.37 / 100.0;
+                nResUnit = PIXELS_PER_CM;
+            }
+
+            if( nResUnit == PIXELS_PER_CM &&
+                dfXRes > 0 && dfYRes > 0 &&
+                dfXRes < 65535 && dfYRes < 65535 )
+            {
+                /* Format a resd box and embed it inside a res box */
+                GDALJP2Box oResd;
+                oResd.SetType("resd");
+
+                int nYDenom = 1;
+                while (nYDenom < 32767 && dfYRes < 32767)
+                {
+                    dfYRes *= 2;
+                    nYDenom *= 2;
+                }
+                int nXDenom = 1;
+                while (nXDenom < 32767 && dfXRes < 32767)
+                {
+                    dfXRes *= 2;
+                    nXDenom *= 2;
+                }
+
+                oResd.AppendUInt16((GUInt16)dfYRes);
+                oResd.AppendUInt16((GUInt16)nYDenom);
+                oResd.AppendUInt16((GUInt16)dfXRes);
+                oResd.AppendUInt16((GUInt16)nXDenom);
+                oResd.AppendUInt8(2); /* vertical exponent */
+                oResd.AppendUInt8(2); /* horizontal exponent */
+
+                GDALJP2Box* poResd = &oResd;
+                poRes = GDALJP2Box::CreateAsocBox( 1, &poResd );
+                poRes->SetType("res ");
+            }
+        }
+
+        /* Build and write jp2h super box now */
+        GDALJP2Box* apoBoxes[7];
+        int nBoxes = 1;
+        apoBoxes[0] = &ihdrBox;
+        if( bpccBox.GetDataLength() )
+            apoBoxes[nBoxes++] = &bpccBox;
+        apoBoxes[nBoxes++] = &colrBox;
+        if( pclrBox.GetDataLength() )
+            apoBoxes[nBoxes++] = &pclrBox;
+        if( cmapBox.GetDataLength() )
+            apoBoxes[nBoxes++] = &cmapBox;
+        if( cdefBox.GetDataLength() )
+            apoBoxes[nBoxes++] = &cdefBox;
+        if( poRes )
+            apoBoxes[nBoxes++] = poRes;
+        GDALJP2Box* psJP2HBox = GDALJP2Box::CreateSuperBox( "jp2h",
+                                                            nBoxes,
+                                                            apoBoxes );
+        WriteBox(fp, psJP2HBox);
+        delete psJP2HBox;
+        delete poRes;
+
+        if( !bGeoBoxesAfter )
+        {
+            if( bGeoJP2Option && bGeoreferencingCompatOfGeoJP2 )
+            {
+                GDALJP2Box* poBox = oJP2MD.CreateJP2GeoTIFF();
+                WriteBox(fp, poBox);
+                delete poBox;
+            }
+
+            if( CPLFetchBool(papszOptions, "WRITE_METADATA", false) &&
+                !CPLFetchBool(papszOptions, "MAIN_MD_DOMAIN_ONLY", false) )
+            {
+                WriteXMPBox(fp, poSrcDS, papszOptions);
+            }
+
+            if( CPLFetchBool(papszOptions, "WRITE_METADATA", false) )
+            {
+                if( !CPLFetchBool(papszOptions, "MAIN_MD_DOMAIN_ONLY", false) )
+                    WriteXMLBoxes(fp, poSrcDS, papszOptions);
+                WriteGDALMetadataBox(fp, poSrcDS, papszOptions);
+            }
+
+            if( poGMLJP2Box != nullptr )
+            {
+                WriteBox(fp, poGMLJP2Box);
+            }
+        }
+    }
+    CPLFree(pasBandParams);
+    pasBandParams = nullptr;
+
+/* -------------------------------------------------------------------- */
+/*      Try lossless reuse of an existing JPEG2000 codestream           */
+/* -------------------------------------------------------------------- */
+    vsi_l_offset nCodeStreamLength = 0;
+    vsi_l_offset nCodeStreamStart = 0;
+    VSILFILE* fpSrc = nullptr;
+    if( CPLFetchBool(papszOptions, "USE_SRC_CODESTREAM", false) )
+    {
+        CPLString osSrcFilename( poSrcDS->GetDescription() );
+        if( poSrcDS->GetDriver() != nullptr &&
+            poSrcDS->GetDriver() == GDALGetDriverByName("VRT") )
+        {
+            VRTDataset* poVRTDS = (VRTDataset* )poSrcDS;
+            GDALDataset* poSimpleSourceDS = poVRTDS->GetSingleSimpleSource();
+            if( poSimpleSourceDS )
+                osSrcFilename = poSimpleSourceDS->GetDescription();
+        }
+
+        fpSrc = VSIFOpenL( osSrcFilename, "rb" );
+        if( fpSrc )
+        {
+            nCodeStreamStart = JP2OpenJPEGFindCodeStream(fpSrc,
+                                                         &nCodeStreamLength);
+        }
+        if( nCodeStreamLength == 0 )
+        {
+            CPLError(CE_Warning, CPLE_AppDefined,
+                     "USE_SRC_CODESTREAM=YES specified, but no codestream found");
+        }
+    }
+
+    if( eCodecFormat == OPJ_CODEC_JP2  )
+    {
+        // Start codestream box
+        nStartJP2C = VSIFTellL(fp);
+        if( nCodeStreamLength )
+            bUseXLBoxes = ((vsi_l_offset)(GUInt32)nCodeStreamLength != nCodeStreamLength);
+        else
+            bUseXLBoxes = CPLFetchBool(papszOptions, "JP2C_XLBOX", false) || /* For debugging */
+                (GIntBig)nXSize * nYSize * nBands * nDataTypeSize / adfRates.back() > 4e9;
+        GUInt32 nLBox = (bUseXLBoxes) ? 1 : 0;
+        CPL_MSBPTR32(&nLBox);
+        VSIFWriteL(&nLBox, 1, 4, fp);
+        VSIFWriteL("jp2c", 1, 4, fp);
+        if( bUseXLBoxes )
+        {
+            GUIntBig nXLBox = 0;
+            VSIFWriteL(&nXLBox, 1, 8, fp);
+        }
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Do lossless reuse of an existing JPEG2000 codestream            */
+/* -------------------------------------------------------------------- */
+    if( fpSrc )
+    {
+        const char* apszIgnoredOptions[] = {
+            "BLOCKXSIZE", "BLOCKYSIZE", "QUALITY", "REVERSIBLE",
+            "RESOLUTIONS", "PROGRESSION", "SOP", "EPH",
+            "YCBCR420", "YCC", "NBITS", "1BIT_ALPHA", "PRECINCTS",
+            "TILEPARTS", "CODEBLOCK_WIDTH", "CODEBLOCK_HEIGHT", "PLT", nullptr };
+        for( int i = 0; apszIgnoredOptions[i]; i ++)
+        {
+            if( CSLFetchNameValue(papszOptions, apszIgnoredOptions[i]) )
+            {
+                CPLError(CE_Warning, CPLE_NotSupported,
+                            "Option %s ignored when USE_SRC_CODESTREAM=YES",
+                            apszIgnoredOptions[i]);
+            }
+        }
+        GByte abyBuffer[4096];
+        VSIFSeekL( fpSrc, nCodeStreamStart, SEEK_SET );
+        vsi_l_offset nRead = 0;
+        /* coverity[tainted_data] */
+        while( nRead < nCodeStreamLength )
+        {
+            int nToRead = ( nCodeStreamLength-nRead > 4096 ) ? 4096 :
+                                        (int)(nCodeStreamLength-nRead);
+            if( (int)VSIFReadL(abyBuffer, 1, nToRead, fpSrc) != nToRead )
+            {
+                VSIFCloseL(fp);
+                VSIFCloseL(fpSrc);
+                opj_image_destroy(psImage);
+                opj_destroy_codec(pCodec);
+                delete poGMLJP2Box;
+                return nullptr;
+            }
+            if( nRead == 0 && (pszProfile || bInspireTG) &&
+                abyBuffer[2] == 0xFF && abyBuffer[3] == 0x51 )
+            {
+                if( EQUAL(pszProfile, "UNRESTRICTED") )
+                {
+                    abyBuffer[6] = 0;
+                    abyBuffer[7] = 0;
+                }
+                else if( EQUAL(pszProfile, "PROFILE_1") || bInspireTG )
+                {
+                    // TODO: ultimately we should check that we can really set Profile 1
+                    abyBuffer[6] = 0;
+                    abyBuffer[7] = 2;
+                }
+            }
+            if( (int)VSIFWriteL(abyBuffer, 1, nToRead, fp) != nToRead ||
+                !pfnProgress( (nRead + nToRead) * 1.0 / nCodeStreamLength,
+                                nullptr, pProgressData ) )
+            {
+                VSIFCloseL(fp);
+                VSIFCloseL(fpSrc);
+                opj_image_destroy(psImage);
+                opj_destroy_codec(pCodec);
+                delete poGMLJP2Box;
+                return nullptr;
+            }
+            nRead += nToRead;
+        }
+
+        VSIFCloseL(fpSrc);
+    }
+    else
+    {
+        JP2OpenJPEGFile sJP2OpenJPEGFile;
+        sJP2OpenJPEGFile.fp = fp;
+        sJP2OpenJPEGFile.nBaseOffset = VSIFTellL(fp);
+        opj_stream_t * pStream = opj_stream_create(1024*1024, FALSE);
+        opj_stream_set_write_function(pStream, JP2OpenJPEGDataset_Write);
+        opj_stream_set_seek_function(pStream, JP2OpenJPEGDataset_Seek);
+        opj_stream_set_skip_function(pStream, JP2OpenJPEGDataset_Skip);
+        opj_stream_set_user_data(pStream, &sJP2OpenJPEGFile, nullptr);
+
+        if (!opj_start_compress(pCodec,psImage,pStream))
+        {
+            CPLError(CE_Failure, CPLE_AppDefined,
+                    "opj_start_compress() failed");
+            opj_stream_destroy(pStream);
+            opj_image_destroy(psImage);
+            opj_destroy_codec(pCodec);
+            VSIFCloseL(fp);
+            delete poGMLJP2Box;
+            return nullptr;
+        }
+
+        const int nTilesX = DIV_ROUND_UP(nXSize, nBlockXSize);
+        const int nTilesY = DIV_ROUND_UP(nYSize, nBlockYSize);
+
+        const GUIntBig nTileSize = (GUIntBig)nBlockXSize * nBlockYSize * nBands * nDataTypeSize;
+        GByte* pTempBuffer = nullptr;
+
+        const bool bUseIOThread =
+            (nTilesX > 1 || nTilesY > 1) &&
+            nTileSize < 10 * 1024 * 1024 &&
+            strcmp(CPLGetThreadingModel(), "stub") != 0 &&
+            CPLTestBool(CPLGetConfigOption("JP2OPENJPEG_USE_THREADED_IO", "YES"));
+
+        if( nTileSize > UINT_MAX )
+        {
+            CPLError(CE_Failure, CPLE_NotSupported, "Tile size exceeds 4GB");
+            pTempBuffer = nullptr;
+        }
+        else
+        {
+            // Double memory buffer when using threaded I/O
+            const size_t nBufferSize = static_cast<size_t>(
+                bUseIOThread ? nTileSize * 2 : nTileSize);
+            pTempBuffer = (GByte*)VSIMalloc(nBufferSize);
+        }
+        if (pTempBuffer == nullptr)
+        {
+            opj_stream_destroy(pStream);
+            opj_image_destroy(psImage);
+            opj_destroy_codec(pCodec);
+            VSIFCloseL(fp);
+            delete poGMLJP2Box;
+            return nullptr;
+        }
+
+        GByte* pYUV420Buffer = nullptr;
+        if (bYCBCR420)
+        {
+            pYUV420Buffer =(GByte*)VSIMalloc(3 * nBlockXSize * nBlockYSize / 2 +
+                                            ((nBands == 4) ? nBlockXSize * nBlockYSize : 0));
+            if (pYUV420Buffer == nullptr)
+            {
+                opj_stream_destroy(pStream);
+                opj_image_destroy(psImage);
+                opj_destroy_codec(pCodec);
+                CPLFree(pTempBuffer);
+                VSIFCloseL(fp);
+                delete poGMLJP2Box;
+                return nullptr;
+            }
+        }
+
+/* -------------------------------------------------------------------- */
+/*      Iterate over the tiles                                          */
+/* -------------------------------------------------------------------- */
+        pfnProgress( 0.0, nullptr, pProgressData );
+
+        struct ReadRasterJob
+        {
+            GDALDataset* poSrcDS;
+            int nXOff;
+            int nYOff;
+            int nWidthToRead;
+            int nHeightToRead;
+            GDALDataType eDataType;
+            GByte* pBuffer;
+            int nBands;
+            CPLErr eErr;
+        };
+
+        const auto ReadRasterFunction = [](void* threadData)
+        {
+            ReadRasterJob* job = static_cast<ReadRasterJob*>(threadData);
+            job->eErr = job->poSrcDS->RasterIO(
+                GF_Read,
+                job->nXOff, job->nYOff,
+                job->nWidthToRead, job->nHeightToRead,
+                job->pBuffer, job->nWidthToRead, job->nHeightToRead,
+                job->eDataType, job->nBands, nullptr,
+                0,0,0,nullptr);
+        };
+
+        CPLWorkerThreadPool oPool;
+        if( bUseIOThread )
+        {
+            oPool.Setup(1, nullptr, nullptr);
+        }
+
+        GByte* pabyActiveBuffer = pTempBuffer;
+        GByte* pabyBackgroundBuffer = pTempBuffer + static_cast<size_t>(nTileSize);
+
+        CPLErr eErr = CE_None;
+        int iTile = 0;
+
+        ReadRasterJob job;
+        job.eDataType = eDataType;
+        job.pBuffer = pabyActiveBuffer;
+        job.nBands = nBands;
+        job.eErr = CE_Failure;
+        job.poSrcDS = poSrcDS;
+
+        if( bUseIOThread )
+        {
+            job.nXOff = 0;
+            job.nYOff = 0;
+            job.nWidthToRead = std::min(nBlockXSize, nXSize);
+            job.nHeightToRead = std::min(nBlockYSize, nYSize);
+            job.pBuffer = pabyBackgroundBuffer;
+            ReadRasterFunction(&job);
+            eErr = job.eErr;
+        }
+
+        for(int nBlockYOff=0;eErr == CE_None && nBlockYOff<nTilesY;nBlockYOff++)
+        {
+            for(int nBlockXOff=0;eErr == CE_None && nBlockXOff<nTilesX;nBlockXOff++)
+            {
+                const int nWidthToRead =
+                    std::min(nBlockXSize, nXSize - nBlockXOff * nBlockXSize);
+                const int nHeightToRead =
+                    std::min(nBlockYSize, nYSize - nBlockYOff * nBlockYSize);
+
+                if( bUseIOThread )
+                {
+                    // Wait for previous background I/O task to be finished
+                    oPool.WaitCompletion();
+                    eErr = job.eErr;
+
+                    // Swap buffers
+                    std::swap(pabyBackgroundBuffer, pabyActiveBuffer);
+
+                    // Prepare for next I/O task
+                    int nNextBlockXOff = nBlockXOff + 1;
+                    int nNextBlockYOff = nBlockYOff;
+                    if( nNextBlockXOff == nTilesX )
+                    {
+                        nNextBlockXOff = 0;
+                        nNextBlockYOff ++;
+                    }
+                    if( nNextBlockYOff != nTilesY )
+                    {
+                        job.nXOff = nNextBlockXOff * nBlockXSize;
+                        job.nYOff = nNextBlockYOff * nBlockYSize;
+                        job.nWidthToRead =
+                            std::min(nBlockXSize, nXSize - job.nXOff);
+                        job.nHeightToRead =
+                            std::min(nBlockYSize, nYSize - job.nYOff);
+                        job.pBuffer = pabyBackgroundBuffer;
+
+                        // Submit next job
+                        oPool.SubmitJob(ReadRasterFunction, &job);
+                    }
+                }
+                else
+                {
+                    job.nXOff = nBlockXOff * nBlockXSize;
+                    job.nYOff = nBlockYOff * nBlockYSize;
+                    job.nWidthToRead = nWidthToRead;
+                    job.nHeightToRead = nHeightToRead;
+                    ReadRasterFunction(&job);
+                    eErr = job.eErr;
+                }
+
+                if( b1BitAlpha )
+                {
+                    for(int i=0;i<nWidthToRead*nHeightToRead;i++)
+                    {
+                        if( pabyActiveBuffer[nAlphaBandIndex*nWidthToRead*nHeightToRead+i] )
+                            pabyActiveBuffer[nAlphaBandIndex*nWidthToRead*nHeightToRead+i] = 1;
+                        else
+                            pabyActiveBuffer[nAlphaBandIndex*nWidthToRead*nHeightToRead+i] = 0;
+                    }
+                }
+                if (eErr == CE_None)
+                {
+                    if (bYCBCR420)
+                    {
+                        int j, i;
+                        for(j=0;j<nHeightToRead;j++)
+                        {
+                            for(i=0;i<nWidthToRead;i++)
+                            {
+                                int R = pabyActiveBuffer[j*nWidthToRead+i];
+                                int G = pabyActiveBuffer[nHeightToRead*nWidthToRead + j*nWidthToRead+i];
+                                int B = pabyActiveBuffer[2*nHeightToRead*nWidthToRead + j*nWidthToRead+i];
+                                int Y = (int) (0.299 * R + 0.587 * G + 0.114 * B);
+                                int Cb = CLAMP_0_255((int) (-0.1687 * R - 0.3313 * G + 0.5 * B  + 128));
+                                int Cr = CLAMP_0_255((int) (0.5 * R - 0.4187 * G - 0.0813 * B  + 128));
+                                pYUV420Buffer[j*nWidthToRead+i] = (GByte) Y;
+                                pYUV420Buffer[nHeightToRead * nWidthToRead + ((j/2) * ((nWidthToRead)/2) + i/2) ] = (GByte) Cb;
+                                pYUV420Buffer[5 * nHeightToRead * nWidthToRead / 4 + ((j/2) * ((nWidthToRead)/2) + i/2) ] = (GByte) Cr;
+                                if( nBands == 4 )
+                                {
+                                    pYUV420Buffer[3 * nHeightToRead * nWidthToRead / 2 + j*nWidthToRead+i ] =
+                                        (GByte) pabyActiveBuffer[3*nHeightToRead*nWidthToRead + j*nWidthToRead+i];
+                                }
+                            }
+                        }
+
+                        int nBytesToWrite = 3 * nWidthToRead * nHeightToRead / 2;
+                        if (nBands == 4)
+                            nBytesToWrite += nBlockXSize * nBlockYSize;
+
+                        if (!opj_write_tile(pCodec,
+                                            iTile,
+                                            pYUV420Buffer,
+                                            nBytesToWrite,
+                                            pStream))
+                        {
+                            CPLError(CE_Failure, CPLE_AppDefined,
+                                    "opj_write_tile() failed");
+                            eErr = CE_Failure;
+                        }
+                    }
+                    else
+                    {
+                        if (!opj_write_tile(pCodec,
+                                            iTile,
+                                            pabyActiveBuffer,
+                                            nWidthToRead * nHeightToRead * nBands * nDataTypeSize,
+                                            pStream))
+                        {
+                            CPLError(CE_Failure, CPLE_AppDefined,
+                                    "opj_write_tile() failed");
+                            eErr = CE_Failure;
+                        }
+                    }
+                }
+
+                if( !pfnProgress( (iTile + 1) * 1.0 / (nTilesX * nTilesY), nullptr, pProgressData ) )
+                    eErr = CE_Failure;
+
+                iTile ++;
+            }
+        }
+
+        VSIFree(pTempBuffer);
+        VSIFree(pYUV420Buffer);
+
+        if (eErr != CE_None)
+        {
+            opj_stream_destroy(pStream);
+            opj_image_destroy(psImage);
+            opj_destroy_codec(pCodec);
+            VSIFCloseL(fp);
+            delete poGMLJP2Box;
+            return nullptr;
+        }
+
+        if (!opj_end_compress(pCodec,pStream))
+        {
+            CPLError(CE_Failure, CPLE_AppDefined,
+                    "opj_end_compress() failed");
+            opj_stream_destroy(pStream);
+            opj_image_destroy(psImage);
+            opj_destroy_codec(pCodec);
+            VSIFCloseL(fp);
+            delete poGMLJP2Box;
+            return nullptr;
+        }
+        opj_stream_destroy(pStream);
+    }
+
+    opj_image_destroy(psImage);
+    opj_destroy_codec(pCodec);
+
+/* -------------------------------------------------------------------- */
+/*      Patch JP2C box length and add trailing JP2 boxes                */
+/* -------------------------------------------------------------------- */
+    if( eCodecFormat == OPJ_CODEC_JP2 &&
+        !CPLFetchBool(papszOptions, "JP2C_LENGTH_ZERO", false) /* debug option */ )
+    {
+        vsi_l_offset nEndJP2C = VSIFTellL(fp);
+        GUIntBig nBoxSize = nEndJP2C -nStartJP2C;
+        if( bUseXLBoxes )
+        {
+            VSIFSeekL(fp, nStartJP2C + 8, SEEK_SET);
+            CPL_MSBPTR64(&nBoxSize);
+            VSIFWriteL(&nBoxSize, 8, 1, fp);
+        }
+        else
+        {
+            GUInt32 nBoxSize32 = (GUInt32)nBoxSize;
+            if( (vsi_l_offset)nBoxSize32 != nBoxSize )
+            {
+                /*  Should not happen hopefully */
+                if( (bGeoreferencingCompatOfGeoJP2 || poGMLJP2Box) && bGeoBoxesAfter )
+                {
+                    CPLError(CE_Warning, CPLE_AppDefined,
+                             "Cannot write GMLJP2/GeoJP2 boxes as codestream is unexpectedly > 4GB");
+                    bGeoreferencingCompatOfGeoJP2 = FALSE;
+                    delete poGMLJP2Box;
+                    poGMLJP2Box = nullptr;
+                }
+            }
+            else
+            {
+                VSIFSeekL(fp, nStartJP2C, SEEK_SET);
+                CPL_MSBPTR32(&nBoxSize32);
+                VSIFWriteL(&nBoxSize32, 4, 1, fp);
+            }
+        }
+        VSIFSeekL(fp, 0, SEEK_END);
+
+        if( CPLFetchBool(papszOptions, "WRITE_METADATA", false) )
+        {
+            WriteIPRBox(fp, poSrcDS, papszOptions);
+        }
+
+        if( bGeoBoxesAfter )
+        {
+            if( poGMLJP2Box != nullptr )
+            {
+                WriteBox(fp, poGMLJP2Box);
+            }
+
+            if( CPLFetchBool(papszOptions, "WRITE_METADATA", false) )
+            {
+                if( !CPLFetchBool(papszOptions, "MAIN_MD_DOMAIN_ONLY", false) )
+                    WriteXMLBoxes(fp, poSrcDS, papszOptions);
+                WriteGDALMetadataBox(fp, poSrcDS, papszOptions);
+            }
+
+            if( bGeoJP2Option && bGeoreferencingCompatOfGeoJP2 )
+            {
+                GDALJP2Box* poBox = oJP2MD.CreateJP2GeoTIFF();
+                WriteBox(fp, poBox);
+                delete poBox;
+            }
+
+            if( CPLFetchBool(papszOptions, "WRITE_METADATA", false) &&
+                !CPLFetchBool(papszOptions, "MAIN_MD_DOMAIN_ONLY", false) )
+            {
+                WriteXMPBox(fp, poSrcDS, papszOptions);
+            }
+        }
+    }
+
+    VSIFCloseL(fp);
+    delete poGMLJP2Box;
+
+/* -------------------------------------------------------------------- */
+/*      Re-open dataset, and copy any auxiliary pam information.         */
+/* -------------------------------------------------------------------- */
+
+    GDALOpenInfo oOpenInfo(pszFilename, GA_ReadOnly);
+    JP2OpenJPEGDataset *poDS = (JP2OpenJPEGDataset*) JP2OpenJPEGDataset::Open(&oOpenInfo);
+
+    if( poDS )
+    {
+        poDS->CloneInfo( poSrcDS, GCIF_PAM_DEFAULT & (~GCIF_METADATA) );
+
+        /* Only write relevant metadata to PAM, and if needed */
+        if( !CPLFetchBool(papszOptions, "WRITE_METADATA", false) )
+        {
+            char** papszSrcMD = CSLDuplicate(poSrcDS->GetMetadata());
+            papszSrcMD = CSLSetNameValue(papszSrcMD, GDALMD_AREA_OR_POINT, nullptr);
+            papszSrcMD = CSLSetNameValue(papszSrcMD, "Corder", nullptr);
+            for(char** papszSrcMDIter = papszSrcMD;
+                    papszSrcMDIter && *papszSrcMDIter; )
+            {
+                /* Remove entries like KEY= (without value) */
+                if( (*papszSrcMDIter)[0] &&
+                    (*papszSrcMDIter)[strlen((*papszSrcMDIter))-1] == '=' )
+                {
+                    CPLFree(*papszSrcMDIter);
+                    memmove(papszSrcMDIter, papszSrcMDIter + 1,
+                            sizeof(char*) * (CSLCount(papszSrcMDIter + 1) + 1));
+                }
+                else
+                    ++papszSrcMDIter;
+            }
+            char** papszMD = CSLDuplicate(poDS->GetMetadata());
+            papszMD = CSLSetNameValue(papszMD, GDALMD_AREA_OR_POINT, nullptr);
+            if( papszSrcMD && papszSrcMD[0] != nullptr &&
+                CSLCount(papszSrcMD) != CSLCount(papszMD) )
+            {
+                poDS->SetMetadata(papszSrcMD);
+            }
+            CSLDestroy(papszSrcMD);
+            CSLDestroy(papszMD);
+        }
+    }
+
+    return poDS;
+}
+
+/************************************************************************/
+/*                      GDALRegister_JP2OpenJPEG()                      */
+/************************************************************************/
+
+void GDALRegister_JP2OpenJPEG()
+
+{
+    if( !GDAL_CHECK_VERSION( "JP2OpenJPEG driver" ) )
+        return;
+
+    if( GDALGetDriverByName( "JP2OpenJPEG" ) != nullptr )
+        return;
+
+    GDALDriver *poDriver = new GDALDriver();
+
+    poDriver->SetDescription( "JP2OpenJPEG" );
+    poDriver->SetMetadataItem( GDAL_DCAP_RASTER, "YES" );
+    poDriver->SetMetadataItem( GDAL_DCAP_VECTOR, "YES" );
+    poDriver->SetMetadataItem( GDAL_DMD_LONGNAME,
+                               "JPEG-2000 driver based on OpenJPEG library" );
+    poDriver->SetMetadataItem( GDAL_DMD_HELPTOPIC, "drivers/raster/jp2openjpeg.html" );
+    poDriver->SetMetadataItem( GDAL_DMD_MIMETYPE, "image/jp2" );
+    poDriver->SetMetadataItem( GDAL_DMD_EXTENSION, "jp2" );
+    poDriver->SetMetadataItem( GDAL_DMD_EXTENSIONS, "jp2 j2k" );
+    poDriver->SetMetadataItem( GDAL_DMD_CREATIONDATATYPES,
+                               "Byte Int16 UInt16 Int32 UInt32" );
+
+    poDriver->SetMetadataItem( GDAL_DMD_OPENOPTIONLIST,
+"<OpenOptionList>"
+#if IS_OPENJPEG_OR_LATER(2,5,0)
+"   <Option name='STRICT' type='boolean' description='Whether strict/pedantic decoding should be adopted. Set to NO to allow decoding broken files' default='YES'/>"
+#endif
+"   <Option name='1BIT_ALPHA_PROMOTION' type='boolean' description='Whether a 1-bit alpha channel should be promoted to 8-bit' default='YES'/>"
+"   <Option name='OPEN_REMOTE_GML' type='boolean' description='Whether to load remote vector layers referenced by a link in a GMLJP2 v2 box' default='NO'/>"
+"   <Option name='GEOREF_SOURCES' type='string' description='Comma separated list made with values INTERNAL/GMLJP2/GEOJP2/WORLDFILE/PAM/NONE that describe the priority order for georeferencing' default='PAM,GEOJP2,GMLJP2,WORLDFILE'/>"
+"   <Option name='USE_TILE_AS_BLOCK' type='boolean' description='Whether to always use the JPEG-2000 block size as the GDAL block size' default='NO'/>"
+"</OpenOptionList>" );
+
+    poDriver->SetMetadataItem( GDAL_DMD_CREATIONOPTIONLIST,
+"<CreationOptionList>"
+"   <Option name='CODEC' type='string-select' default='according to file extension. If unknown, default to J2K'>"
+"       <Value>JP2</Value>"
+"       <Value>J2K</Value>"
+"   </Option>"
+"   <Option name='GeoJP2' type='boolean' description='Whether to emit a GeoJP2 box' default='YES'/>"
+"   <Option name='GMLJP2' type='boolean' description='Whether to emit a GMLJP2 v1 box' default='YES'/>"
+"   <Option name='GMLJP2V2_DEF' type='string' description='Definition file to describe how a GMLJP2 v2 box should be generated. If set to YES, a minimal instance will be created'/>"
+"   <Option name='QUALITY' type='string' description='Single quality value or comma separated list of increasing quality values for several layers, each in the 0-100 range' default='25'/>"
+"   <Option name='REVERSIBLE' type='boolean' description='True if the compression is reversible' default='false'/>"
+"   <Option name='RESOLUTIONS' type='int' description='Number of resolutions.' min='1' max='30'/>"
+"   <Option name='BLOCKXSIZE' type='int' description='Tile Width' default='1024'/>"
+"   <Option name='BLOCKYSIZE' type='int' description='Tile Height' default='1024'/>"
+"   <Option name='PROGRESSION' type='string-select' default='LRCP'>"
+"       <Value>LRCP</Value>"
+"       <Value>RLCP</Value>"
+"       <Value>RPCL</Value>"
+"       <Value>PCRL</Value>"
+"       <Value>CPRL</Value>"
+"   </Option>"
+"   <Option name='SOP' type='boolean' description='True to insert SOP markers' default='false'/>"
+"   <Option name='EPH' type='boolean' description='True to insert EPH markers' default='false'/>"
+"   <Option name='YCBCR420' type='boolean' description='if RGB must be resampled to YCbCr 4:2:0' default='false'/>"
+"   <Option name='YCC' type='boolean' description='if RGB must be transformed to YCC color space (lossless MCT transform)' default='YES'/>"
+"   <Option name='NBITS' type='int' description='Bits (precision) for sub-byte files (1-7), sub-uint16 (9-15), sub-uint32 (17-31)'/>"
+"   <Option name='1BIT_ALPHA' type='boolean' description='Whether to encode the alpha channel as a 1-bit channel' default='NO'/>"
+"   <Option name='ALPHA' type='boolean' description='Whether to force encoding last channel as alpha channel' default='NO'/>"
+"   <Option name='PROFILE' type='string-select' description='Which codestream profile to use' default='AUTO'>"
+"       <Value>AUTO</Value>"
+"       <Value>UNRESTRICTED</Value>"
+"       <Value>PROFILE_1</Value>"
+"   </Option>"
+"   <Option name='INSPIRE_TG' type='boolean' description='Whether to use features that comply with Inspire Orthoimagery Technical Guidelines' default='NO'/>"
+"   <Option name='JPX' type='boolean' description='Whether to advertise JPX features when a GMLJP2 box is written (or use JPX branding if GMLJP2 v2)' default='YES'/>"
+"   <Option name='GEOBOXES_AFTER_JP2C' type='boolean' description='Whether to place GeoJP2/GMLJP2 boxes after the code-stream' default='NO'/>"
+"   <Option name='PRECINCTS' type='string' description='Precincts size as a string of the form {w,h},{w,h},... with power-of-two values'/>"
+"   <Option name='TILEPARTS' type='string-select' description='Whether to generate tile-parts and according to which criterion' default='DISABLED'>"
+"       <Value>DISABLED</Value>"
+"       <Value>RESOLUTIONS</Value>"
+"       <Value>LAYERS</Value>"
+"       <Value>COMPONENTS</Value>"
+"   </Option>"
+"   <Option name='CODEBLOCK_WIDTH' type='int' description='Codeblock width' default='64' min='4' max='1024'/>"
+"   <Option name='CODEBLOCK_HEIGHT' type='int' description='Codeblock height' default='64' min='4' max='1024'/>"
+"   <Option name='CT_COMPONENTS' type='int' min='3' max='4' description='If there is one color table, number of color table components to write. Autodetected if not specified.'/>"
+"   <Option name='WRITE_METADATA' type='boolean' description='Whether metadata should be written, in a dedicated JP2 XML box' default='NO'/>"
+"   <Option name='MAIN_MD_DOMAIN_ONLY' type='boolean' description='(Only if WRITE_METADATA=YES) Whether only metadata from the main domain should be written' default='NO'/>"
+"   <Option name='USE_SRC_CODESTREAM' type='boolean' description='When source dataset is JPEG2000, whether to reuse the codestream of the source dataset unmodified' default='NO'/>"
+#if IS_OPENJPEG_OR_LATER(2,3,0)
+"   <Option name='CODEBLOCK_STYLE' type='string' description='Comma-separated combination of BYPASS, RESET, TERMALL, VSC, PREDICTABLE, SEGSYM or value between 0 and 63'/>"
+#endif
+#if IS_OPENJPEG_OR_LATER(2,4,0)
+"   <Option name='PLT' type='boolean' description='True to insert PLT marker segments' default='false'/>"
+#endif
+#if IS_OPENJPEG_OR_LATER(2,5,0)
+"   <Option name='TLM' type='boolean' description='True to insert TLM marker segments' default='false'/>"
+#endif
+"</CreationOptionList>"  );
+
+    poDriver->SetMetadataItem( GDAL_DCAP_VIRTUALIO, "YES" );
+
+    poDriver->pfnIdentify = JP2OpenJPEGDataset::Identify;
+    poDriver->pfnOpen = JP2OpenJPEGDataset::Open;
+    poDriver->pfnCreateCopy = JP2OpenJPEGDataset::CreateCopy;
+
+    GetGDALDriverManager()->RegisterDriver( poDriver );
+}
diff -Nru gdal-3.5.0-orig/m4/geos.m4 gdal-3.5.0-patched/m4/geos.m4
--- gdal-3.5.0-orig/m4/geos.m4	2022-05-10 10:03:38.000000000 -0400
+++ gdal-3.5.0-patched/m4/geos.m4	2022-09-13 14:32:47.643089147 -0400
@@ -124,7 +124,7 @@
 
       HAVE_GEOS="no"
 
-      GEOS_LIBS="`${GEOS_CONFIG} --ldflags` -lgeos_c"
+      GEOS_LIBS="`${GEOS_CONFIG} --static-clibs`"
       GEOS_CFLAGS="`${GEOS_CONFIG} --cflags`"
       GEOS_VERSION="`${GEOS_CONFIG} --version`"
 
diff -Nru gdal-3.5.0-orig/m4/geos.m4.orig gdal-3.5.0-patched/m4/geos.m4.orig
--- gdal-3.5.0-orig/m4/geos.m4.orig	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.5.0-patched/m4/geos.m4.orig	2022-09-14 04:26:13.028347536 -0400
@@ -0,0 +1,167 @@
+dnl ***************************************************************************
+dnl $Id$
+dnl
+dnl Project:  GDAL
+dnl Purpose:  Test for GEOS library presence
+dnl Author:   Andrey Kiselev, dron@ak4719.spb.edu
+dnl	      Ideas borrowed from the old GDAL test and from the macro
+dnl           supplied with GEOS package.
+dnl
+dnl ***************************************************************************
+dnl Copyright (c) 2006, Andrey Kiselev
+dnl
+dnl Permission is hereby granted, free of charge, to any person obtaining a
+dnl copy of this software and associated documentation files (the "Software"),
+dnl to deal in the Software without restriction, including without limitation
+dnl the rights to use, copy, modify, merge, publish, distribute, sublicense,
+dnl and/or sell copies of the Software, and to permit persons to whom the
+dnl Software is furnished to do so, subject to the following conditions:
+dnl
+dnl The above copyright notice and this permission notice shall be included
+dnl in all copies or substantial portions of the Software.
+dnl
+dnl THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+dnl OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+dnl FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+dnl THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+dnl LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+dnl FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+dnl DEALINGS IN THE SOFTWARE.
+dnl ***************************************************************************
+
+dnl
+dnl GEOS_INIT (MINIMUM_VERSION)
+dnl
+dnl Test for GEOS: define HAVE_GEOS, GEOS_LIBS, GEOS_CFLAGS, GEOS_VERSION
+dnl
+dnl Call as GEOS_INIT or GEOS_INIT(minimum version) in configure.ac. Test
+dnl HAVE_GEOS (yes|no) afterwards. If yes, all other vars above can be
+dnl used in program.
+dnl
+
+AC_DEFUN([GEOS_INIT],[
+  AC_SUBST(GEOS_LIBS)
+  AC_SUBST(GEOS_CFLAGS)
+  AC_SUBST(HAVE_GEOS)
+  AC_SUBST(GEOS_VERSION)
+
+  AC_ARG_WITH(geos,
+    AS_HELP_STRING([--with-geos[=ARG]],
+                   [Include GEOS support (ARG=yes, no or geos-config path)]),,)
+
+  ac_geos_config_auto=no
+
+  if test x"$with_geos" = x"no" ; then
+
+    AC_MSG_RESULT([GEOS support disabled])
+    GEOS_CONFIG=no
+    HAVE_GEOS=no
+
+  elif test x"$with_geos" = x"yes" -o x"$with_geos" = x"" ; then
+
+    AC_PATH_PROG(GEOS_CONFIG, geos-config, no)
+    if test x"$with_geos" = x"" ; then
+      ac_geos_config_auto=yes
+    fi
+
+  else
+
+   ac_geos_config=`basename "$with_geos"`
+   ac_geos_config_dir=`AS_DIRNAME(["$with_geos"])`
+
+   AC_CHECK_PROG(
+        GEOS_CONFIG,
+        "$ac_geos_config",
+        $with_geos,
+        [no],
+        ["$ac_geos_config_dir"],
+        []
+   )
+
+  fi
+
+  if test x"$GEOS_CONFIG" != x"no" ; then
+
+    min_geos_version=ifelse([$1], ,1.0.0,$1)
+
+    AC_MSG_CHECKING(for GEOS version >= $min_geos_version)
+
+    geos_major_version=`$GEOS_CONFIG --version | \
+       sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\).*/\1/'`
+    geos_minor_version=`$GEOS_CONFIG --version | \
+       sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\).*/\2/'`
+    geos_micro_version=`$GEOS_CONFIG --version | \
+       sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\).*/\3/'`
+
+    req_major=`echo $min_geos_version | \
+       sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\).*/\1/'`
+    req_minor=`echo $min_geos_version | \
+       sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\).*/\2/'`
+    req_micro=`echo $min_geos_version | \
+       sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\).*/\3/'`
+
+    version_ok="no"
+    ac_req_version=`expr $req_major \* 100000 \+  $req_minor \* 100 \+ $req_micro`
+    ac_geos_version=`expr $geos_major_version \* 100000 \+  $geos_minor_version \* 100 \+ $geos_micro_version`
+
+    if test $ac_req_version -le $ac_geos_version; then
+        version_ok="yes"
+        AC_MSG_RESULT([yes])
+    fi
+
+    if test $version_ok = "no"; then
+
+      HAVE_GEOS="no"
+      AC_MSG_RESULT(no)
+
+      if test $ac_geos_config_auto = "yes" ; then
+        AC_MSG_WARN([GEOS was found on your system, but geos-config reports version ${geos_major_version}.${geos_minor_version}.${geos_micro_version}, need at least $min_geos_version. GEOS support disabled.])
+      else
+        AC_MSG_ERROR([geos-config reports version ${geos_major_version}.${geos_minor_version}.${geos_micro_version}, need at least $min_geos_version or configure --without-geos])
+      fi
+
+    else
+
+      HAVE_GEOS="no"
+
+      GEOS_LIBS="`${GEOS_CONFIG} --static-clibs`"
+      GEOS_CFLAGS="`${GEOS_CONFIG} --cflags`"
+      GEOS_VERSION="`${GEOS_CONFIG} --version`"
+
+      ax_save_LIBS="${LIBS}"
+      LIBS=${GEOS_LIBS}
+      ax_save_CFLAGS="${CFLAGS}"
+      CFLAGS="${GEOS_CFLAGS} ${CFLAGS}"
+
+      AC_CHECK_LIB([geos_c],
+        [GEOSversion],
+        [HAVE_GEOS="yes"],
+        [HAVE_GEOS="no"],
+        []
+      )
+
+      if test x"$HAVE_GEOS" = "xno"; then
+        if test $ac_geos_config_auto = "yes" ; then
+          AC_MSG_WARN([GEOS was found on your system, but the library could not be linked. GEOS support disabled.])
+        else
+          AC_MSG_ERROR([GEOS library could not be linked])
+        fi
+
+        GEOS_CFLAGS=""
+
+      fi
+
+      CFLAGS="${ax_save_CFLAGS}"
+      LIBS="${ax_save_LIBS}"
+
+    fi
+
+  else
+
+    if test x"$with_geos" != x"no" -a x"$with_geos" != x ; then
+      AC_MSG_ERROR([GEOS support explicitly enabled, but geos-config could not be found])
+    fi
+
+  fi
+])
+
diff -Nru gdal-3.5.0-orig/ogr/ogrct.cpp.orig gdal-3.5.0-patched/ogr/ogrct.cpp.orig
--- gdal-3.5.0-orig/ogr/ogrct.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ gdal-3.5.0-patched/ogr/ogrct.cpp.orig	2022-09-14 04:26:13.032347514 -0400
@@ -0,0 +1,3459 @@
+/******************************************************************************
+ *
+ * Project:  OpenGIS Simple Features Reference Implementation
+ * Purpose:  The OGRSCoordinateTransformation class.
+ * Author:   Frank Warmerdam, warmerdam@pobox.com
+ *
+ ******************************************************************************
+ * Copyright (c) 2000, Frank Warmerdam
+ * Copyright (c) 2008-2013, Even Rouault <even dot rouault at spatialys.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ ****************************************************************************/
+
+#include "cpl_port.h"
+#include "ogr_spatialref.h"
+
+#include <algorithm>
+#include <cassert>
+#include <cmath>
+#include <cstring>
+#include <limits>
+#include <list>
+#include <mutex>
+
+#include "cpl_conv.h"
+#include "cpl_error.h"
+#include "cpl_mem_cache.h"
+#include "cpl_string.h"
+#include "ogr_core.h"
+#include "ogr_srs_api.h"
+#include "ogr_proj_p.h"
+
+#include "proj.h"
+#include "proj_experimental.h"
+
+CPL_CVSID("$Id$")
+
+#ifdef DEBUG_PERF
+static double g_dfTotalTimeCRStoCRS = 0;
+static double g_dfTotalTimeReprojection = 0;
+
+/************************************************************************/
+/*                        CPLGettimeofday()                             */
+/************************************************************************/
+
+#if defined(_WIN32) && !defined(__CYGWIN__)
+#  include <sys/timeb.h>
+
+namespace {
+struct CPLTimeVal
+{
+  time_t  tv_sec;         /* seconds */
+  long    tv_usec;        /* and microseconds */
+};
+}
+
+static void CPLGettimeofday(struct CPLTimeVal* tp, void* /* timezonep*/ )
+{
+  struct _timeb theTime;
+
+  _ftime(&theTime);
+  tp->tv_sec = static_cast<time_t>(theTime.time);
+  tp->tv_usec = theTime.millitm * 1000;
+}
+#else
+#  include <sys/time.h>     /* for gettimeofday() */
+#  define  CPLTimeVal timeval
+#  define  CPLGettimeofday(t,u) gettimeofday(t,u)
+#endif
+
+#endif // DEBUG_PERF
+
+// Cache of OGRProjCT objects
+static std::mutex g_oCTCacheMutex;
+class OGRProjCT;
+// We wrap a OGRProjCT in a shared_ptr<unique_ptr>, because we need a copyable
+// type to be inserted in the cache (shared_ptr), and we need to be able to
+// alter the content of the value to release() the unique_ptr value when we
+// find a value in it.
+typedef std::string CTCacheKey;
+typedef std::shared_ptr<std::unique_ptr<OGRProjCT>> CTCacheValue;
+static lru11::Cache<CTCacheKey, CTCacheValue>* g_poCTCache = nullptr;
+
+/************************************************************************/
+/*             OGRCoordinateTransformationOptions::Private              */
+/************************************************************************/
+
+struct OGRCoordinateTransformationOptions::Private
+{
+    bool bHasAreaOfInterest = false;
+    double dfWestLongitudeDeg = 0.0;
+    double dfSouthLatitudeDeg = 0.0;
+    double dfEastLongitudeDeg = 0.0;
+    double dfNorthLatitudeDeg = 0.0;
+
+    CPLString osCoordOperation{};
+    bool bReverseCO = false;
+
+    bool bAllowBallpark = true;
+    double dfAccuracy = -1; // no constraint
+
+    bool bHasSourceCenterLong = false;
+    double dfSourceCenterLong = 0.0;
+
+    bool bHasTargetCenterLong = false;
+    double dfTargetCenterLong = 0.0;
+
+    bool bCheckWithInvertProj = false;
+
+    Private();
+    Private(const Private&) = default;
+    Private(Private&&) = default;
+    Private& operator=(const Private&) = default;
+    Private& operator=(Private&&) = default;
+
+    std::string GetKey() const;
+    void RefreshCheckWithInvertProj();
+};
+
+/************************************************************************/
+/*                              Private()                               */
+/************************************************************************/
+
+OGRCoordinateTransformationOptions::Private::Private()
+{
+    RefreshCheckWithInvertProj();
+}
+
+/************************************************************************/
+/*                              GetKey()                                */
+/************************************************************************/
+
+std::string OGRCoordinateTransformationOptions::Private::GetKey() const
+{
+    std::string ret;
+    ret += std::to_string(static_cast<int>(bHasAreaOfInterest));
+    ret += std::to_string(dfWestLongitudeDeg);
+    ret += std::to_string(dfSouthLatitudeDeg);
+    ret += std::to_string(dfEastLongitudeDeg);
+    ret += std::to_string(dfNorthLatitudeDeg);
+    ret += osCoordOperation;
+    ret += std::to_string(static_cast<int>(bReverseCO));
+    ret += std::to_string(static_cast<int>(bAllowBallpark));
+    ret += std::to_string(dfAccuracy);
+    ret += std::to_string(static_cast<int>(bHasSourceCenterLong));
+    ret += std::to_string(dfSourceCenterLong);
+    ret += std::to_string(static_cast<int>(bHasTargetCenterLong));
+    ret += std::to_string(dfTargetCenterLong);
+    ret += std::to_string(static_cast<int>(bCheckWithInvertProj));
+    return ret;
+}
+
+/************************************************************************/
+/*                       RefreshCheckWithInvertProj()                   */
+/************************************************************************/
+
+void OGRCoordinateTransformationOptions::Private::RefreshCheckWithInvertProj()
+{
+    bCheckWithInvertProj =
+        CPLTestBool(CPLGetConfigOption( "CHECK_WITH_INVERT_PROJ", "NO" ));
+}
+
+/************************************************************************/
+/*                          GetWktOrProjString()                        */
+/************************************************************************/
+
+static char* GetWktOrProjString(const OGRSpatialReference* poSRS)
+{
+    CPLErrorStateBackuper oErrorStateBackuper;
+    CPLErrorHandlerPusher oErrorHandler(CPLQuietErrorHandler);
+    const char* const apszOptionsWKT2_2018[] = { "FORMAT=WKT2_2018", nullptr };
+    // If there's a PROJ4 EXTENSION node in WKT1, then use
+    // it. For example when dealing with "+proj=longlat +lon_wrap=180"
+    char* pszText = nullptr;
+    if( poSRS->GetExtension(nullptr, "PROJ4", nullptr) )
+    {
+        poSRS->exportToProj4(&pszText);
+        if (strstr(pszText, " +type=crs") == nullptr )
+        {
+            auto tmpText = std::string(pszText) + " +type=crs";
+            CPLFree(pszText);
+            pszText = CPLStrdup(tmpText.c_str());
+        }
+    }
+    else
+        poSRS->exportToWkt(&pszText, apszOptionsWKT2_2018);
+    return pszText;
+}
+
+/************************************************************************/
+/*                  OGRCoordinateTransformationOptions()                */
+/************************************************************************/
+
+/** \brief Constructs a new OGRCoordinateTransformationOptions.
+ *
+ * @since GDAL 3.0
+ */
+OGRCoordinateTransformationOptions::OGRCoordinateTransformationOptions():
+    d(new Private())
+{
+}
+
+/************************************************************************/
+/*                  OGRCoordinateTransformationOptions()                */
+/************************************************************************/
+
+/** \brief Copy constructor
+ *
+ * @since GDAL 3.1
+ */
+OGRCoordinateTransformationOptions::OGRCoordinateTransformationOptions(
+    const OGRCoordinateTransformationOptions& other):
+        d(new Private(*(other.d)))
+{}
+
+/************************************************************************/
+/*                          operator =()                                */
+/************************************************************************/
+
+/** \brief Assignment operator
+ *
+ * @since GDAL 3.1
+ */
+OGRCoordinateTransformationOptions&
+    OGRCoordinateTransformationOptions::operator= (const OGRCoordinateTransformationOptions& other)
+{
+    if( this != &other )
+    {
+        *d = *(other.d);
+    }
+    return *this;
+}
+
+/************************************************************************/
+/*                  OGRCoordinateTransformationOptions()                */
+/************************************************************************/
+
+/** \brief Destroys a OGRCoordinateTransformationOptions.
+ *
+ * @since GDAL 3.0
+ */
+OGRCoordinateTransformationOptions::~OGRCoordinateTransformationOptions()
+{
+}
+
+/************************************************************************/
+/*                   OCTNewCoordinateTransformationOptions()            */
+/************************************************************************/
+
+/** \brief Create coordinate transformation options.
+ *
+ * To be freed with OCTDestroyCoordinateTransformationOptions()
+ *
+ * @since GDAL 3.0
+ */
+OGRCoordinateTransformationOptionsH OCTNewCoordinateTransformationOptions(void)
+{
+    return new OGRCoordinateTransformationOptions();
+}
+
+/************************************************************************/
+/*                  OCTDestroyCoordinateTransformationOptions()         */
+/************************************************************************/
+
+/** \brief Destroy coordinate transformation options.
+ *
+ * @since GDAL 3.0
+ */
+void OCTDestroyCoordinateTransformationOptions(
+                            OGRCoordinateTransformationOptionsH hOptions)
+{
+    delete hOptions;
+}
+
+/************************************************************************/
+/*                        SetAreaOfInterest()                           */
+/************************************************************************/
+
+/** \brief Sets an area of interest.
+ *
+ * The west longitude is generally lower than the east longitude, except for
+ * areas of interest that go across the anti-meridian.
+ *
+ * @param dfWestLongitudeDeg West longitude (in degree). Must be in [-180,180]
+ * @param dfSouthLatitudeDeg South latitude (in degree). Must be in [-90,90]
+ * @param dfEastLongitudeDeg East longitude (in degree). Must be in [-180,180]
+ * @param dfNorthLatitudeDeg North latitude (in degree). Must be in [-90,90]
+ * @return true in case of success.
+ *
+ * @since GDAL 3.0
+ */
+bool OGRCoordinateTransformationOptions::SetAreaOfInterest(
+        double dfWestLongitudeDeg, double dfSouthLatitudeDeg,
+        double dfEastLongitudeDeg, double dfNorthLatitudeDeg)
+{
+    if( std::fabs(dfWestLongitudeDeg) > 180 )
+    {
+        CPLError(CE_Failure, CPLE_AppDefined, "Invalid dfWestLongitudeDeg");
+        return false;
+    }
+    if( std::fabs(dfSouthLatitudeDeg) > 90 )
+    {
+        CPLError(CE_Failure, CPLE_AppDefined, "Invalid dfSouthLatitudeDeg");
+        return false;
+    }
+    if( std::fabs(dfEastLongitudeDeg) > 180 )
+    {
+        CPLError(CE_Failure, CPLE_AppDefined, "Invalid dfEastLongitudeDeg");
+        return false;
+    }
+    if( std::fabs(dfNorthLatitudeDeg) > 90 )
+    {
+        CPLError(CE_Failure, CPLE_AppDefined, "Invalid dfNorthLatitudeDeg");
+        return false;
+    }
+    if( dfSouthLatitudeDeg > dfNorthLatitudeDeg )
+    {
+        CPLError(CE_Failure, CPLE_AppDefined,
+                 "dfSouthLatitudeDeg should be lower than dfNorthLatitudeDeg");
+        return false;
+    }
+    d->bHasAreaOfInterest = true;
+    d->dfWestLongitudeDeg = dfWestLongitudeDeg;
+    d->dfSouthLatitudeDeg = dfSouthLatitudeDeg;
+    d->dfEastLongitudeDeg = dfEastLongitudeDeg;
+    d->dfNorthLatitudeDeg = dfNorthLatitudeDeg;
+    return true;
+}
+
+/************************************************************************/
+/*           OCTCoordinateTransformationOptionsSetAreaOfInterest()      */
+/************************************************************************/
+
+/** \brief Sets an area of interest.
+ *
+ * See OGRCoordinateTransformationOptions::SetAreaOfInterest()
+ *
+ * @since GDAL 3.0
+ */
+int OCTCoordinateTransformationOptionsSetAreaOfInterest(
+    OGRCoordinateTransformationOptionsH hOptions,
+    double dfWestLongitudeDeg,
+    double dfSouthLatitudeDeg,
+    double dfEastLongitudeDeg,
+    double dfNorthLatitudeDeg)
+{
+    return hOptions->SetAreaOfInterest(
+        dfWestLongitudeDeg, dfSouthLatitudeDeg,
+        dfEastLongitudeDeg, dfNorthLatitudeDeg);
+}
+
+/************************************************************************/
+/*                        SetCoordinateOperation()                      */
+/************************************************************************/
+
+/** \brief Sets a coordinate operation.
+ *
+ * This is a user override to be used instead of the normally computed pipeline.
+ *
+ * The pipeline must take into account the axis order of the source and target
+ * SRS.
+ *
+ * The pipeline may be provided as a PROJ string (single step operation or
+ * multiple step string starting with +proj=pipeline), a WKT2 string describing
+ * a CoordinateOperation, or a "urn:ogc:def:coordinateOperation:EPSG::XXXX" URN
+ *
+ * @param pszCO PROJ or WKT string describing a coordinate operation
+ * @param bReverseCO Whether the PROJ or WKT string should be evaluated in the reverse path
+ * @return true in case of success.
+ *
+ * @since GDAL 3.0
+ */
+bool OGRCoordinateTransformationOptions::SetCoordinateOperation(const char* pszCO, bool bReverseCO)
+{
+    d->osCoordOperation = pszCO ? pszCO : "";
+    d->bReverseCO = bReverseCO;
+    return true;
+}
+
+/************************************************************************/
+/*                         SetSourceCenterLong()                        */
+/************************************************************************/
+
+/*! @cond Doxygen_Suppress */
+void OGRCoordinateTransformationOptions::SetSourceCenterLong(double dfCenterLong)
+{
+    d->dfSourceCenterLong = dfCenterLong;
+    d->bHasSourceCenterLong = true;
+}
+/*! @endcond */
+
+/************************************************************************/
+/*                         SetTargetCenterLong()                        */
+/************************************************************************/
+
+/*! @cond Doxygen_Suppress */
+void OGRCoordinateTransformationOptions::SetTargetCenterLong(double dfCenterLong)
+{
+    d->dfTargetCenterLong = dfCenterLong;
+    d->bHasTargetCenterLong = true;
+}
+/*! @endcond */
+
+/************************************************************************/
+/*            OCTCoordinateTransformationOptionsSetOperation()          */
+/************************************************************************/
+
+/** \brief Sets a coordinate operation.
+ *
+ * See OGRCoordinateTransformationOptions::SetCoordinateTransformation()
+ *
+ * @since GDAL 3.0
+ */
+int OCTCoordinateTransformationOptionsSetOperation(
+    OGRCoordinateTransformationOptionsH hOptions,
+    const char* pszCO, int bReverseCO)
+{
+    return hOptions->SetCoordinateOperation(pszCO, CPL_TO_BOOL(bReverseCO));
+}
+
+/************************************************************************/
+/*                         SetDesiredAccuracy()                         */
+/************************************************************************/
+
+/** \brief Sets the desired accuracy for coordinate operations.
+ *
+ * Only coordinate operations that offer an accuracy of at least the one
+ * specified will be considered.
+ *
+ * An accuracy of 0 is valid and means a coordinate operation made only of one or
+ * several conversions (map projections, unit conversion, etc.)
+ * Operations involving ballpark transformations have a unknown accuracy, and
+ * will be filtered out by any dfAccuracy >= 0 value.
+ *
+ * If this option is specified with PROJ < 8, the OGR_CT_OP_SELECTION configuration
+ * option will default to BEST_ACCURACY.
+ *
+ * @param dfAccuracy accuracy in meters (or a negative value to disable this filter)
+ *
+ * @since GDAL 3.3
+ */
+bool OGRCoordinateTransformationOptions::SetDesiredAccuracy(double dfAccuracy)
+{
+    d->dfAccuracy = dfAccuracy;
+    return true;
+}
+
+/************************************************************************/
+/*        OCTCoordinateTransformationOptionsSetDesiredAccuracy()        */
+/************************************************************************/
+
+/** \brief Sets the desired accuracy for coordinate operations.
+ *
+ * See OGRCoordinateTransformationOptions::SetDesiredAccuracy()
+ *
+ * @since GDAL 3.3
+ */
+int OCTCoordinateTransformationOptionsSetDesiredAccuracy(
+    OGRCoordinateTransformationOptionsH hOptions, double dfAccuracy)
+{
+    return hOptions->SetDesiredAccuracy(dfAccuracy);
+}
+
+/************************************************************************/
+/*                       SetBallparkAllowed()                           */
+/************************************************************************/
+
+/** \brief Sets whether ballpark transformations are allowed.
+ *
+ * By default, PROJ may generate "ballpark transformations" (see
+ * https://proj.org/glossary.html) when precise datum transformations are missing.
+ * For high accuracy use cases, such transformations might not be allowed.
+ *
+ * If this option is specified with PROJ < 8, the OGR_CT_OP_SELECTION configuration
+ * option will default to BEST_ACCURACY.
+ *
+ * @param bAllowBallpark false to disable the user of ballpark transformations
+ *
+ * @since GDAL 3.3
+ */
+bool OGRCoordinateTransformationOptions::SetBallparkAllowed(bool bAllowBallpark)
+{
+    d->bAllowBallpark = bAllowBallpark;
+    return true;
+}
+
+/************************************************************************/
+/*        OCTCoordinateTransformationOptionsSetBallparkAllowed()        */
+/************************************************************************/
+
+/** \brief Sets whether ballpark transformations are allowed.
+ *
+ * See OGRCoordinateTransformationOptions::SetDesiredAccuracy()
+ *
+ * @since GDAL 3.3 and PROJ 8
+ */
+int OCTCoordinateTransformationOptionsSetBallparkAllowed(
+    OGRCoordinateTransformationOptionsH hOptions, int bAllowBallpark)
+{
+    return hOptions->SetBallparkAllowed(CPL_TO_BOOL(bAllowBallpark));
+}
+
+
+/************************************************************************/
+/*                              OGRProjCT                               */
+/************************************************************************/
+
+//! @cond Doxygen_Suppress
+class OGRProjCT : public OGRCoordinateTransformation
+{
+    class PjPtr
+    {
+        PJ* m_pj = nullptr;
+        void reset()
+        {
+            if( m_pj )
+            {
+                proj_assign_context(m_pj, OSRGetProjTLSContext());
+                proj_destroy(m_pj);
+            }
+        }
+    public:
+        PjPtr() : m_pj(nullptr){}
+        explicit PjPtr(PJ* pjIn) : m_pj(pjIn){}
+        ~PjPtr()
+        {
+            reset();
+        }
+        PjPtr(const PjPtr& other) :
+            m_pj((other.m_pj != nullptr) ?
+                 (proj_clone(OSRGetProjTLSContext(), other.m_pj)) :
+                 (nullptr))
+        {}
+        PjPtr(PjPtr&& other) :
+            m_pj(other.m_pj)
+        {
+            other.m_pj = nullptr;
+        }
+        PjPtr& operator=(const PjPtr& other)
+        {
+            if(this != &other)
+            {
+                reset();
+                m_pj = (other.m_pj != nullptr) ?
+                       (proj_clone(OSRGetProjTLSContext(), other.m_pj)) :
+                       (nullptr);
+            }
+            return *this;
+        }
+        PjPtr& operator=(PJ* pjIn)
+        {
+            if(m_pj != pjIn)
+            {
+                reset();
+                m_pj = pjIn;
+            }
+            return *this;
+        }
+        operator PJ* () { return m_pj; }
+        operator const PJ* () const{ return m_pj; }
+    };
+
+    OGRSpatialReference *poSRSSource = nullptr;
+    bool        bSourceLatLong = false;
+    bool        bSourceWrap = false;
+    double      dfSourceWrapLong = 0.0;
+    bool        bSourceIsDynamicCRS = false;
+    double      dfSourceCoordinateEpoch = 0.0;
+
+    OGRSpatialReference *poSRSTarget = nullptr;
+    bool        bTargetLatLong = false;
+    bool        bTargetWrap = false;
+    double      dfTargetWrapLong = 0.0;
+    bool        bTargetIsDynamicCRS = false;
+    double      dfTargetCoordinateEpoch = 0.0;
+
+    bool        bWebMercatorToWGS84LongLat = false;
+
+    int         nErrorCount = 0;
+
+    double      dfThreshold = 0.0;
+
+    PjPtr       m_pj{};
+    bool        m_bReversePj = false;
+
+    bool        m_bEmitErrors = true;
+
+    bool        bNoTransform = false;
+
+    enum class Strategy
+    {
+        PROJ,
+        BEST_ACCURACY,
+        FIRST_MATCHING
+    };
+#if PROJ_VERSION_MAJOR > 6 || PROJ_VERSION_MINOR >= 3
+    Strategy    m_eStrategy = Strategy::PROJ;
+#else
+    Strategy    m_eStrategy = Strategy::BEST_ACCURACY;
+#endif
+
+    bool        ListCoordinateOperations(const char* pszSrcSRS,
+                                         const char* pszTargetSRS,
+                                         const OGRCoordinateTransformationOptions& options );
+    struct Transformation
+    {
+        double minx = 0.0;
+        double miny = 0.0;
+        double maxx = 0.0;
+        double maxy = 0.0;
+        PjPtr  pj{};
+        CPLString osName{};
+        CPLString osProjString{};
+        double accuracy = 0.0;
+
+        Transformation(double minxIn, double minyIn, double maxxIn, double maxyIn,
+                       PJ* pjIn,
+                       const CPLString& osNameIn,
+                       const CPLString& osProjStringIn,
+                       double accuracyIn):
+            minx(minxIn), miny(minyIn), maxx(maxxIn), maxy(maxyIn),
+            pj(pjIn), osName(osNameIn), osProjString(osProjStringIn),
+            accuracy(accuracyIn) {}
+    };
+    std::vector<Transformation> m_oTransformations{};
+    int m_iCurTransformation = -1;
+    OGRCoordinateTransformationOptions m_options{};
+
+    void ComputeThreshold();
+
+    OGRProjCT(const OGRProjCT& other);
+    OGRProjCT& operator= (const OGRProjCT& ) = delete;
+
+    static CTCacheKey MakeCacheKey(const OGRSpatialReference* poSRS1,
+                           const OGRSpatialReference* poSRS2,
+                           const OGRCoordinateTransformationOptions& options);
+    bool ContainsNorthPole(
+        const double xmin,
+        const double ymin,
+        const double xmax,
+        const double ymax,
+        bool lon_lat_order
+    );
+    bool ContainsSouthPole(
+        const double xmin,
+        const double ymin,
+        const double xmax,
+        const double ymax,
+        bool lon_lat_order
+    );
+public:
+    OGRProjCT();
+    ~OGRProjCT() override;
+
+    int         Initialize( const OGRSpatialReference *poSource,
+                            const OGRSpatialReference *poTarget,
+                            const OGRCoordinateTransformationOptions& options );
+
+    OGRSpatialReference *GetSourceCS() override;
+    OGRSpatialReference *GetTargetCS() override;
+
+    int Transform( int nCount,
+                             double *x, double *y, double *z, double *t,
+                             int *pabSuccess ) override;
+
+    int TransformWithErrorCodes( int nCount,
+                             double *x, double *y, double *z, double *t,
+                             int *panErrorCodes ) override;
+
+    int TransformBounds( const double xmin,
+                         const double ymin,
+                         const double xmax,
+                         const double ymax,
+                         double* out_xmin,
+                         double* out_ymin,
+                         double* out_xmax,
+                         double* out_ymax,
+                         const int densify_pts ) override;
+
+    bool GetEmitErrors() const override { return m_bEmitErrors; }
+    void SetEmitErrors( bool bEmitErrors ) override
+        { m_bEmitErrors = bEmitErrors; }
+
+    OGRCoordinateTransformation* Clone() const override;
+
+    OGRCoordinateTransformation* GetInverse() const override;
+
+    static void InsertIntoCache( OGRProjCT* poCT );
+
+    static OGRProjCT* FindFromCache( const OGRSpatialReference *poSource,
+                                     const OGRSpatialReference *poTarget,
+                                     const OGRCoordinateTransformationOptions& options );
+};
+//! @endcond
+
+/************************************************************************/
+/*                 OCTDestroyCoordinateTransformation()                 */
+/************************************************************************/
+
+/**
+ * \brief OGRCoordinateTransformation destructor.
+ *
+ * This function is the same as OGRCoordinateTransformation::DestroyCT()
+ *
+ * @param hCT the object to delete
+ */
+
+void CPL_STDCALL
+OCTDestroyCoordinateTransformation( OGRCoordinateTransformationH hCT )
+
+{
+    OGRCoordinateTransformation::DestroyCT(
+        OGRCoordinateTransformation::FromHandle(hCT));
+}
+
+/************************************************************************/
+/*                             DestroyCT()                              */
+/************************************************************************/
+
+/**
+ * \brief OGRCoordinateTransformation destructor.
+ *
+ * This function is the same as
+ * OGRCoordinateTransformation::~OGRCoordinateTransformation()
+ * and OCTDestroyCoordinateTransformation()
+ *
+ * This static method will destroy a OGRCoordinateTransformation.  It is
+ * equivalent to calling delete on the object, but it ensures that the
+ * deallocation is properly executed within the OGR libraries heap on
+ * platforms where this can matter (win32).
+ *
+ * @param poCT the object to delete
+ *
+ * @since GDAL 1.7.0
+ */
+
+void OGRCoordinateTransformation::DestroyCT( OGRCoordinateTransformation* poCT )
+{
+    auto poProjCT = dynamic_cast<OGRProjCT*>(poCT);
+    if( poProjCT )
+    {
+        OGRProjCT::InsertIntoCache(poProjCT);
+    }
+    else
+    {
+        delete poCT;
+    }
+}
+
+/************************************************************************/
+/*                 OGRCreateCoordinateTransformation()                  */
+/************************************************************************/
+
+/**
+ * Create transformation object.
+ *
+ * This is the same as the C function OCTNewCoordinateTransformation().
+ *
+ * Input spatial reference system objects are assigned
+ * by copy (calling clone() method) and no ownership transfer occurs.
+ *
+ * The delete operator, or OCTDestroyCoordinateTransformation() should
+ * be used to destroy transformation objects.
+ *
+ * This will honour the axis order advertized by the source and target SRS,
+ * as well as their "data axis to SRS axis mapping".
+ * To have a behavior similar to GDAL &lt; 3.0, the OGR_CT_FORCE_TRADITIONAL_GIS_ORDER
+ * configuration option can be set to YES.
+ *
+ * @param poSource source spatial reference system.
+ * @param poTarget target spatial reference system.
+ * @return NULL on failure or a ready to use transformation object.
+ */
+
+OGRCoordinateTransformation*
+OGRCreateCoordinateTransformation( const OGRSpatialReference *poSource,
+                                   const OGRSpatialReference *poTarget )
+
+{
+    return OGRCreateCoordinateTransformation(
+        poSource, poTarget, OGRCoordinateTransformationOptions());
+}
+
+/**
+ * Create transformation object.
+ *
+ * This is the same as the C function OCTNewCoordinateTransformationEx().
+ *
+ * Input spatial reference system objects are assigned
+ * by copy (calling clone() method) and no ownership transfer occurs.
+ *
+ * The delete operator, or OCTDestroyCoordinateTransformation() should
+ * be used to destroy transformation objects.
+ *
+ * This will honour the axis order advertized by the source and target SRS,
+ * as well as their "data axis to SRS axis mapping".
+ * To have a behavior similar to GDAL &lt; 3.0, the OGR_CT_FORCE_TRADITIONAL_GIS_ORDER
+ * configuration option can be set to YES.
+ *
+ * The source SRS and target SRS should generally not be NULL. This is only
+ * allowed if a custom coordinate operation is set through the hOptions argument.
+ *
+ * Starting with GDAL 3.0.3, the OGR_CT_OP_SELECTION configuration option can be
+ * set to PROJ (default if PROJ >= 6.3), BEST_ACCURACY or FIRST_MATCHING to decide
+ * of the strategy to select the operation to use among candidates, whose area of
+ * use is compatible with the points to transform. It is only taken into account
+ * if no user defined coordinate transformation pipeline has been specified.
+ * <ul>
+ * <li>PROJ means the default behavior used by PROJ proj_create_crs_to_crs().
+ *     In particular the operation to use among several initial candidates is
+ *     evaluated for each point to transform.</li>
+ * <li>BEST_ACCURACY means the operation whose accuracy is best. It should be
+ *     close to PROJ behavior, except that the operation to select is decided
+ *     for the average point of the coordinates passed in a single Transform() call.
+ *     Note: if the OGRCoordinateTransformationOptions::SetDesiredAccuracy() or
+ *     OGRCoordinateTransformationOptions::SetBallparkAllowed() methods are called
+ *     with PROJ < 8, this strategy will be selected instead of PROJ.
+ * </li>
+ * <li>FIRST_MATCHING is the operation ordered first in the list of candidates:
+ *     it will not necessarily have the best accuracy, but generally a larger area of
+ *     use.  It is evaluated for the average point of the coordinates passed in a
+ *     single Transform() call. This was the default behavior for GDAL 3.0.0 to
+ *     3.0.2</li>
+ * </ul>
+ *
+ * By default, if the source or target SRS definition refers to an official
+ * CRS through a code, GDAL will use the official definition if the official
+ * definition and the source/target SRS definition are equivalent. Note that TOWGS84[]
+ * clauses are ignored when checking equivalence. Starting with GDAL 3.4.1, if
+ * you set the OGR_CT_PREFER_OFFICIAL_SRS_DEF configuration option to NO,
+ * the source or target SRS definition will be always used.
+ *
+ * If options contains a user defined coordinate transformation pipeline, it
+ * will be unconditionally used.
+ * If options has an area of interest defined, it will be used to research the
+ * best fitting coordinate transformation (which will be used for all coordinate
+ * transformations, even if they don't fall into the declared area of interest)
+ * If no options are set, then a list of candidate coordinate operations will be
+ * researched, and at each call to Transform(), the best of those candidate
+ * regarding the centroid of the coordinate set will be dynamically selected.
+ *
+ * @param poSource source spatial reference system.
+ * @param poTarget target spatial reference system.
+ * @param options Coordinate transformation options.
+ * @return NULL on failure or a ready to use transformation object.
+ * @since GDAL 3.0
+ */
+
+OGRCoordinateTransformation*
+OGRCreateCoordinateTransformation( const OGRSpatialReference *poSource,
+                                   const OGRSpatialReference *poTarget,
+                                   const OGRCoordinateTransformationOptions& options )
+
+{
+    // Try to find if we have a match in the case
+    auto poCTFromCache = OGRProjCT::FindFromCache(poSource, poTarget, options);
+    if( poCTFromCache )
+        return poCTFromCache;
+
+    OGRProjCT *poCT = new OGRProjCT();
+
+    if( !poCT->Initialize( poSource, poTarget, options ) )
+    {
+        delete poCT;
+        return nullptr;
+    }
+
+    return poCT;
+}
+
+/************************************************************************/
+/*                   OCTNewCoordinateTransformation()                   */
+/************************************************************************/
+
+/**
+ * Create transformation object.
+ *
+ * This is the same as the C++ function OGRCreateCoordinateTransformation(const OGRSpatialReference *, const OGRSpatialReference *)
+ *
+ * Input spatial reference system objects are assigned
+ * by copy (calling clone() method) and no ownership transfer occurs.
+ *
+ * OCTDestroyCoordinateTransformation() should
+ * be used to destroy transformation objects.
+ *
+ * This will honour the axis order advertized by the source and target SRS,
+ * as well as their "data axis to SRS axis mapping".
+ * To have a behavior similar to GDAL &lt; 3.0, the OGR_CT_FORCE_TRADITIONAL_GIS_ORDER
+ * configuration option can be set to YES.
+ *
+ * @param hSourceSRS source spatial reference system.
+ * @param hTargetSRS target spatial reference system.
+ * @return NULL on failure or a ready to use transformation object.
+ */
+
+OGRCoordinateTransformationH CPL_STDCALL
+OCTNewCoordinateTransformation(
+    OGRSpatialReferenceH hSourceSRS, OGRSpatialReferenceH hTargetSRS )
+
+{
+    return reinterpret_cast<OGRCoordinateTransformationH>(
+        OGRCreateCoordinateTransformation(
+            reinterpret_cast<OGRSpatialReference *>(hSourceSRS),
+            reinterpret_cast<OGRSpatialReference *>(hTargetSRS)));
+}
+
+/************************************************************************/
+/*                   OCTNewCoordinateTransformationEx()                 */
+/************************************************************************/
+
+/**
+ * Create transformation object.
+ *
+ * This is the same as the C++ function OGRCreateCoordinateTransformation(const OGRSpatialReference *, const OGRSpatialReference *, const OGRCoordinateTransformationOptions& )
+ *
+ * Input spatial reference system objects are assigned
+ * by copy (calling clone() method) and no ownership transfer occurs.
+ *
+ * OCTDestroyCoordinateTransformation() should
+ * be used to destroy transformation objects.
+ *
+ * The source SRS and target SRS should generally not be NULL. This is only
+ * allowed if a custom coordinate operation is set through the hOptions argument.
+ *
+ * This will honour the axis order advertized by the source and target SRS,
+ * as well as their "data axis to SRS axis mapping".
+ * To have a behavior similar to GDAL &lt; 3.0, the OGR_CT_FORCE_TRADITIONAL_GIS_ORDER
+ * configuration option can be set to YES.
+ *
+ * If options contains a user defined coordinate transformation pipeline, it
+ * will be unconditionally used.
+ * If options has an area of interest defined, it will be used to research the
+ * best fitting coordinate transformation (which will be used for all coordinate
+ * transformations, even if they don't fall into the declared area of interest)
+ * If no options are set, then a list of candidate coordinate operations will be
+ * researched, and at each call to Transform(), the best of those candidate
+ * regarding the centroid of the coordinate set will be dynamically selected.
+ *
+ * @param hSourceSRS source spatial reference system.
+ * @param hTargetSRS target spatial reference system.
+ * @param hOptions Coordinate transformation options.
+ * @return NULL on failure or a ready to use transformation object.
+ * @since GDAL 3.0
+ */
+
+OGRCoordinateTransformationH
+OCTNewCoordinateTransformationEx(
+    OGRSpatialReferenceH hSourceSRS, OGRSpatialReferenceH hTargetSRS,
+    OGRCoordinateTransformationOptionsH hOptions)
+
+{
+    return reinterpret_cast<OGRCoordinateTransformationH>(
+        OGRCreateCoordinateTransformation(
+            reinterpret_cast<OGRSpatialReference *>(hSourceSRS),
+            reinterpret_cast<OGRSpatialReference *>(hTargetSRS),
+            hOptions ? *hOptions : OGRCoordinateTransformationOptions()));
+}
+
+/************************************************************************/
+/*                              OCTClone()                              */
+/************************************************************************/
+
+/**
+ * Clone transformation object.
+ *
+ * This is the same as the C++ function OGRCreateCoordinateTransformation::Clone
+ *
+ * @return handle to transformation's clone or NULL on error,
+ *         must be freed with OCTDestroyCoordinateTransformation
+ *
+ * @since GDAL 3.4
+ */
+
+OGRCoordinateTransformationH
+OCTClone(OGRCoordinateTransformationH hTransform)
+
+{
+    VALIDATE_POINTER1( hTransform, "OCTClone", nullptr );
+    return OGRCoordinateTransformation::ToHandle(
+        OGRCoordinateTransformation::FromHandle(hTransform)->Clone());
+}
+
+/************************************************************************/
+/*                             OCTGetSourceCS()                         */
+/************************************************************************/
+
+/**
+ * Transformation's source coordinate system reference.
+ *
+ * This is the same as the C++ function OGRCreateCoordinateTransformation::GetSourceCS
+ *
+ * @return handle to transformation's source coordinate system or NULL if not present.
+ *
+ * The ownership of the returned CS belongs to the transformation object.
+ *
+ * @since GDAL 3.4
+ */
+
+OGRSpatialReferenceH OCTGetSourceCS(OGRCoordinateTransformationH hTransform)
+
+{
+    VALIDATE_POINTER1( hTransform, "OCTGetSourceCS", nullptr );
+    return OGRSpatialReference::ToHandle(
+        OGRCoordinateTransformation::FromHandle(hTransform)->GetSourceCS());
+}
+
+/************************************************************************/
+/*                             OCTGetTargetCS()                         */
+/************************************************************************/
+
+/**
+ * Transformation's target coordinate system reference.
+ *
+ * This is the same as the C++ function OGRCreateCoordinateTransformation::GetTargetCS
+ *
+ * @return handle to transformation's target coordinate system or NULL if not present.
+ *
+ * The ownership of the returned CS belongs to the transformation object.
+ *
+ * @since GDAL 3.4
+ */
+
+OGRSpatialReferenceH OCTGetTargetCS(OGRCoordinateTransformationH hTransform)
+
+{
+    VALIDATE_POINTER1( hTransform, "OCTGetTargetCS", nullptr );
+    return OGRSpatialReference::ToHandle(
+        OGRCoordinateTransformation::FromHandle(hTransform)->GetTargetCS());
+}
+
+/************************************************************************/
+/*                             OCTGetInverse()                          */
+/************************************************************************/
+
+/**
+ * Inverse transformation object.
+ *
+ * This is the same as the C++ function OGRCreateCoordinateTransformation::GetInverse
+ *
+ * @return handle to inverse transformation or NULL on error,
+ *         must be freed with OCTDestroyCoordinateTransformation
+ *
+ * @since GDAL 3.4
+ */
+
+OGRCoordinateTransformationH CPL_DLL OCTGetInverse(OGRCoordinateTransformationH hTransform)
+
+{
+    VALIDATE_POINTER1( hTransform, "OCTGetInverse", nullptr );
+    return OGRCoordinateTransformation::ToHandle(
+        OGRCoordinateTransformation::FromHandle(hTransform)->GetInverse());
+}
+
+/************************************************************************/
+/*                             OGRProjCT()                             */
+/************************************************************************/
+
+//! @cond Doxygen_Suppress
+OGRProjCT::OGRProjCT()
+{
+}
+
+/************************************************************************/
+/*                  OGRProjCT(const OGRProjCT& other)                   */
+/************************************************************************/
+
+OGRProjCT::OGRProjCT(const OGRProjCT& other) :
+    poSRSSource((other.poSRSSource != nullptr) ? (other.poSRSSource->Clone()) : (nullptr)),
+    bSourceLatLong(other.bSourceLatLong),
+    bSourceWrap(other.bSourceWrap),
+    dfSourceWrapLong(other.dfSourceWrapLong),
+    bSourceIsDynamicCRS(other.bSourceIsDynamicCRS),
+    dfSourceCoordinateEpoch(other.dfSourceCoordinateEpoch),
+    poSRSTarget((other.poSRSTarget != nullptr) ? (other.poSRSTarget->Clone()) : (nullptr)),
+    bTargetLatLong(other.bTargetLatLong),
+    bTargetWrap(other.bTargetWrap),
+    dfTargetWrapLong(other.dfTargetWrapLong),
+    bTargetIsDynamicCRS(other.bTargetIsDynamicCRS),
+    dfTargetCoordinateEpoch(other.dfTargetCoordinateEpoch),
+    bWebMercatorToWGS84LongLat(other.bWebMercatorToWGS84LongLat),
+    nErrorCount(other.nErrorCount),
+    dfThreshold(other.dfThreshold),
+    m_pj(other.m_pj),
+    m_bReversePj(other.m_bReversePj),
+    m_bEmitErrors(other.m_bEmitErrors),
+    bNoTransform(other.bNoTransform),
+    m_eStrategy(other.m_eStrategy),
+    m_oTransformations(other.m_oTransformations),
+    m_iCurTransformation(other.m_iCurTransformation),
+    m_options(other.m_options)
+{
+}
+
+/************************************************************************/
+/*                            ~OGRProjCT()                             */
+/************************************************************************/
+
+OGRProjCT::~OGRProjCT()
+
+{
+    if( poSRSSource != nullptr )
+    {
+        poSRSSource->Release();
+    }
+
+    if( poSRSTarget != nullptr )
+    {
+        poSRSTarget->Release();
+    }
+}
+
+/************************************************************************/
+/*                          ComputeThreshold()                          */
+/************************************************************************/
+
+void OGRProjCT::ComputeThreshold()
+{
+    // The threshold is experimental. Works well with the cases of ticket #2305.
+    if( bSourceLatLong )
+    {
+        // coverity[tainted_data]
+        dfThreshold = CPLAtof(CPLGetConfigOption( "THRESHOLD", ".1" ));
+    }
+    else
+    {
+        // 1 works well for most projections, except for +proj=aeqd that
+        // requires a tolerance of 10000.
+        // coverity[tainted_data]
+        dfThreshold = CPLAtof(CPLGetConfigOption( "THRESHOLD", "10000" ));
+    }
+}
+
+/************************************************************************/
+/*                             Initialize()                             */
+/************************************************************************/
+
+int OGRProjCT::Initialize( const OGRSpatialReference * poSourceIn,
+                           const OGRSpatialReference * poTargetIn,
+                           const OGRCoordinateTransformationOptions& options )
+
+{
+    m_options = options;
+
+    if( poSourceIn == nullptr || poTargetIn == nullptr )
+    {
+        if( options.d->osCoordOperation.empty() )
+        {
+            CPLError(CE_Failure, CPLE_AppDefined,
+                     "OGRProjCT::Initialize(): if source and/or target CRS "
+                     "are null, a coordinate operation must be specified");
+            return FALSE;
+        }
+    }
+
+    if( poSourceIn )
+        poSRSSource = poSourceIn->Clone();
+    if( poTargetIn )
+        poSRSTarget = poTargetIn->Clone();
+
+    // To easy quick&dirty compatibility with GDAL < 3.0
+    if( CPLTestBool(CPLGetConfigOption("OGR_CT_FORCE_TRADITIONAL_GIS_ORDER", "NO")) )
+    {
+        if( poSRSSource )
+            poSRSSource->SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);
+        if( poSRSTarget )
+            poSRSTarget->SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);
+    }
+
+    if( poSRSSource )
+    {
+        bSourceLatLong = CPL_TO_BOOL(poSRSSource->IsGeographic());
+        bSourceIsDynamicCRS = poSRSSource->IsDynamic();
+        dfSourceCoordinateEpoch = poSRSSource->GetCoordinateEpoch();
+    }
+    if( poSRSTarget )
+    {
+        bTargetLatLong = CPL_TO_BOOL(poSRSTarget->IsGeographic());
+        bTargetIsDynamicCRS = poSRSTarget->IsDynamic();
+        dfTargetCoordinateEpoch = poSRSTarget->GetCoordinateEpoch();
+    }
+
+    if( bSourceIsDynamicCRS && bTargetIsDynamicCRS &&
+        dfSourceCoordinateEpoch > 0 && dfTargetCoordinateEpoch > 0 &&
+        dfSourceCoordinateEpoch != dfTargetCoordinateEpoch )
+    {
+        CPLError(CE_Warning, CPLE_AppDefined,
+                 "Coordinate transformation between different epochs are "
+                 "not currently supported");
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Setup source and target translations to radians for lat/long    */
+/*      systems.                                                        */
+/* -------------------------------------------------------------------- */
+    bSourceWrap = false;
+    dfSourceWrapLong = 0.0;
+
+    bTargetWrap = false;
+    dfTargetWrapLong = 0.0;
+
+/* -------------------------------------------------------------------- */
+/*      Preliminary logic to setup wrapping.                            */
+/* -------------------------------------------------------------------- */
+    if( CPLGetConfigOption( "CENTER_LONG", nullptr ) != nullptr )
+    {
+        bSourceWrap = true;
+        bTargetWrap = true;
+        // coverity[tainted_data]
+        dfSourceWrapLong = dfTargetWrapLong =
+            CPLAtof(CPLGetConfigOption( "CENTER_LONG", "" ));
+        CPLDebug( "OGRCT", "Wrap at %g.", dfSourceWrapLong );
+    }
+
+    const char *pszCENTER_LONG;
+    {
+        CPLErrorStateBackuper oErrorStateBackuper;
+        CPLErrorHandlerPusher oErrorHandler(CPLQuietErrorHandler);
+        pszCENTER_LONG =
+            poSRSSource ? poSRSSource->GetExtension( "GEOGCS", "CENTER_LONG" ) : nullptr;
+    }
+    if( pszCENTER_LONG != nullptr )
+    {
+        dfSourceWrapLong = CPLAtof(pszCENTER_LONG);
+        bSourceWrap = true;
+        CPLDebug( "OGRCT", "Wrap source at %g.", dfSourceWrapLong );
+    }
+    else if( bSourceLatLong && options.d->bHasSourceCenterLong)
+    {
+        dfSourceWrapLong = options.d->dfSourceCenterLong;
+        bSourceWrap = true;
+        CPLDebug( "OGRCT", "Wrap source at %g.", dfSourceWrapLong );
+    }
+
+    {
+        CPLErrorStateBackuper oErrorStateBackuper;
+        CPLErrorHandlerPusher oErrorHandler(CPLQuietErrorHandler);
+        pszCENTER_LONG = poSRSTarget ?
+            poSRSTarget->GetExtension( "GEOGCS", "CENTER_LONG" ) : nullptr;
+    }
+    if( pszCENTER_LONG != nullptr )
+    {
+        dfTargetWrapLong = CPLAtof(pszCENTER_LONG);
+        bTargetWrap = true;
+        CPLDebug( "OGRCT", "Wrap target at %g.", dfTargetWrapLong );
+    }
+    else if( bTargetLatLong && options.d->bHasTargetCenterLong)
+    {
+        dfTargetWrapLong = options.d->dfTargetCenterLong;
+        bTargetWrap = true;
+        CPLDebug( "OGRCT", "Wrap target at %g.", dfTargetWrapLong );
+    }
+
+    ComputeThreshold();
+
+    // Detect webmercator to WGS84
+    OGRAxisOrientation orientAxis0, orientAxis1;
+    if( options.d->osCoordOperation.empty() &&
+        poSRSSource && poSRSTarget &&
+        poSRSSource->IsProjected() && poSRSTarget->IsGeographic() &&
+        poSRSTarget->GetAxis(nullptr, 0, &orientAxis0) != nullptr &&
+        poSRSTarget->GetAxis(nullptr, 1, &orientAxis1) != nullptr &&
+        ((orientAxis0 == OAO_North && orientAxis1 == OAO_East &&
+          poSRSTarget->GetDataAxisToSRSAxisMapping() == std::vector<int>{2,1}) ||
+         (orientAxis0 == OAO_East && orientAxis1 == OAO_North &&
+          poSRSTarget->GetDataAxisToSRSAxisMapping() == std::vector<int>{1,2})) )
+    {
+        CPLPushErrorHandler(CPLQuietErrorHandler);
+        char *pszSrcProj4Defn = nullptr;
+        poSRSSource->exportToProj4( &pszSrcProj4Defn );
+
+        char *pszDstProj4Defn = nullptr;
+        poSRSTarget->exportToProj4( &pszDstProj4Defn );
+        CPLPopErrorHandler();
+
+        if( pszSrcProj4Defn && pszDstProj4Defn )
+        {
+            if( pszSrcProj4Defn[0] != '\0' &&
+                pszSrcProj4Defn[strlen(pszSrcProj4Defn)-1] == ' ' )
+                pszSrcProj4Defn[strlen(pszSrcProj4Defn)-1] = 0;
+            if( pszDstProj4Defn[0] != '\0' &&
+                pszDstProj4Defn[strlen(pszDstProj4Defn)-1] == ' ' )
+                pszDstProj4Defn[strlen(pszDstProj4Defn)-1] = 0;
+            char* pszNeedle = strstr(pszSrcProj4Defn, "  ");
+            if( pszNeedle )
+                memmove(pszNeedle, pszNeedle + 1, strlen(pszNeedle + 1)+1);
+            pszNeedle = strstr(pszDstProj4Defn, "  ");
+            if( pszNeedle )
+                memmove(pszNeedle, pszNeedle + 1, strlen(pszNeedle + 1)+1);
+
+            if( (strstr(pszDstProj4Defn, "+datum=WGS84") != nullptr ||
+                strstr(pszDstProj4Defn,
+                        "+ellps=WGS84 +towgs84=0,0,0,0,0,0,0 ") != nullptr) &&
+                strstr(pszSrcProj4Defn, "+nadgrids=@null ") != nullptr &&
+                strstr(pszSrcProj4Defn, "+towgs84") == nullptr )
+            {
+                char* pszDst = strstr(pszDstProj4Defn, "+towgs84=0,0,0,0,0,0,0 ");
+                if( pszDst != nullptr)
+                {
+                    char* pszSrc = pszDst + strlen("+towgs84=0,0,0,0,0,0,0 ");
+                    memmove(pszDst, pszSrc, strlen(pszSrc)+1);
+                }
+                else
+                {
+                    memcpy(strstr(pszDstProj4Defn, "+datum=WGS84"), "+ellps", 6);
+                }
+
+                pszDst = strstr(pszSrcProj4Defn, "+nadgrids=@null ");
+                char* pszSrc = pszDst + strlen("+nadgrids=@null ");
+                memmove(pszDst, pszSrc, strlen(pszSrc)+1);
+
+                pszDst = strstr(pszSrcProj4Defn, "+wktext ");
+                if( pszDst )
+                {
+                    pszSrc = pszDst + strlen("+wktext ");
+                    memmove(pszDst, pszSrc, strlen(pszSrc)+1);
+                }
+                bWebMercatorToWGS84LongLat =
+                    strcmp(pszDstProj4Defn,
+                        "+proj=longlat +ellps=WGS84 +no_defs") == 0 &&
+                    (strcmp(pszSrcProj4Defn,
+                        "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 "
+                        "+x_0=0.0 +y_0=0 +k=1.0 +units=m +no_defs") == 0 ||
+                    strcmp(pszSrcProj4Defn,
+                        "+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 "
+                        "+x_0=0 +y_0=0 +k=1 +units=m +no_defs") == 0);
+            }
+        }
+
+        CPLFree(pszSrcProj4Defn);
+        CPLFree(pszDstProj4Defn);
+    }
+
+    const char* pszCTOpSelection = CPLGetConfigOption("OGR_CT_OP_SELECTION", nullptr);
+    if( pszCTOpSelection )
+    {
+        if( EQUAL(pszCTOpSelection, "PROJ") )
+            m_eStrategy = Strategy::PROJ;
+        else if( EQUAL(pszCTOpSelection, "BEST_ACCURACY") )
+            m_eStrategy = Strategy::BEST_ACCURACY;
+        else if( EQUAL(pszCTOpSelection, "FIRST_MATCHING") )
+            m_eStrategy = Strategy::FIRST_MATCHING;
+        else
+            CPLError(CE_Warning, CPLE_NotSupported,
+                     "OGR_CT_OP_SELECTION=%s not supported", pszCTOpSelection);
+    }
+#if PROJ_VERSION_MAJOR < 8
+    else
+    {
+        if( options.d->dfAccuracy >= 0 || !options.d->bAllowBallpark )
+        {
+            m_eStrategy = Strategy::BEST_ACCURACY;
+        }
+    }
+#endif
+    if( m_eStrategy == Strategy::PROJ )
+    {
+        const char* pszUseApproxTMERC = CPLGetConfigOption("OSR_USE_APPROX_TMERC", nullptr);
+        if( pszUseApproxTMERC && CPLTestBool(pszUseApproxTMERC) )
+        {
+            CPLDebug("OSRCT", "Using OGR_CT_OP_SELECTION=BEST_ACCURACY as OSR_USE_APPROX_TMERC is set");
+            m_eStrategy = Strategy::BEST_ACCURACY;
+        }
+    }
+
+    if( !options.d->osCoordOperation.empty() )
+    {
+        auto ctx = OSRGetProjTLSContext();
+        m_pj = proj_create(ctx, options.d->osCoordOperation);
+        if( !m_pj )
+        {
+            CPLError( CE_Failure, CPLE_NotSupported,
+                      "Cannot instantiate pipeline %s",
+                      options.d->osCoordOperation.c_str() );
+            return FALSE;
+        }
+        m_bReversePj = options.d->bReverseCO;
+#ifdef DEBUG
+        auto info = proj_pj_info(m_pj);
+        CPLDebug("OGRCT", "%s %s(user set)", info.definition,
+                 m_bReversePj ? "(reversed) " : "");
+#endif
+    }
+    else if( !bWebMercatorToWGS84LongLat && poSRSSource && poSRSTarget )
+    {
+        const auto CanUseAuthorityDef = [](const OGRSpatialReference* poSRS1,
+                                           OGRSpatialReference* poSRSFromAuth,
+                                           const char* pszAuth)
+        {
+            if( EQUAL(pszAuth, "EPSG") &&
+                CPLTestBool(CPLGetConfigOption("OSR_CT_USE_DEFAULT_EPSG_TOWGS84", "NO")) )
+            {
+                // We don't want by default to honour 'default' TOWGS84 terms that come with the EPSG code
+                // because there might be a better transformation from that
+                // Typical case if EPSG:31468 "DHDN / 3-degree Gauss-Kruger zone 4"
+                // where the DHDN->TOWGS84 transformation can use the BETA2007.gsb grid
+                // instead of TOWGS84[598.1,73.7,418.2,0.202,0.045,-2.455,6.7]
+                // But if the user really wants it, it can set the
+                // OSR_CT_USE_DEFAULT_EPSG_TOWGS84 configuration option to YES
+                double adfTOWGS84_1[7];
+                double adfTOWGS84_2[7];
+
+                poSRSFromAuth->AddGuessedTOWGS84();
+
+                if( poSRS1->GetTOWGS84(adfTOWGS84_1) == OGRERR_NONE &&
+                    poSRSFromAuth->GetTOWGS84(adfTOWGS84_2) == OGRERR_NONE &&
+                    memcmp(adfTOWGS84_1, adfTOWGS84_2, sizeof(adfTOWGS84_1)) == 0 )
+                {
+                    return false;
+                }
+            }
+            return true;
+        };
+
+        const auto exportSRSToText = [&CanUseAuthorityDef](const OGRSpatialReference* poSRS)
+        {
+            char* pszText = nullptr;
+            // If we have a AUTH:CODE attached, use it to retrieve the full
+            // definition in case a trip to WKT1 has lost the area of use.
+            // unless OGR_CT_PREFER_OFFICIAL_SRS_DEF=NO (see https://github.com/OSGeo/PROJ/issues/2955)
+            const char* pszAuth = poSRS->GetAuthorityName(nullptr);
+            const char* pszCode = poSRS->GetAuthorityCode(nullptr);
+            if( pszAuth && pszCode &&
+                CPLTestBool(CPLGetConfigOption("OGR_CT_PREFER_OFFICIAL_SRS_DEF", "YES")) )
+            {
+                CPLString osAuthCode(pszAuth);
+                osAuthCode += ':';
+                osAuthCode += pszCode;
+                OGRSpatialReference oTmpSRS;
+                oTmpSRS.SetFromUserInput(osAuthCode);
+                oTmpSRS.SetDataAxisToSRSAxisMapping(poSRS->GetDataAxisToSRSAxisMapping());
+                const char* const apszOptionsIsSame[] = { "CRITERION=EQUIVALENT", nullptr };
+                if( oTmpSRS.IsSame(poSRS, apszOptionsIsSame) )
+                {
+                    if( CanUseAuthorityDef(poSRS, &oTmpSRS, pszAuth) )
+                    {
+                        pszText = CPLStrdup(osAuthCode);
+                    }
+                }
+            }
+            if( pszText == nullptr )
+            {
+                pszText = GetWktOrProjString(poSRS);
+            }
+            return pszText;
+        };
+
+        char* pszSrcSRS = exportSRSToText(poSRSSource);
+        char* pszTargetSRS = exportSRSToText(poSRSTarget);
+#ifdef DEBUG_PERF
+        struct CPLTimeVal tvStart;
+        CPLGettimeofday(&tvStart, nullptr);
+        CPLDebug("OGR_CT", "Before proj_create_crs_to_crs()");
+#endif
+#ifdef DEBUG
+        CPLDebug("OGR_CT", "Source CRS: '%s'", pszSrcSRS);
+        CPLDebug("OGR_CT", "Target CRS: '%s'", pszTargetSRS);
+#endif
+
+        if( m_eStrategy == Strategy::PROJ )
+        {
+            PJ_AREA* area = nullptr;
+            if( options.d->bHasAreaOfInterest )
+            {
+                area = proj_area_create();
+                proj_area_set_bbox(area,
+                    options.d->dfWestLongitudeDeg,
+                    options.d->dfSouthLatitudeDeg,
+                    options.d->dfEastLongitudeDeg,
+                    options.d->dfNorthLatitudeDeg);
+            }
+            auto ctx = OSRGetProjTLSContext();
+#if PROJ_VERSION_MAJOR >= 8
+            auto srcCRS = proj_create(ctx, pszSrcSRS);
+            auto targetCRS = proj_create(ctx, pszTargetSRS);
+            if( srcCRS == nullptr || targetCRS == nullptr )
+            {
+                CPLFree( pszSrcSRS );
+                CPLFree( pszTargetSRS );
+                proj_destroy(srcCRS);
+                proj_destroy(targetCRS);
+                return FALSE;
+            }
+            CPLStringList aosOptions;
+            if( options.d->dfAccuracy >= 0 )
+                aosOptions.SetNameValue("ACCURACY", CPLSPrintf("%.18g", options.d->dfAccuracy));
+            if( !options.d->bAllowBallpark )
+                aosOptions.SetNameValue("ALLOW_BALLPARK", "NO");
+            m_pj = proj_create_crs_to_crs_from_pj(ctx, srcCRS, targetCRS, area, aosOptions.List());
+            proj_destroy(srcCRS);
+            proj_destroy(targetCRS);
+#else
+            m_pj = proj_create_crs_to_crs(ctx, pszSrcSRS, pszTargetSRS, area);
+#endif
+            if( area )
+                proj_area_destroy(area);
+            if( m_pj == nullptr )
+            {
+                CPLError( CE_Failure, CPLE_NotSupported,
+                            "Cannot find coordinate operations from `%s' to `%s'",
+                            pszSrcSRS,
+                            pszTargetSRS );
+                CPLFree( pszSrcSRS );
+                CPLFree( pszTargetSRS );
+                return FALSE;
+            }
+
+        }
+        else if( !ListCoordinateOperations(pszSrcSRS, pszTargetSRS, options) )
+        {
+            CPLError( CE_Failure, CPLE_NotSupported,
+                        "Cannot find coordinate operations from `%s' to `%s'",
+                        pszSrcSRS,
+                        pszTargetSRS );
+            CPLFree( pszSrcSRS );
+            CPLFree( pszTargetSRS );
+            return FALSE;
+        }
+#ifdef DEBUG_PERF
+        struct CPLTimeVal tvEnd;
+        CPLGettimeofday(&tvEnd, nullptr);
+        const double delay = (tvEnd.tv_sec + tvEnd.tv_usec * 1e-6) -
+                             (tvStart.tv_sec + tvStart.tv_usec * 1e-6);
+        g_dfTotalTimeCRStoCRS += delay;
+        CPLDebug("OGR_CT", "After proj_create_crs_to_crs(): %d ms",
+                 static_cast<int>(delay * 1000));
+#endif
+
+        CPLFree(pszSrcSRS);
+        CPLFree(pszTargetSRS);
+    }
+
+    if( options.d->osCoordOperation.empty() && poSRSSource && poSRSTarget )
+    {
+        // Determine if we can skip the transformation completely.
+        const char* const apszOptionsIsSame[] = { "CRITERION=EQUIVALENT", nullptr };
+        bNoTransform = !bSourceWrap && !bTargetWrap &&
+                       CPL_TO_BOOL(poSRSSource->IsSame(poSRSTarget, apszOptionsIsSame));
+    }
+
+    return TRUE;
+}
+
+/************************************************************************/
+/*                               op_to_pj()                             */
+/************************************************************************/
+
+static PJ* op_to_pj(PJ_CONTEXT* ctx, PJ* op, CPLString* osOutProjString = nullptr )
+{
+    // OSR_USE_ETMERC is here just for legacy
+    bool bForceApproxTMerc = false;
+    const char* pszUseETMERC = CPLGetConfigOption("OSR_USE_ETMERC", nullptr);
+    if( pszUseETMERC && pszUseETMERC[0] )
+    {
+        static bool bHasWarned = false;
+        if( !bHasWarned )
+        {
+            CPLError(CE_Warning, CPLE_AppDefined,
+                     "OSR_USE_ETMERC is a legacy configuration option, which "
+                     "now has only effect when set to NO (YES is the default). "
+                     "Use OSR_USE_APPROX_TMERC=YES instead");
+            bHasWarned = true;
+        }
+        bForceApproxTMerc = !CPLTestBool(pszUseETMERC);
+    }
+    else
+    {
+        const char* pszUseApproxTMERC = CPLGetConfigOption("OSR_USE_APPROX_TMERC", nullptr);
+        if( pszUseApproxTMERC && pszUseApproxTMERC[0] )
+        {
+            bForceApproxTMerc = CPLTestBool(pszUseApproxTMERC);
+        }
+    }
+    const char* options[] = {
+        bForceApproxTMerc ? "USE_APPROX_TMERC=YES" : nullptr,
+        nullptr
+    };
+    auto proj_string = proj_as_proj_string(ctx, op, PJ_PROJ_5, options);
+    if( !proj_string) {
+        return nullptr;
+    }
+    if( osOutProjString )
+        *osOutProjString = proj_string;
+
+    if( proj_string[0] == '\0' ) {
+        /* Null transform ? */
+        return proj_create(ctx, "proj=affine");
+    } else {
+        return proj_create(ctx, proj_string);
+    }
+}
+
+/************************************************************************/
+/*                       ListCoordinateOperations()                     */
+/************************************************************************/
+
+bool OGRProjCT::ListCoordinateOperations(const char* pszSrcSRS,
+                                         const char* pszTargetSRS,
+                                         const OGRCoordinateTransformationOptions& options )
+{
+    auto ctx = OSRGetProjTLSContext();
+
+    auto src = proj_create(ctx, pszSrcSRS);
+    if( !src ) {
+        CPLError(CE_Failure, CPLE_AppDefined, "Cannot instantiate source_crs");
+        return false;
+    }
+
+    auto dst = proj_create(ctx, pszTargetSRS);
+    if( !dst ) {
+        CPLError(CE_Failure, CPLE_AppDefined, "Cannot instantiate target_crs");
+        proj_destroy(src);
+        return false;
+    }
+
+    auto operation_ctx = proj_create_operation_factory_context(ctx, nullptr);
+    if( !operation_ctx ) {
+        proj_destroy(src);
+        proj_destroy(dst);
+        return false;
+    }
+
+    proj_operation_factory_context_set_spatial_criterion(
+        ctx, operation_ctx, PROJ_SPATIAL_CRITERION_PARTIAL_INTERSECTION);
+    proj_operation_factory_context_set_grid_availability_use(
+        ctx, operation_ctx,
+#if PROJ_VERSION_MAJOR >= 7
+        proj_context_is_network_enabled(ctx) ?
+            PROJ_GRID_AVAILABILITY_KNOWN_AVAILABLE:
+#endif
+            PROJ_GRID_AVAILABILITY_DISCARD_OPERATION_IF_MISSING_GRID);
+
+    if( options.d->bHasAreaOfInterest )
+    {
+        proj_operation_factory_context_set_area_of_interest(
+            ctx,
+            operation_ctx,
+            options.d->dfWestLongitudeDeg,
+            options.d->dfSouthLatitudeDeg,
+            options.d->dfEastLongitudeDeg,
+            options.d->dfNorthLatitudeDeg);
+    }
+
+    if( options.d->dfAccuracy >= 0 )
+        proj_operation_factory_context_set_desired_accuracy(ctx ,operation_ctx, options.d->dfAccuracy);
+    if ( !options.d->bAllowBallpark )
+    {
+#if PROJ_VERSION_MAJOR > 7 || (PROJ_VERSION_MAJOR == 7 && PROJ_VERSION_MINOR >= 1)
+        proj_operation_factory_context_set_allow_ballpark_transformations(ctx ,operation_ctx, FALSE);
+#else
+        if( options.d->dfAccuracy < 0 )
+        {
+            proj_operation_factory_context_set_desired_accuracy(ctx ,operation_ctx, HUGE_VAL);
+        }
+#endif
+    }
+
+    auto op_list = proj_create_operations(ctx, src, dst, operation_ctx);
+
+    if( !op_list ) {
+        proj_operation_factory_context_destroy(operation_ctx);
+        proj_destroy(src);
+        proj_destroy(dst);
+        return false;
+    }
+
+    auto op_count = proj_list_get_count(op_list);
+    if( op_count == 0 ) {
+        proj_list_destroy(op_list);
+        proj_operation_factory_context_destroy(operation_ctx);
+        proj_destroy(src);
+        proj_destroy(dst);
+        CPLDebug("OGRCT", "No operation found matching criteria");
+        return false;
+    }
+
+    if( op_count == 1 || options.d->bHasAreaOfInterest ||
+        proj_get_type(src) == PJ_TYPE_GEOCENTRIC_CRS ||
+        proj_get_type(dst) == PJ_TYPE_GEOCENTRIC_CRS ) {
+        auto op = proj_list_get(ctx, op_list, 0);
+        CPLAssert(op);
+        m_pj = op_to_pj(ctx, op);
+        CPLString osName;
+        auto name = proj_get_name(op);
+        if( name )
+            osName = name;
+        proj_destroy(op);
+        proj_list_destroy(op_list);
+        proj_operation_factory_context_destroy(operation_ctx);
+        proj_destroy(src);
+        proj_destroy(dst);
+        if( !m_pj )
+            return false;
+#ifdef DEBUG
+        auto info = proj_pj_info(m_pj);
+        CPLDebug("OGRCT", "%s (%s)", info.definition, osName.c_str());
+#endif
+        return true;
+    }
+
+    // Create a geographic 2D long-lat degrees CRS that is related to the
+    // source CRS
+    auto geodetic_crs = proj_crs_get_geodetic_crs(ctx, src);
+    if( !geodetic_crs ) {
+        proj_list_destroy(op_list);
+        proj_operation_factory_context_destroy(operation_ctx);
+        proj_destroy(src);
+        proj_destroy(dst);
+        CPLDebug("OGRCT", "Cannot find geodetic CRS matching source CRS");
+        return false;
+    }
+    auto geodetic_crs_type = proj_get_type(geodetic_crs);
+    if( geodetic_crs_type == PJ_TYPE_GEOCENTRIC_CRS ||
+        geodetic_crs_type == PJ_TYPE_GEOGRAPHIC_2D_CRS ||
+        geodetic_crs_type == PJ_TYPE_GEOGRAPHIC_3D_CRS )
+    {
+        auto datum = proj_crs_get_datum(ctx, geodetic_crs);
+#if PROJ_VERSION_MAJOR > 7 || (PROJ_VERSION_MAJOR == 7 && PROJ_VERSION_MINOR >= 2)
+        if( datum == nullptr )
+        {
+            datum = proj_crs_get_datum_forced(ctx, geodetic_crs);
+        }
+#endif
+        if( datum )
+        {
+            auto ellps = proj_get_ellipsoid(ctx, datum);
+            proj_destroy(datum);
+            double semi_major_metre = 0;
+            double inv_flattening = 0;
+            proj_ellipsoid_get_parameters(ctx, ellps, &semi_major_metre,
+                                          nullptr, nullptr, &inv_flattening);
+            auto cs = proj_create_ellipsoidal_2D_cs(
+                ctx, PJ_ELLPS2D_LONGITUDE_LATITUDE, nullptr, 0);
+            // It is critical to set the prime meridian to 0
+            auto temp = proj_create_geographic_crs(
+                ctx, "unnamed crs", "unnamed datum",
+                proj_get_name(ellps),
+                semi_major_metre, inv_flattening,
+                "Reference prime meridian", 0, nullptr, 0,
+                cs);
+            proj_destroy(ellps);
+            proj_destroy(cs);
+            proj_destroy(geodetic_crs);
+            geodetic_crs = temp;
+            geodetic_crs_type = proj_get_type(geodetic_crs);
+        }
+    }
+    if( geodetic_crs_type != PJ_TYPE_GEOGRAPHIC_2D_CRS )
+    {
+        // Shouldn't happen
+        proj_list_destroy(op_list);
+        proj_operation_factory_context_destroy(operation_ctx);
+        proj_destroy(src);
+        proj_destroy(dst);
+        proj_destroy(geodetic_crs);
+        CPLDebug("OGRCT", "Cannot find geographic CRS matching source CRS");
+        return false;
+    }
+
+    // Create the transformation from this geographic 2D CRS to the source CRS
+    auto op_list_to_geodetic = proj_create_operations(
+        ctx, geodetic_crs, src, operation_ctx);
+    proj_destroy(geodetic_crs);
+
+    if( op_list_to_geodetic == nullptr ||
+        proj_list_get_count(op_list_to_geodetic) == 0 )
+    {
+        CPLDebug("OGRCT", "Cannot compute transformation from geographic CRS to source CRS");
+        proj_list_destroy(op_list);
+        proj_list_destroy(op_list_to_geodetic);
+        proj_operation_factory_context_destroy(operation_ctx);
+        proj_destroy(src);
+        proj_destroy(dst);
+        return false;
+    }
+    auto opGeogToSrc = proj_list_get(ctx, op_list_to_geodetic, 0);
+    CPLAssert(opGeogToSrc);
+    proj_list_destroy(op_list_to_geodetic);
+    auto pjGeogToSrc = op_to_pj(ctx, opGeogToSrc);
+    proj_destroy(opGeogToSrc);
+    if( !pjGeogToSrc ) {
+        proj_list_destroy(op_list);
+        proj_operation_factory_context_destroy(operation_ctx);
+        proj_destroy(src);
+        proj_destroy(dst);
+        return false;
+    }
+
+    const auto addTransformation = [this, &pjGeogToSrc, &ctx](PJ* op,
+                                       double west_lon, double south_lat,
+                                       double east_lon, double north_lat) {
+        double minx = -std::numeric_limits<double>::max();
+        double miny = -std::numeric_limits<double>::max();
+        double maxx = std::numeric_limits<double>::max();
+        double maxy = std::numeric_limits<double>::max();
+
+        if( !(west_lon == -180.0 && east_lon == 180.0 &&
+              south_lat == -90.0 && north_lat == 90.0) )
+        {
+            minx = -minx;
+            miny = -miny;
+            maxx = -maxx;
+            maxy = -maxy;
+
+            double x[21 * 4], y[21 * 4];
+            for( int j = 0; j <= 20; j++ )
+            {
+                x[j] = west_lon + j * (east_lon - west_lon) / 20;
+                y[j] = south_lat;
+                x[21+j] = west_lon + j * (east_lon - west_lon) / 20;
+                y[21+j] = north_lat;
+                x[21*2+j] = west_lon;
+                y[21*2+j] = south_lat + j * (north_lat - south_lat) / 20;
+                x[21*3+j] = east_lon;
+                y[21*3+j] = south_lat + j * (north_lat - south_lat) / 20;
+            }
+            proj_trans_generic (
+                pjGeogToSrc, PJ_FWD,
+                    x, sizeof(double), 21 * 4,
+                    y, sizeof(double), 21 * 4,
+                    nullptr, 0, 0,
+                    nullptr, 0, 0);
+            for( int j = 0; j < 21 * 4; j++ )
+            {
+                if( x[j] != HUGE_VAL && y[j] != HUGE_VAL )
+                {
+                    minx = std::min(minx, x[j]);
+                    miny = std::min(miny, y[j]);
+                    maxx = std::max(maxx, x[j]);
+                    maxy = std::max(maxy, y[j]);
+                }
+            }
+        }
+
+        if( minx <= maxx )
+        {
+            CPLString osProjString;
+            const double accuracy = proj_coordoperation_get_accuracy(ctx, op);
+            auto pj = op_to_pj(ctx, op, &osProjString);
+            CPLString osName;
+            auto name = proj_get_name(op);
+            if( name )
+                osName = name;
+            proj_destroy(op);
+            op = nullptr;
+            if( pj )
+            {
+                m_oTransformations.emplace_back(
+                    minx, miny, maxx, maxy, pj, osName, osProjString, accuracy);
+            }
+        }
+        return op;
+    };
+
+    // Iterate over source->target candidate transformations and reproject
+    // their long-lat bounding box into the source CRS.
+    bool foundWorldTransformation = false;
+    for( int i = 0; i < op_count; i++ )
+    {
+        auto op = proj_list_get(ctx, op_list, i);
+        CPLAssert(op);
+        double west_lon = 0.0;
+        double south_lat = 0.0;
+        double east_lon = 0.0;
+        double north_lat = 0.0;
+        if( proj_get_area_of_use(ctx, op,
+                    &west_lon, &south_lat, &east_lon, &north_lat, nullptr) )
+        {
+            if( west_lon <= east_lon )
+            {
+                if( west_lon == -180 && east_lon == 180 &&
+                    south_lat == -90 && north_lat == 90 )
+                {
+                    foundWorldTransformation = true;
+                }
+                op = addTransformation(op,
+                                  west_lon, south_lat, east_lon, north_lat);
+            }
+            else
+            {
+                auto op_clone = proj_clone(ctx, op);
+
+                op = addTransformation(op,
+                                  west_lon, south_lat, 180, north_lat);
+                op_clone = addTransformation(op_clone,
+                                  -180, south_lat, east_lon, north_lat);
+                proj_destroy(op_clone);
+            }
+        }
+
+        proj_destroy(op);
+    }
+
+    proj_list_destroy(op_list);
+
+    // Sometimes the user will operate even outside the area of use of the
+    // source and target CRS, so if no global transformation has been returned
+    // previously, trigger the computation of one.
+    if( !foundWorldTransformation )
+    {
+        proj_operation_factory_context_set_area_of_interest(
+                                            ctx,
+                                            operation_ctx,
+                                            -180, -90, 180, 90);
+        proj_operation_factory_context_set_spatial_criterion(
+            ctx, operation_ctx, PROJ_SPATIAL_CRITERION_STRICT_CONTAINMENT);
+        op_list = proj_create_operations(ctx, src, dst, operation_ctx);
+        if( op_list )
+        {
+            op_count = proj_list_get_count(op_list);
+            for( int i = 0; i < op_count; i++ )
+            {
+                auto op = proj_list_get(ctx, op_list, i);
+                CPLAssert(op);
+                double west_lon = 0.0;
+                double south_lat = 0.0;
+                double east_lon = 0.0;
+                double north_lat = 0.0;
+                if( proj_get_area_of_use(ctx, op,
+                        &west_lon, &south_lat, &east_lon, &north_lat, nullptr) &&
+                    west_lon == -180 && east_lon == 180 &&
+                    south_lat == -90 && north_lat == 90 )
+                {
+                    op = addTransformation(op,
+                                  west_lon, south_lat, east_lon, north_lat);
+                }
+                proj_destroy(op);
+            }
+        }
+        proj_list_destroy(op_list);
+    }
+
+    proj_operation_factory_context_destroy(operation_ctx);
+    proj_destroy(src);
+    proj_destroy(dst);
+    proj_destroy(pjGeogToSrc);
+    return !m_oTransformations.empty();
+}
+
+/************************************************************************/
+/*                            GetSourceCS()                             */
+/************************************************************************/
+
+OGRSpatialReference *OGRProjCT::GetSourceCS()
+
+{
+    return poSRSSource;
+}
+
+/************************************************************************/
+/*                            GetTargetCS()                             */
+/************************************************************************/
+
+OGRSpatialReference *OGRProjCT::GetTargetCS()
+
+{
+    return poSRSTarget;
+}
+
+/************************************************************************/
+/*                             Transform()                              */
+/************************************************************************/
+
+int OGRCoordinateTransformation::Transform(
+            int nCount, double *x, double *y, double *z,
+            int *pabSuccessIn )
+
+{
+    int *pabSuccess = pabSuccessIn ? pabSuccessIn :
+        static_cast<int *>(CPLMalloc(sizeof(int) * nCount));
+
+    bool bOverallSuccess =
+        CPL_TO_BOOL(Transform( nCount, x, y, z, nullptr, pabSuccess ));
+
+    for( int i = 0; i < nCount; i++ )
+    {
+        if( !pabSuccess[i] )
+        {
+            bOverallSuccess = false;
+            break;
+        }
+    }
+
+    if( pabSuccess != pabSuccessIn )
+        CPLFree( pabSuccess );
+
+    return bOverallSuccess;
+}
+
+/************************************************************************/
+/*                      TransformWithErrorCodes()                       */
+/************************************************************************/
+
+int OGRCoordinateTransformation::TransformWithErrorCodes(
+            int nCount, double *x, double *y, double *z, double* t,
+            int *panErrorCodes )
+
+{
+    std::vector<int> abSuccess(nCount+1);
+
+    bool bOverallSuccess =
+        CPL_TO_BOOL(Transform( nCount, x, y, z, t, &abSuccess[0] ));
+
+    if( panErrorCodes )
+    {
+        for( int i = 0; i < nCount; i++ )
+        {
+            panErrorCodes[i] = abSuccess[i] ? 0 : -1;
+        }
+    }
+
+    return bOverallSuccess;
+}
+
+/************************************************************************/
+/*                             Transform()                             */
+/************************************************************************/
+
+int OGRProjCT::Transform( int nCount, double *x, double *y, double *z,
+                          double *t, int *pabSuccess )
+
+{
+    std::vector<int> anErrorCodes(nCount+1);
+
+    bool bOverallSuccess =
+        CPL_TO_BOOL(TransformWithErrorCodes( nCount, x, y, z, t, &anErrorCodes[0] ));
+
+    if( pabSuccess )
+    {
+        for( int i = 0; i < nCount; i++ )
+        {
+            pabSuccess[i] = ( anErrorCodes[i] == 0 );
+        }
+    }
+
+    return bOverallSuccess;
+}
+
+/************************************************************************/
+/*                       TransformWithErrorCodes()                      */
+/************************************************************************/
+
+#ifndef PROJ_ERR_COORD_TRANSFM_INVALID_COORD
+#define PROJ_ERR_COORD_TRANSFM_INVALID_COORD             2049
+#define PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN 2050
+#define PROJ_ERR_COORD_TRANSFM_NO_OPERATION              2051
+#endif
+
+int OGRProjCT::TransformWithErrorCodes(
+            int nCount, double *x, double *y, double *z, double* t,
+            int *panErrorCodes )
+
+{
+    if( nCount == 0 )
+        return TRUE;
+
+    // Prevent any coordinate modification when possible
+    if ( bNoTransform )
+    {
+        if( panErrorCodes )
+        {
+            for( int i = 0; i < nCount; i++ )
+            {
+                 panErrorCodes[i] = 0;
+            }
+        }
+        return TRUE;
+    }
+
+#ifdef DEBUG_VERBOSE
+    bool bDebugCT = CPLTestBool(CPLGetConfigOption("OGR_CT_DEBUG", "NO"));
+    if( bDebugCT )
+    {
+        CPLDebug("OGRCT", "count = %d", nCount);
+        for( int i = 0; i < nCount; ++i )
+        {
+            CPLDebug("OGRCT", "  x[%d] = %.16g y[%d] = %.16g",
+                     i, x[i], i, y[i]);
+        }
+    }
+#endif
+#ifdef DEBUG_PERF
+    //CPLDebug("OGR_CT", "Begin TransformWithErrorCodes()");
+    struct CPLTimeVal tvStart;
+    CPLGettimeofday(&tvStart, nullptr);
+#endif
+
+/* -------------------------------------------------------------------- */
+/*      Apply data axis to source CRS mapping.                          */
+/* -------------------------------------------------------------------- */
+    if( poSRSSource )
+    {
+        const auto& mapping = poSRSSource->GetDataAxisToSRSAxisMapping();
+        if( mapping.size() >= 2 && (mapping[0] != 1 || mapping[1] != 2) )
+        {
+            for( int i = 0; i < nCount; i++ )
+            {
+                double newX = (mapping[0] == 1) ? x[i] :
+                    (mapping[0] == -1) ? -x[i] : (mapping[0] == 2) ? y[i] : -y[i];
+                double newY = (mapping[1] == 2) ? y[i] :
+                    (mapping[1] == -2) ? -y[i] : (mapping[1] == 1) ? x[i] : -x[i];
+                x[i] = newX;
+                y[i] = newY;
+                if( z && mapping.size() >= 3 && mapping[2] == -3)
+                    z[i] = -z[i];
+            }
+        }
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Potentially do longitude wrapping.                              */
+/* -------------------------------------------------------------------- */
+    if( bSourceLatLong && bSourceWrap )
+    {
+        OGRAxisOrientation orientation;
+        assert( poSRSSource );
+        poSRSSource->GetAxis(nullptr, 0, &orientation);
+        if( orientation == OAO_East )
+        {
+            for( int i = 0; i < nCount; i++ )
+            {
+                if( x[i] != HUGE_VAL && y[i] != HUGE_VAL )
+                {
+                    if( x[i] < dfSourceWrapLong - 180.0 )
+                        x[i] += 360.0;
+                    else if( x[i] > dfSourceWrapLong + 180 )
+                        x[i] -= 360.0;
+                }
+            }
+        }
+        else
+        {
+            for( int i = 0; i < nCount; i++ )
+            {
+                if( x[i] != HUGE_VAL && y[i] != HUGE_VAL )
+                {
+                    if( y[i] < dfSourceWrapLong - 180.0 )
+                        y[i] += 360.0;
+                    else if( y[i] > dfSourceWrapLong + 180 )
+                        y[i] -= 360.0;
+                }
+            }
+        }
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Optimized transform from WebMercator to WGS84                   */
+/* -------------------------------------------------------------------- */
+    bool bTransformDone = false;
+    if( bWebMercatorToWGS84LongLat )
+    {
+        constexpr double REVERSE_SPHERE_RADIUS = 1.0 / 6378137.0;
+
+        if( poSRSSource )
+        {
+            OGRAxisOrientation orientation;
+            poSRSSource->GetAxis(nullptr, 0, &orientation);
+            if( orientation != OAO_East )
+            {
+                for( int i = 0; i < nCount; i++ )
+                {
+                    std::swap(x[i], y[i]);
+                }
+            }
+        }
+
+        double y0 = y[0];
+        for( int i = 0; i < nCount; i++ )
+        {
+            if( x[i] != HUGE_VAL )
+            {
+                x[i] = x[i] * REVERSE_SPHERE_RADIUS;
+                if( x[i] > M_PI )
+                {
+                    if( x[i] < M_PI+1e-14 )
+                    {
+                        x[i] = M_PI;
+                    }
+                    else if( m_options.d->bCheckWithInvertProj )
+                    {
+                        x[i] = HUGE_VAL;
+                        y[i] = HUGE_VAL;
+                        y0 = HUGE_VAL;
+                        continue;
+                    }
+                    else
+                    {
+                        do {
+                            x[i] -= 2 * M_PI;
+                        } while( x[i] > M_PI );
+                    }
+                }
+                else if( x[i] < -M_PI )
+                {
+                    if( x[i] > -M_PI-1e-14 )
+                    {
+                        x[i] = -M_PI;
+                    }
+                    else if( m_options.d->bCheckWithInvertProj )
+                    {
+                        x[i] = HUGE_VAL;
+                        y[i] = HUGE_VAL;
+                        y0 = HUGE_VAL;
+                        continue;
+                    }
+                    else
+                    {
+                        do {
+                            x[i] += 2 * M_PI;
+                        } while( x[i] < -M_PI );
+                    }
+                }
+                constexpr double RAD_TO_DEG = 57.29577951308232;
+                x[i] *= RAD_TO_DEG;
+
+                 // Optimization for the case where we are provided a whole line
+                 // of same northing.
+                if( i > 0 && y[i] == y0 )
+                    y[i] = y[0];
+                else
+                {
+                    y[i] =
+                        M_PI / 2.0 -
+                        2.0 * atan(exp(-y[i] * REVERSE_SPHERE_RADIUS));
+                    y[i] *= RAD_TO_DEG;
+                }
+            }
+        }
+
+        if( panErrorCodes )
+        {
+            for( int i = 0; i < nCount; i++ )
+            {
+                if( x[i] != HUGE_VAL )
+                    panErrorCodes[i] = 0;
+                else
+                    panErrorCodes[i] = PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN;
+            }
+        }
+
+        if( poSRSTarget )
+        {
+            OGRAxisOrientation orientation;
+            poSRSTarget->GetAxis(nullptr, 0, &orientation);
+            if( orientation != OAO_East )
+            {
+                for( int i = 0; i < nCount; i++ )
+                {
+                    std::swap(x[i], y[i]);
+                }
+            }
+        }
+
+        bTransformDone = true;
+    }
+
+    // Determine the default coordinate epoch, if not provided in the point to
+    // transform.
+    // For time-dependent transformations, PROJ can currently only do
+    // staticCRS -> dynamicCRS or dynamicCRS -> staticCRS transformations, and
+    // in either case, the coordinate epoch of the dynamicCRS must be provided
+    // as the input time.
+    double dfDefaultTime = HUGE_VAL;
+    if( bSourceIsDynamicCRS && dfSourceCoordinateEpoch > 0 &&
+        !bTargetIsDynamicCRS &&
+        CPLTestBool(CPLGetConfigOption("OGR_CT_USE_SRS_COORDINATE_EPOCH", "YES")) )
+    {
+        dfDefaultTime = dfSourceCoordinateEpoch;
+        CPLDebug("OGR_CT", "Using coordinate epoch %f from source CRS",
+                 dfDefaultTime);
+    }
+    else if (bTargetIsDynamicCRS && dfTargetCoordinateEpoch > 0 &&
+             !bSourceIsDynamicCRS &&
+             CPLTestBool(CPLGetConfigOption("OGR_CT_USE_SRS_COORDINATE_EPOCH", "YES")) )
+    {
+        dfDefaultTime = dfTargetCoordinateEpoch;
+        CPLDebug("OGR_CT", "Using coordinate epoch %f from target CRS",
+                 dfDefaultTime);
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Select dynamically the best transformation for the data, if     */
+/*      needed.                                                         */
+/* -------------------------------------------------------------------- */
+    auto ctx = OSRGetProjTLSContext();
+    PJ* pj = m_pj;
+    if( !bTransformDone && !pj )
+    {
+        double avgX = 0.0;
+        double avgY = 0.0;
+        int nCountValid = 0;
+        for( int i = 0; i < nCount; i++ )
+        {
+            if( x[i] != HUGE_VAL && y[i] != HUGE_VAL )
+            {
+                avgX += x[i];
+                avgY += y[i];
+                nCountValid ++;
+            }
+        }
+        if( nCountValid != 0 )
+        {
+            avgX /= nCountValid;
+            avgY /= nCountValid;
+        }
+
+        constexpr int N_MAX_RETRY = 2;
+        int iExcluded[N_MAX_RETRY] = {-1, -1};
+
+        const int nOperations = static_cast<int>(m_oTransformations.size());
+        PJ_COORD coord;
+        coord.xyzt.x = avgX;
+        coord.xyzt.y = avgY;
+        coord.xyzt.z = z ? z[0] : 0;
+        coord.xyzt.t = t ? t[0] : dfDefaultTime;
+
+        // We may need several attempts. For example the point at
+        // lon=-111.5 lat=45.26 falls into the bounding box of the Canadian
+        // ntv2_0.gsb grid, except that it is not in any of the subgrids, being
+        // in the US. We thus need another retry that will select the conus
+        // grid.
+        for( int iRetry = 0; iRetry <= N_MAX_RETRY; iRetry++ )
+        {
+            int iBestTransf = -1;
+            // Select transform whose BBOX match our data and has the best accuracy
+            // if m_eStrategy == BEST_ACCURACY. Or just the first BBOX matching one, if
+            //  m_eStrategy == FIRST_MATCHING
+            double dfBestAccuracy = std::numeric_limits<double>::infinity();
+            for( int i = 0; i < nOperations; i++ )
+            {
+                if( i == iExcluded[0] || i == iExcluded[1] )
+                {
+                    continue;
+                }
+                const auto& transf = m_oTransformations[i];
+                if( avgX >= transf.minx && avgX <= transf.maxx &&
+                    avgY >= transf.miny && avgY <= transf.maxy &&
+                    (iBestTransf < 0 || (transf.accuracy >= 0 &&
+                                        transf.accuracy < dfBestAccuracy)) )
+                {
+                    iBestTransf = i;
+                    dfBestAccuracy = transf.accuracy;
+                    if( m_eStrategy == Strategy::FIRST_MATCHING )
+                        break;
+                }
+            }
+            if( iBestTransf < 0 )
+            {
+                break;
+            }
+            auto& transf = m_oTransformations[iBestTransf];
+            pj = transf.pj;
+            proj_assign_context( pj, ctx );
+            if( iBestTransf != m_iCurTransformation )
+            {
+                CPLDebug("OGRCT", "Selecting transformation %s (%s)",
+                        transf.osProjString.c_str(),
+                        transf.osName.c_str());
+                m_iCurTransformation = iBestTransf;
+            }
+
+            auto res = proj_trans(pj, m_bReversePj ? PJ_INV : PJ_FWD, coord);
+            if( res.xyzt.x != HUGE_VAL ) {
+                break;
+            }
+            pj = nullptr;
+            CPLDebug("OGRCT",
+                     "Did not result in valid result. "
+                     "Attempting a retry with another operation.");
+            if( iRetry == N_MAX_RETRY ) {
+                break;
+            }
+            iExcluded[iRetry] = iBestTransf;
+        }
+
+        if( !pj )
+        {
+            // In case we did not find an operation whose area of use is compatible
+            // with the input coordinate, then goes through again the list, and
+            // use the first operation that does not require grids.
+            for( int i = 0; i < nOperations; i++ )
+            {
+                auto& transf = m_oTransformations[i];
+                if( proj_coordoperation_get_grid_used_count(ctx, transf.pj) == 0 )
+                {
+                    pj = transf.pj;
+                    proj_assign_context( pj, ctx );
+                    if( i != m_iCurTransformation )
+                    {
+                        CPLDebug("OGRCT", "Selecting transformation %s (%s)",
+                                transf.osProjString.c_str(),
+                                transf.osName.c_str());
+                        m_iCurTransformation = i;
+                    }
+                    break;
+                }
+            }
+        }
+
+        if( !pj )
+        {
+            if( m_bEmitErrors && ++nErrorCount < 20 )
+            {
+                CPLError(CE_Failure, CPLE_AppDefined,
+                        "Cannot find transformation for provided coordinates");
+            }
+            else if( nErrorCount == 20 )
+            {
+                CPLError( CE_Failure, CPLE_AppDefined,
+                        "Reprojection failed, further errors will be "
+                        "suppressed on the transform object.");
+            }
+
+            for( int i = 0; i < nCount; i++ )
+            {
+                x[i] = HUGE_VAL;
+                y[i] = HUGE_VAL;
+                if( panErrorCodes )
+                    panErrorCodes[i] = PROJ_ERR_COORD_TRANSFM_NO_OPERATION;
+            }
+            return FALSE;
+        }
+    }
+    if( pj )
+    {
+        proj_assign_context( pj, ctx );
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Do the transformation (or not...) using PROJ                    */
+/* -------------------------------------------------------------------- */
+
+    if( !bTransformDone )
+    {
+        for( int i = 0; i < nCount; i++ )
+        {
+            PJ_COORD coord;
+            const double xIn = x[i];
+            const double yIn = y[i];
+            if( !std::isfinite(xIn) )
+            {
+                x[i] = HUGE_VAL;
+                y[i] = HUGE_VAL;
+                if( panErrorCodes )
+                    panErrorCodes[i] = PROJ_ERR_COORD_TRANSFM_INVALID_COORD;
+                continue;
+            }
+            coord.xyzt.x = x[i];
+            coord.xyzt.y = y[i];
+            coord.xyzt.z = z ? z[i] : 0;
+            coord.xyzt.t = t ? t[i] : dfDefaultTime;
+            proj_errno_reset(pj);
+            coord = proj_trans(pj, m_bReversePj ? PJ_INV : PJ_FWD, coord);
+            x[i] = coord.xyzt.x;
+            y[i] = coord.xyzt.y;
+            if( z )
+                z[i] = coord.xyzt.z;
+            if( t )
+                t[i] = coord.xyzt.t;
+            int err = 0;
+            if( std::isnan(coord.xyzt.x) )
+            {
+                // This shouldn't normally happen if PROJ projections behave
+                // correctly, but e.g inverse laea before PROJ 8.1.1 could
+                // do that for points out of domain.
+                // See https://github.com/OSGeo/PROJ/pull/2800
+                x[i] = HUGE_VAL;
+                y[i] = HUGE_VAL;
+                err = PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN;
+                static bool bHasWarned = false;
+                if( !bHasWarned )
+                {
+#ifdef DEBUG
+                    CPLError(CE_Warning, CPLE_AppDefined,
+                             "PROJ returned a NaN value. It should be fixed");
+#else
+                    CPLDebug("OGR_CT", "PROJ returned a NaN value. It should be fixed");
+#endif
+                    bHasWarned = true;
+                }
+            }
+            else if( coord.xyzt.x == HUGE_VAL )
+            {
+                err = proj_errno(pj);
+                // PROJ should normally emit an error, but in case it does not
+                // (e.g PROJ 6.3 with the +ortho projection), synthetize one
+                if( err == 0 )
+                    err = PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN;
+            }
+            else if( m_options.d->bCheckWithInvertProj )
+            {
+                // For some projections, we cannot detect if we are trying to reproject
+                // coordinates outside the validity area of the projection. So let's do
+                // the reverse reprojection and compare with the source coordinates.
+                coord = proj_trans(pj, m_bReversePj ? PJ_FWD : PJ_INV, coord);
+                if (fabs(coord.xyzt.x - xIn) > dfThreshold ||
+                    fabs(coord.xyzt.y - yIn) > dfThreshold)
+                {
+                    err  = PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN;
+                    x[i] = HUGE_VAL;
+                    y[i] = HUGE_VAL;
+                }
+            }
+
+            if( panErrorCodes )
+                panErrorCodes[i] = err;
+
+/* -------------------------------------------------------------------- */
+/*      Try to report an error through CPL.  Get proj error string      */
+/*      if possible.  Try to avoid reporting thousands of errors.       */
+/*      Suppress further error reporting on this OGRProjCT if we        */
+/*      have already reported 20 errors.                                */
+/* -------------------------------------------------------------------- */
+            if( err != 0 )
+            {
+                if( ++nErrorCount < 20 )
+                {
+#if PROJ_VERSION_MAJOR >= 8
+                    const char *pszError = proj_context_errno_string(ctx, err);
+#else
+                    const char *pszError = proj_errno_string(err);
+#endif
+                    if( m_bEmitErrors )
+                    {
+                        if( pszError == nullptr )
+                            CPLError( CE_Failure, CPLE_AppDefined,
+                                      "Reprojection failed, err = %d", err );
+                        else
+                            CPLError( CE_Failure, CPLE_AppDefined, "%s", pszError );
+                    }
+                    else
+                    {
+                        if( pszError == nullptr )
+                            CPLDebug("OGRCT",
+                                     "Reprojection failed, err = %d", err );
+                        else
+                            CPLDebug("OGRCT", "%s", pszError );
+                    }
+                }
+                else if( nErrorCount == 20 )
+                {
+                    if( m_bEmitErrors )
+                    {
+                        CPLError(CE_Failure, CPLE_AppDefined,
+                                 "Reprojection failed, err = %d, further errors will be "
+                                 "suppressed on the transform object.",
+                                 err );
+                    }
+                    else
+                    {
+                        CPLDebug("OGRCT",
+                                 "Reprojection failed, err = %d, further errors will be "
+                                 "suppressed on the transform object.",
+                                 err );
+                    }
+                }
+            }
+        }
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Potentially do longitude wrapping.                              */
+/* -------------------------------------------------------------------- */
+    if( bTargetLatLong && bTargetWrap )
+    {
+        OGRAxisOrientation orientation;
+        assert( poSRSTarget );
+        poSRSTarget->GetAxis(nullptr, 0, &orientation);
+        if( orientation == OAO_East )
+        {
+            for( int i = 0; i < nCount; i++ )
+            {
+                if( x[i] != HUGE_VAL && y[i] != HUGE_VAL )
+                {
+                    if( x[i] < dfTargetWrapLong - 180.0 )
+                        x[i] += 360.0;
+                    else if( x[i] > dfTargetWrapLong + 180 )
+                        x[i] -= 360.0;
+                }
+            }
+        }
+        else
+        {
+            for( int i = 0; i < nCount; i++ )
+            {
+                if( x[i] != HUGE_VAL && y[i] != HUGE_VAL )
+                {
+                    if( y[i] < dfTargetWrapLong - 180.0 )
+                        y[i] += 360.0;
+                    else if( y[i] > dfTargetWrapLong + 180 )
+                        y[i] -= 360.0;
+                }
+            }
+        }
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Apply data axis to target CRS mapping.                          */
+/* -------------------------------------------------------------------- */
+    if( poSRSTarget )
+    {
+        const auto& mapping = poSRSTarget->GetDataAxisToSRSAxisMapping();
+        if( mapping.size() >= 2 && (mapping[0] != 1 || mapping[1] != 2) )
+        {
+            for( int i = 0; i < nCount; i++ )
+            {
+                double newX = (mapping[0] == 1) ? x[i] :
+                    (mapping[0] == -1) ? -x[i] : (mapping[0] == 2) ? y[i] : -y[i];
+                double newY = (mapping[1] == 2) ? y[i] :
+                    (mapping[1] == -2) ? -y[i] : (mapping[1] == 1) ? x[i] : -x[i];
+                x[i] = newX;
+                y[i] = newY;
+                if( z && mapping.size() >= 3 && mapping[2] == -3)
+                    z[i] = -z[i];
+            }
+        }
+    }
+
+#ifdef DEBUG_VERBOSE
+    if( bDebugCT )
+    {
+        CPLDebug("OGRCT", "Out:");
+        for( int i = 0; i < nCount; ++i )
+        {
+            CPLDebug("OGRCT", "  x[%d] = %.16g y[%d] = %.16g",
+                     i, x[i], i, y[i]);
+        }
+    }
+#endif
+#ifdef DEBUG_PERF
+    struct CPLTimeVal tvEnd;
+    CPLGettimeofday(&tvEnd, nullptr);
+    const double delay = (tvEnd.tv_sec + tvEnd.tv_usec * 1e-6) -
+                         (tvStart.tv_sec + tvStart.tv_usec * 1e-6);
+    g_dfTotalTimeReprojection += delay;
+    //CPLDebug("OGR_CT", "End TransformWithErrorCodes(): %d ms",
+    //         static_cast<int>(delay * 1000));
+#endif
+
+    return TRUE;
+}
+
+
+/************************************************************************/
+/*                      TransformBounds()                       */
+/************************************************************************/
+
+// ---------------------------------------------------------------------------
+static double simple_min(const double* data, const int arr_len) {
+    double min_value = data[0];
+    for( int iii = 1; iii < arr_len; iii++ ) {
+        if (data[iii] < min_value)
+            min_value = data[iii];
+    }
+    return min_value;
+}
+
+
+// ---------------------------------------------------------------------------
+static double simple_max(const double* data, const int arr_len) {
+    double max_value = data[0];
+    for( int iii = 1; iii < arr_len; iii++ ) {
+        if ((data[iii] > max_value || max_value == HUGE_VAL) && data[iii] != HUGE_VAL)
+            max_value = data[iii];
+    }
+    return max_value;
+ }
+
+
+// ---------------------------------------------------------------------------
+static int _find_previous_index(const int iii, const double* data, const int arr_len) {
+    // find index of nearest valid previous value if exists
+    int prev_iii = iii - 1;
+    if (prev_iii == -1)  // handle wraparound
+        prev_iii = arr_len - 1;
+    while (data[prev_iii] == HUGE_VAL && prev_iii != iii) {
+        prev_iii --;
+        if (prev_iii == -1)  // handle wraparound
+            prev_iii = arr_len - 1;
+    }
+    return prev_iii;
+}
+
+
+// ---------------------------------------------------------------------------
+/******************************************************************************
+Handles the case when longitude values cross the antimeridian
+when calculating the minimum.
+Note: The data array must be in a linear ring.
+Note: This requires a densified ring with at least 2 additional
+        points per edge to correctly handle global extents.
+If only 1 additional point:
+    |        |
+    |RL--x0--|RL--
+    |        |
+-180    180|-180
+If they are evenly spaced and it crosses the antimeridian:
+x0 - L = 180
+R - x0 = -180
+For example:
+Let R = -179.9, x0 = 0.1, L = -179.89
+x0 - L = 0.1 - -179.9 = 180
+R - x0 = -179.89 - 0.1 ~= -180
+This is the same in the case when it didn't cross the antimeridian.
+If you have 2 additional points:
+    |            |
+    |RL--x0--x1--|RL--
+    |            |
+-180        180|-180
+If they are evenly spaced and it crosses the antimeridian:
+x0 - L = 120
+x1 - x0 = 120
+R - x1 = -240
+For example:
+Let R = -179.9, x0 = -59.9, x1 = 60.1 L = -179.89
+x0 - L = 59.9 - -179.9 = 120
+x1 - x0 = 60.1 - 59.9 = 120
+R - x1 = -179.89 - 60.1 ~= -240
+However, if they are evenly spaced and it didn't cross the antimeridian:
+x0 - L = 120
+x1 - x0 = 120
+R - x1 = 120
+From this, we have a delta that is guaranteed to be significantly
+large enough to tell the difference reguarless of the direction
+the antimeridian was crossed.
+However, even though the spacing was even in the source projection, it isn't
+guaranteed in the target geographic projection. So, instead of 240, 200 is used
+as it significantly larger than 120 to be sure that the antimeridian was crossed
+but smalller than 240 to account for possible irregularities in distances
+when re-projecting. Also, 200 ensures latitudes are ignored for axis order handling.
+******************************************************************************/
+static double antimeridian_min(const double* data, const int arr_len) {
+    double positive_min = HUGE_VAL;
+    double min_value = HUGE_VAL;
+    int crossed_meridian_count = 0;
+    bool positive_meridian = false;
+
+    for( int iii = 0; iii < arr_len; iii++ ) {
+        if (data[iii] == HUGE_VAL)
+            continue;
+        int prev_iii = _find_previous_index(iii, data, arr_len);
+        // check if crossed meridian
+        double delta = data[prev_iii] - data[iii];
+        // 180 -> -180
+        if (delta >= 200 && delta != HUGE_VAL) {
+            if (crossed_meridian_count == 0)
+                positive_min = min_value;
+            crossed_meridian_count ++;
+            positive_meridian = false;
+        // -180 -> 180
+        } else if (delta <= -200 && delta != HUGE_VAL) {
+            if (crossed_meridian_count == 0)
+                positive_min = data[iii];
+            crossed_meridian_count ++;
+            positive_meridian = true;
+        }
+        // positive meridian side min
+        if (positive_meridian && data[iii] < positive_min)
+            positive_min = data[iii];
+        // track general min value
+        if (data[iii] < min_value)
+            min_value = data[iii];
+    }
+
+    if (crossed_meridian_count == 2)
+        return positive_min;
+    else if (crossed_meridian_count == 4)
+        // bounds extends beyond -180/180
+        return -180;
+    return min_value;
+}
+
+
+// ---------------------------------------------------------------------------
+// Handles the case when longitude values cross the antimeridian
+// when calculating the minimum.
+// Note: The data array must be in a linear ring.
+// Note: This requires a densified ring with at least 2 additional
+//       points per edge to correctly handle global extents.
+// See antimeridian_min docstring for reasoning.
+static double antimeridian_max(const double* data, const int arr_len) {
+    double negative_max = -HUGE_VAL;
+    double max_value = -HUGE_VAL;
+    bool negative_meridian = false;
+    int crossed_meridian_count = 0;
+
+    for( int iii = 0; iii < arr_len; iii++ ) {
+        if (data[iii] == HUGE_VAL)
+            continue;
+        int prev_iii = _find_previous_index(iii, data, arr_len);
+        // check if crossed meridian
+        double delta = data[prev_iii] - data[iii];
+        // 180 -> -180
+        if (delta >= 200 && delta != HUGE_VAL) {
+            if (crossed_meridian_count == 0)
+                negative_max = data[iii];
+            crossed_meridian_count ++;
+            negative_meridian = true;
+        // -180 -> 180
+        } else if (delta <= -200 && delta != HUGE_VAL){
+            if (crossed_meridian_count == 0)
+                negative_max = max_value;
+            negative_meridian = false;
+            crossed_meridian_count++;
+        }
+        // negative meridian side max
+        if (negative_meridian
+            && (data[iii] > negative_max || negative_max == HUGE_VAL)
+            && data[iii] != HUGE_VAL
+        )
+            negative_max = data[iii];
+        // track general max value
+        if ((data[iii] > max_value || max_value == HUGE_VAL) && data[iii] != HUGE_VAL)
+            max_value = data[iii];
+    }
+    if (crossed_meridian_count == 2)
+        return negative_max;
+    else if (crossed_meridian_count == 4)
+        // bounds extends beyond -180/180
+        return 180;
+    return max_value;
+}
+
+
+// ---------------------------------------------------------------------------
+// Check if the original projected bounds contains
+// the north pole.
+// This assumes that the destination CRS is geographic.
+bool OGRProjCT::ContainsNorthPole(
+    const double xmin,
+    const double ymin,
+    const double xmax,
+    const double ymax,
+    bool lon_lat_order
+) {
+    double pole_y = 90;
+    double pole_x = 0;
+    if (!lon_lat_order) {
+        pole_y = 0;
+        pole_x = 90;
+    }
+    auto inverseCT = GetInverse();
+    if (!inverseCT)
+        return false;
+    inverseCT->TransformWithErrorCodes(
+        1,
+        &pole_x,
+        &pole_y,
+        nullptr,
+        nullptr,
+        nullptr
+    );
+    delete inverseCT;
+    if (xmin < pole_x && pole_x < xmax && ymax > pole_y && pole_y > ymin)
+        return true;
+    return false;
+}
+
+
+// ---------------------------------------------------------------------------
+// Check if the original projected bounds contains
+// the south pole.
+// This assumes that the destination CRS is geographic.
+bool OGRProjCT::ContainsSouthPole(
+    const double xmin,
+    const double ymin,
+    const double xmax,
+    const double ymax,
+    bool lon_lat_order
+) {
+    double pole_y = -90;
+    double pole_x = 0;
+    if (!lon_lat_order) {
+        pole_y = 0;
+        pole_x = -90;
+    }
+    auto inverseCT = GetInverse();
+    if (!inverseCT)
+        return false;
+    inverseCT->TransformWithErrorCodes(
+        1,
+        &pole_x,
+        &pole_y,
+        nullptr,
+        nullptr,
+        nullptr
+    );
+    delete inverseCT;
+    if (xmin < pole_x && pole_x < xmax && ymax > pole_y && pole_y > ymin)
+        return true;
+    return false;
+}
+
+
+int OGRProjCT::TransformBounds(
+    const double xmin,
+    const double ymin,
+    const double xmax,
+    const double ymax,
+    double* out_xmin,
+    double* out_ymin,
+    double* out_xmax,
+    double* out_ymax,
+    const int densify_pts
+) {
+
+    if ( bNoTransform ) {
+        *out_xmin = xmin;
+        *out_ymin = ymin;
+        *out_xmax = xmax;
+        *out_ymax = ymax;
+        return true;
+    }
+
+    *out_xmin = HUGE_VAL;
+    *out_ymin = HUGE_VAL;
+    *out_xmax = HUGE_VAL;
+    *out_ymax = HUGE_VAL;
+
+    if (densify_pts < 0 || densify_pts > 10000) {
+        CPLError(CE_Failure, CPLE_AppDefined,
+        "densify_pts must be between 0-10000.");
+        return false;
+    }
+    if (!poSRSSource) {
+        CPLError(CE_Failure, CPLE_AppDefined,
+        "missing source SRS.");
+        return false;
+    }
+    if (!poSRSTarget) {
+        CPLError(CE_Failure, CPLE_AppDefined,
+        "missing target SRS.");
+        return false;
+    }
+
+    bool degree_input = false;
+    bool degree_output = false;
+    bool input_lon_lat_order = false;
+    bool output_lon_lat_order = false;
+
+    if( bSourceLatLong )
+    {
+        degree_input = fabs(poSRSSource->GetAngularUnits(nullptr) -
+                            CPLAtof(SRS_UA_DEGREE_CONV)) < 1e-8;
+        OGRAxisOrientation source_orientation;
+        const auto& mapping = poSRSSource->GetDataAxisToSRSAxisMapping();
+        int axis_index = 0;
+        if( mapping[0] != 1 && mapping[0] != -1 )
+            axis_index = 1;
+        poSRSSource->GetAxis(nullptr, axis_index, &source_orientation);
+        if( source_orientation == OAO_East )
+            input_lon_lat_order = true;
+    }
+    if( bTargetLatLong )
+    {
+        degree_output = fabs(poSRSTarget->GetAngularUnits(nullptr) -
+                            CPLAtof(SRS_UA_DEGREE_CONV)) < 1e-8;
+        OGRAxisOrientation target_orientation;
+        const auto& mapping = poSRSTarget->GetDataAxisToSRSAxisMapping();
+        int axis_index = 0;
+        if( mapping[0] != 1 && mapping[0] != -1 )
+            axis_index = 1;
+        poSRSTarget->GetAxis(nullptr, axis_index, &target_orientation);
+        if( target_orientation == OAO_East )
+            output_lon_lat_order = true;
+    }
+
+    if (degree_output && densify_pts < 2) {
+        CPLError(CE_Failure, CPLE_AppDefined,
+        "densify_pts must be at least 2 if the output is geograpic.");
+        return false;
+    }
+
+    int side_pts = densify_pts + 1;  // add one because we are densifying
+    const int boundary_len = side_pts * 4;
+    std::vector<double> x_boundary_array;
+    std::vector<double> y_boundary_array;
+    try
+    {
+        x_boundary_array.resize(boundary_len);
+        y_boundary_array.resize(boundary_len);
+    }
+    catch( const std::exception & e ) // memory allocation failure
+    {
+        CPLError(CE_Failure, CPLE_AppDefined, "%s", e.what());
+        return false;
+    }
+    double delta_x = 0;
+    double delta_y = 0;
+    bool north_pole_in_bounds = false;
+    bool south_pole_in_bounds = false;
+    if (degree_output) {
+        north_pole_in_bounds = ContainsNorthPole(
+            xmin,
+            ymin,
+            xmax,
+            ymax,
+            output_lon_lat_order
+        );
+        south_pole_in_bounds = ContainsSouthPole(
+            xmin,
+            ymin,
+            xmax,
+            ymax,
+            output_lon_lat_order
+        );
+    }
+
+    if (degree_input && xmax < xmin) {
+        if (!input_lon_lat_order) {
+            CPLError(CE_Failure, CPLE_AppDefined, "latitude max < latitude min.");
+            return false;
+        }
+        // handle antimeridian
+        delta_x = (xmax - xmin + 360.0) / side_pts;
+    } else {
+        delta_x = (xmax - xmin) / side_pts;
+    }
+    if (degree_input && ymax < ymin) {
+        if (input_lon_lat_order) {
+            CPLError(CE_Failure, CPLE_AppDefined, "latitude max < latitude min.");
+            return false;
+        }
+        // handle antimeridian
+        delta_y = (ymax - ymin + 360.0) / side_pts;
+    } else {
+        delta_y = (ymax - ymin) / side_pts;
+    }
+
+
+    // build densified bounding box
+    // Note: must be a linear ring for antimeridian logic
+    for( int iii = 0; iii < side_pts; iii++ )
+    {
+        // xmin boundary
+        y_boundary_array[iii] = ymax - iii * delta_y;
+        x_boundary_array[iii] = xmin;
+        // ymin boundary
+        y_boundary_array[iii + side_pts] = ymin;
+        x_boundary_array[iii + side_pts] = xmin + iii * delta_x;
+        // xmax boundary
+        y_boundary_array[iii + side_pts * 2] = ymin + iii * delta_y;
+        x_boundary_array[iii + side_pts * 2] = xmax;
+        // ymax boundary
+        y_boundary_array[iii + side_pts * 3] = ymax;
+        x_boundary_array[iii + side_pts * 3] = xmax - iii * delta_x;
+    }
+
+    TransformWithErrorCodes(
+        boundary_len,
+        &x_boundary_array[0],
+        &y_boundary_array[0],
+        nullptr,
+        nullptr,
+        nullptr
+    );
+
+    if (!degree_output) {
+        *out_xmin = simple_min(&x_boundary_array[0], boundary_len);
+        *out_xmax = simple_max(&x_boundary_array[0], boundary_len);
+        *out_ymin = simple_min(&y_boundary_array[0], boundary_len);
+        *out_ymax = simple_max(&y_boundary_array[0], boundary_len);
+    } else if (north_pole_in_bounds && output_lon_lat_order) {
+        *out_xmin = -180;
+        *out_ymin = simple_min(&y_boundary_array[0], boundary_len);
+        *out_xmax = 180;
+        *out_ymax = 90;
+    } else if (north_pole_in_bounds) {
+        *out_xmin = simple_min(&x_boundary_array[0], boundary_len);
+        *out_ymin = -180;
+        *out_xmax = 90;
+        *out_ymax = 180;
+    } else if (south_pole_in_bounds && output_lon_lat_order) {
+        *out_xmin = -180;
+        *out_ymin = -90;
+        *out_xmax = 180;
+        *out_ymax = simple_max(&y_boundary_array[0], boundary_len);
+    } else if (south_pole_in_bounds) {
+        *out_xmin = -90;
+        *out_ymin = -180;
+        *out_xmax = simple_max(&x_boundary_array[0], boundary_len);
+        *out_ymax = 180;
+    } else if (output_lon_lat_order) {
+        *out_xmin = antimeridian_min(&x_boundary_array[0], boundary_len);
+        *out_xmax = antimeridian_max(&x_boundary_array[0], boundary_len);
+        *out_ymin = simple_min(&y_boundary_array[0], boundary_len);
+        *out_ymax = simple_max(&y_boundary_array[0], boundary_len);
+    } else {
+        *out_xmin = simple_min(&x_boundary_array[0], boundary_len);
+        *out_xmax = simple_max(&x_boundary_array[0], boundary_len);
+        *out_ymin = antimeridian_min(&y_boundary_array[0], boundary_len);
+        *out_ymax = antimeridian_max(&y_boundary_array[0], boundary_len);
+    }
+    return true;
+}
+
+
+/************************************************************************/
+/*                               Clone()                                */
+/************************************************************************/
+
+OGRCoordinateTransformation* OGRProjCT::Clone() const
+{
+     std::unique_ptr<OGRProjCT> poNewCT(new OGRProjCT(*this));
+#if (PROJ_VERSION_MAJOR * 10000 + PROJ_VERSION_MINOR * 100 + PROJ_VERSION_PATCH) < 80001
+    // See https://github.com/OSGeo/PROJ/pull/2582
+    // This may fail before PROJ 8.0.1 if the m_pj object is a "meta"
+    // operation being a set of real operations
+    bool bCloneDone = ((m_pj == nullptr) == (poNewCT->m_pj == nullptr));
+    if(!bCloneDone)
+    {
+        poNewCT.reset(new OGRProjCT());
+        if(!poNewCT->Initialize(poSRSSource, poSRSTarget, m_options))
+        {
+            return nullptr;
+        }
+    }
+#endif //PROJ_VERSION
+    return poNewCT.release();
+}
+
+/************************************************************************/
+/*                            GetInverse()                              */
+/************************************************************************/
+
+OGRCoordinateTransformation* OGRProjCT::GetInverse() const
+{
+    PJ* new_pj = nullptr;
+    // m_pj can be nullptr if using m_eStrategy != PROJ
+    if( m_pj && !bWebMercatorToWGS84LongLat && !bNoTransform )
+    {
+        // See https://github.com/OSGeo/PROJ/pull/2582
+        // This may fail before PROJ 8.0.1 if the m_pj object is a "meta"
+        // operation being a set of real operations
+        new_pj = proj_clone(OSRGetProjTLSContext(), m_pj);
+    }
+
+    OGRCoordinateTransformationOptions newOptions(m_options);
+    std::swap(newOptions.d->bHasSourceCenterLong, newOptions.d->bHasTargetCenterLong);
+    std::swap(newOptions.d->dfSourceCenterLong, newOptions.d->dfTargetCenterLong);
+    newOptions.d->bReverseCO = !newOptions.d->bReverseCO;
+    newOptions.d->RefreshCheckWithInvertProj();
+
+    if( new_pj == nullptr && !bNoTransform )
+    {
+        return OGRCreateCoordinateTransformation(poSRSTarget, poSRSSource,
+                                                 newOptions);
+    }
+
+    auto poNewCT = new OGRProjCT();
+
+    if( poSRSTarget )
+        poNewCT->poSRSSource = poSRSTarget->Clone();
+    poNewCT->bSourceLatLong = bTargetLatLong;
+    poNewCT->bSourceWrap = bTargetWrap;
+    poNewCT->dfSourceWrapLong = dfTargetWrapLong;
+    poNewCT->bSourceIsDynamicCRS = bTargetIsDynamicCRS;
+    poNewCT->dfSourceCoordinateEpoch = dfTargetCoordinateEpoch;
+
+    if( poSRSSource )
+        poNewCT->poSRSTarget = poSRSSource->Clone();
+    poNewCT->bTargetLatLong = bSourceLatLong;
+    poNewCT->bTargetWrap = bSourceWrap;
+    poNewCT->dfTargetWrapLong = dfSourceWrapLong;
+    poNewCT->bTargetIsDynamicCRS = bSourceIsDynamicCRS;
+    poNewCT->dfTargetCoordinateEpoch = dfSourceCoordinateEpoch;
+
+    poNewCT->ComputeThreshold();
+
+    poNewCT->m_pj = new_pj;
+    poNewCT->m_bReversePj = !m_bReversePj;
+    poNewCT->bNoTransform = bNoTransform;
+    poNewCT->m_eStrategy = m_eStrategy;
+    poNewCT->m_options = newOptions;
+    return poNewCT;
+}
+
+/************************************************************************/
+/*                            OSRCTCleanCache()                         */
+/************************************************************************/
+
+void OSRCTCleanCache()
+{
+    std::lock_guard<std::mutex> oGuard(g_oCTCacheMutex);
+    delete g_poCTCache;
+    g_poCTCache = nullptr;
+}
+
+/************************************************************************/
+/*                          MakeCacheKey()                              */
+/************************************************************************/
+
+CTCacheKey OGRProjCT::MakeCacheKey(const OGRSpatialReference* poSRS1,
+                                    const OGRSpatialReference* poSRS2,
+                                    const OGRCoordinateTransformationOptions& options)
+{
+    const auto GetKeyForSRS = [](const OGRSpatialReference* poSRS)
+    {
+        if (poSRS)
+        {
+            char* pszText = GetWktOrProjString(poSRS);
+            std::string ret(pszText);
+            CPLFree(pszText);
+            const auto& mapping = poSRS->GetDataAxisToSRSAxisMapping();
+            for(const auto& axis: mapping)
+            {
+                ret += std::to_string(axis);
+            }
+            return ret;
+        }
+        else
+        {
+            return std::string("null");
+        }
+    };
+
+    std::string ret( GetKeyForSRS(poSRS1) );
+    ret += GetKeyForSRS(poSRS2);
+    ret += options.d->GetKey();
+    return ret;
+}
+
+/************************************************************************/
+/*                           InsertIntoCache()                          */
+/************************************************************************/
+
+void OGRProjCT::InsertIntoCache( OGRProjCT* poCT )
+{
+    std::lock_guard<std::mutex> oGuard(g_oCTCacheMutex);
+    if( g_poCTCache == nullptr )
+    {
+        g_poCTCache = new lru11::Cache<CTCacheKey, CTCacheValue>();
+    }
+    const auto key = MakeCacheKey(poCT->poSRSSource, poCT->poSRSTarget,
+                                  poCT->m_options);
+    if( g_poCTCache->contains(key) )
+    {
+        delete poCT;
+        return;
+    }
+    g_poCTCache->insert(key, std::make_shared<std::unique_ptr<OGRProjCT>>(
+                                            std::unique_ptr<OGRProjCT>(poCT)));
+}
+
+/************************************************************************/
+/*                            FindFromCache()                           */
+/************************************************************************/
+
+OGRProjCT* OGRProjCT::FindFromCache( const OGRSpatialReference *poSource,
+                                     const OGRSpatialReference *poTarget,
+                                     const OGRCoordinateTransformationOptions& options )
+{
+    std::lock_guard<std::mutex> oGuard(g_oCTCacheMutex);
+    if( g_poCTCache == nullptr || g_poCTCache->empty() )
+        return nullptr;
+
+    const auto key = MakeCacheKey(poSource, poTarget, options);
+    // Get value from cache and remove it
+    CTCacheValue holder;
+    if( g_poCTCache->tryGet(key, holder) )
+    {
+        auto poCT = holder->release();
+        g_poCTCache->remove(key);
+        return poCT;
+    }
+    return nullptr;
+}
+
+//! @endcond
+
+/************************************************************************/
+/*                            OCTTransform()                            */
+/************************************************************************/
+
+/** Transform an array of points
+ *
+ * @param hTransform Transformation object
+ * @param nCount Number of points
+ * @param x Array of nCount x values.
+ * @param y Array of nCount y values.
+ * @param z Array of nCount z values.
+ * @return TRUE or FALSE
+ */
+int CPL_STDCALL OCTTransform( OGRCoordinateTransformationH hTransform,
+                              int nCount, double *x, double *y, double *z )
+
+{
+    VALIDATE_POINTER1( hTransform, "OCTTransform", FALSE );
+
+    return OGRCoordinateTransformation::FromHandle(hTransform)->
+        Transform( nCount, x, y, z );
+}
+
+/************************************************************************/
+/*                           OCTTransformEx()                           */
+/************************************************************************/
+
+/** Transform an array of points
+ *
+ * @param hTransform Transformation object
+ * @param nCount Number of points
+ * @param x Array of nCount x values.
+ * @param y Array of nCount y values.
+ * @param z Array of nCount z values.
+ * @param pabSuccess Output array of nCount value that will be set to TRUE/FALSE
+ * @return TRUE or FALSE
+ */
+int CPL_STDCALL OCTTransformEx( OGRCoordinateTransformationH hTransform,
+                                int nCount, double *x, double *y, double *z,
+                                int *pabSuccess )
+
+{
+    VALIDATE_POINTER1( hTransform, "OCTTransformEx", FALSE );
+
+    return OGRCoordinateTransformation::FromHandle(hTransform)->
+        Transform( nCount, x, y, z, pabSuccess );
+}
+
+/************************************************************************/
+/*                           OCTTransform4D()                           */
+/************************************************************************/
+
+/** Transform an array of points
+ *
+ * @param hTransform Transformation object
+ * @param nCount Number of points
+ * @param x Array of nCount x values. Should not be NULL
+ * @param y Array of nCount y values. Should not be NULL
+ * @param z Array of nCount z values. Might be NULL
+ * @param t Array of nCount time values. Might be NULL
+ * @param pabSuccess Output array of nCount value that will be set to TRUE/FALSE. Might be NULL.
+ * @since GDAL 3.0
+ * @return TRUE or FALSE
+ */
+int OCTTransform4D( OGRCoordinateTransformationH hTransform,
+                    int nCount, double *x, double *y, double *z,
+                    double *t,
+                    int *pabSuccess )
+
+{
+    VALIDATE_POINTER1( hTransform, "OCTTransform4D", FALSE );
+
+    return OGRCoordinateTransformation::FromHandle(hTransform)->
+        Transform( nCount, x, y, z, t, pabSuccess );
+}
+
+/************************************************************************/
+/*                      OCTTransform4DWithErrorCodes()                  */
+/************************************************************************/
+
+/** Transform an array of points
+ *
+ * @param hTransform Transformation object
+ * @param nCount Number of points
+ * @param x Array of nCount x values. Should not be NULL
+ * @param y Array of nCount y values. Should not be NULL
+ * @param z Array of nCount z values. Might be NULL
+ * @param t Array of nCount time values. Might be NULL
+ * @param panErrorCodes Output array of nCount value that will be set to 0 for
+ *                      success, or a non-zero value for failure. Refer to
+ *                      PROJ 8 public error codes. Might be NULL
+ * @since GDAL 3.3, and PROJ 8 to be able to use PROJ public error codes
+ * @return TRUE or FALSE
+ */
+int OCTTransform4DWithErrorCodes( OGRCoordinateTransformationH hTransform,
+                    int nCount, double *x, double *y, double *z,
+                    double *t,
+                    int *panErrorCodes )
+
+{
+    VALIDATE_POINTER1( hTransform, "OCTTransform4DWithErrorCodes", FALSE );
+
+    return OGRCoordinateTransformation::FromHandle(hTransform)->
+        TransformWithErrorCodes( nCount, x, y, z, t, panErrorCodes );
+}
+
+
+/************************************************************************/
+/*                           OCTTransformBounds()                           */
+/************************************************************************/
+/** \brief Transform boundary.
+ *
+ * Transform boundary densifying the edges to account for nonlinear
+ * transformations along these edges and extracting the outermost bounds.
+ *
+ * If the destination CRS is geographic, the first axis is longitude,
+ * and xmax < xmin then the bounds crossed the antimeridian.
+ * In this scenario there are two polygons, one on each side of the antimeridian.
+ * The first polygon should be constructed with (xmin, ymin, 180, ymax)
+ * and the second with (-180, ymin, xmax, ymax).
+ *
+ * If the destination CRS is geographic, the first axis is latitude,
+ * and ymax < ymin then the bounds crossed the antimeridian.
+ * In this scenario there are two polygons, one on each side of the antimeridian.
+ * The first polygon should be constructed with (ymin, xmin, ymax, 180)
+ * and the second with (ymin, -180, ymax, xmax).
+ *
+ * @param hTransform Transformation object
+ * @param xmin Minimum bounding coordinate of the first axis in source CRS.
+ * @param ymin Minimum bounding coordinate of the second axis in source CRS.
+ * @param xmax Maximum bounding coordinate of the first axis in source CRS.
+ * @param ymax Maximum bounding coordinate of the second axis in source CRS.
+ * @param out_xmin Minimum bounding coordinate of the first axis in target CRS
+ * @param out_ymin Minimum bounding coordinate of the second axis in target CRS.
+ * @param out_xmax Maximum bounding coordinate of the first axis in target CRS.
+ * @param out_ymax Maximum bounding coordinate of the second axis in target CRS.
+ * @param densify_pts Recommended to use 21. This is the number of points
+ *     to use to densify the bounding polygon in the transformation.
+ * @return TRUE if successful. FALSE if failures encountered.
+ * @since 3.4
+ */
+int CPL_STDCALL OCTTransformBounds( OGRCoordinateTransformationH hTransform,
+                                    const double xmin,
+                                    const double ymin,
+                                    const double xmax,
+                                    const double ymax,
+                                    double* out_xmin,
+                                    double* out_ymin,
+                                    double* out_xmax,
+                                    double* out_ymax,
+                                    int densify_pts )
+
+{
+    VALIDATE_POINTER1( hTransform, "TransformBounds", FALSE );
+
+    return OGRProjCT::FromHandle(hTransform)->
+        TransformBounds(
+            xmin, ymin, xmax, ymax, out_xmin, out_ymin, out_xmax, out_ymax, densify_pts
+        );
+}
+
+/************************************************************************/
+/*                         OGRCTDumpStatistics()                        */
+/************************************************************************/
+
+void OGRCTDumpStatistics()
+{
+#ifdef DEBUG_PERF
+    CPLDebug("OGR_CT", "Total time in proj_create_crs_to_crs(): %d ms",
+             static_cast<int>(g_dfTotalTimeCRStoCRS * 1000));
+    CPLDebug("OGR_CT", "Total time in coordinate transformation: %d ms",
+             static_cast<int>(g_dfTotalTimeReprojection * 1000));
+#endif
+}
diff -Nru gdal-3.5.0-orig/ogr/ogrsf_frmts/sqlite/ogrsqliteutility.cpp gdal-3.5.0-patched/ogr/ogrsf_frmts/sqlite/ogrsqliteutility.cpp
--- gdal-3.5.0-orig/ogr/ogrsf_frmts/sqlite/ogrsqliteutility.cpp	2022-05-10 10:03:38.000000000 -0400
+++ gdal-3.5.0-patched/ogr/ogrsf_frmts/sqlite/ogrsqliteutility.cpp	2022-09-13 14:35:48.582070744 -0400
@@ -349,7 +349,8 @@
     std::set<std::string> uniqueFieldsUC;
 
     // std::regex in gcc < 4.9 is broken
-#if !defined(__GNUC__) || defined(__clang__) || __GNUC__ >= 5
+    // seems still broken in newer versions, including gcc 10.3
+#if 0
 
     try
     {
diff -Nru gdal-3.5.0-orig/port/cpl_port.h gdal-3.5.0-patched/port/cpl_port.h
--- gdal-3.5.0-orig/port/cpl_port.h	2022-05-10 10:03:38.000000000 -0400
+++ gdal-3.5.0-patched/port/cpl_port.h	2022-09-13 14:32:47.643089147 -0400
@@ -113,15 +113,6 @@
 /*      MinGW stuff                                                     */
 /* ==================================================================== */
 
-/* We need __MSVCRT_VERSION__ >= 0x0700 to have "_aligned_malloc" */
-/* Latest versions of mingw32 define it, but with older ones, */
-/* we need to define it manually */
-#if defined(__MINGW32__)
-#ifndef __MSVCRT_VERSION__
-#define __MSVCRT_VERSION__ 0x0700
-#endif
-#endif
-
 /* Needed for std=c11 on Solaris to have strcasecmp() */
 #if defined(GDAL_COMPILATION) && defined(__sun__) && (__STDC_VERSION__ + 0) >= 201112L && (_XOPEN_SOURCE + 0) < 600
 #ifdef _XOPEN_SOURCE
