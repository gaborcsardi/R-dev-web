diff -ru glib-2.53.7-orig/configure.ac glib-2.53.7-new/configure.ac
--- glib-2.53.7-orig/configure.ac	2017-09-04 09:02:32.000000000 -0400
+++ glib-2.53.7-new/configure.ac	2021-01-06 10:10:57.997827199 -0500
@@ -508,6 +508,8 @@
 dnl when using libtool 2.x create libtool early, because it's used in configure
 m4_ifdef([LT_OUTPUT], [LT_OUTPUT])
 
+# Make sure STDC_HEADERS is set for AC_CHECK_ALIGNOF
+AS_IF([false], [AC_CHECK_HEADER([stdint.h])])
 
 AS_IF([test "$glib_native_win32" = "yes"], [
   if test x$enable_static = xyes -a x$enable_shared = xyes; then
@@ -1605,10 +1607,16 @@
 dnl ** Check for inotify (GIO) **
 dnl *****************************
 inotify_support=no
+ AC_ARG_ENABLE(inotify,
+               AC_HELP_STRING([--disable-inotify],
+                              [build without inotify support]))
+
+ if test "x$enable_inotify" != "xno"; then
 AC_CHECK_HEADERS([sys/inotify.h],
 [
   AC_CHECK_FUNCS(inotify_init1, [inotify_support=yes], [inotify_support=no])
 ])
+fi
 
 AM_CONDITIONAL(HAVE_INOTIFY, [test "$inotify_support" = "yes"])
 
Only in glib-2.53.7-new/: configure.ac.orig
diff -ru glib-2.53.7-orig/gio/gdbusaddress.c glib-2.53.7-new/gio/gdbusaddress.c
--- glib-2.53.7-orig/gio/gdbusaddress.c	2017-08-07 10:58:31.000000000 -0400
+++ glib-2.53.7-new/gio/gdbusaddress.c	2021-01-06 10:10:58.001827194 -0500
@@ -1396,6 +1396,7 @@
 __declspec(dllexport) void CALLBACK
 g_win32_run_session_bus (HWND hwnd, HINSTANCE hinst, char *cmdline, int nCmdShow)
 {
+  /*
   GDBusDaemon *daemon;
   GMainLoop *loop;
   const char *address;
@@ -1428,6 +1429,7 @@
 
   g_main_loop_unref (loop);
   g_object_unref (daemon);
+  */
 }
 
 static gchar *
Only in glib-2.53.7-new/gio: gdbusaddress.c.orig
diff -ru glib-2.53.7-orig/gio/gdbusauth.c glib-2.53.7-new/gio/gdbusauth.c
--- glib-2.53.7-orig/gio/gdbusauth.c	2017-07-13 19:03:38.000000000 -0400
+++ glib-2.53.7-new/gio/gdbusauth.c	2021-01-06 10:11:10.713812660 -0500
@@ -1302,9 +1302,9 @@
                                                     &line_length,
                                                     cancellable,
                                                     error);
-          debug_print ("SERVER: WaitingForBegin, read '%s'", line);
           if (line == NULL)
             goto out;
+          debug_print ("SERVER: WaitingForBegin, read '%s'", line);
           if (g_strcmp0 (line, "BEGIN") == 0)
             {
               /* YAY, done! */
Only in glib-2.53.7-new/gio: gdbusauth.c.orig
diff -ru glib-2.53.7-orig/gio/gdbusmessage.c glib-2.53.7-new/gio/gdbusmessage.c
--- glib-2.53.7-orig/gio/gdbusmessage.c	2017-08-07 10:58:31.000000000 -0400
+++ glib-2.53.7-new/gio/gdbusmessage.c	2021-01-06 10:11:10.713812660 -0500
@@ -2697,7 +2697,6 @@
   if (message->body != NULL)
     {
       gchar *tupled_signature_str;
-      tupled_signature_str = g_strdup_printf ("(%s)", signature_str);
       if (signature == NULL)
         {
           g_set_error (error,
@@ -2705,10 +2704,10 @@
                        G_IO_ERROR_INVALID_ARGUMENT,
                        _("Message body has signature “%s” but there is no signature header"),
                        signature_str);
-          g_free (tupled_signature_str);
           goto out;
         }
-      else if (g_strcmp0 (tupled_signature_str, g_variant_get_type_string (message->body)) != 0)
+      tupled_signature_str = g_strdup_printf ("(%s)", signature_str);
+      if (g_strcmp0 (tupled_signature_str, g_variant_get_type_string (message->body)) != 0)
         {
           g_set_error (error,
                        G_IO_ERROR,
Only in glib-2.53.7-new/gio: gdbusmessage.c.orig
diff -ru glib-2.53.7-orig/gio/giomodule.c glib-2.53.7-new/gio/giomodule.c
--- glib-2.53.7-orig/gio/giomodule.c	2017-07-13 19:03:38.000000000 -0400
+++ glib-2.53.7-new/gio/giomodule.c	2021-01-06 10:10:57.993827204 -0500
@@ -935,14 +935,12 @@
 
 static HMODULE gio_dll = NULL;
 
-#ifdef DLL_EXPORT
-
-BOOL WINAPI DllMain (HINSTANCE hinstDLL,
+BOOL WINAPI gio_DllMain (HINSTANCE hinstDLL,
                      DWORD     fdwReason,
                      LPVOID    lpvReserved);
 
 BOOL WINAPI
-DllMain (HINSTANCE hinstDLL,
+gio_DllMain (HINSTANCE hinstDLL,
 	 DWORD     fdwReason,
 	 LPVOID    lpvReserved)
 {
@@ -952,8 +950,6 @@
   return TRUE;
 }
 
-#endif
-
 void *
 _g_io_win32_get_module (void)
 {
Only in glib-2.53.7-new/gio: giomodule.c.orig
diff -ru glib-2.53.7-orig/gio-2.0.pc.in glib-2.53.7-new/gio-2.0.pc.in
--- glib-2.53.7-orig/gio-2.0.pc.in	2017-02-13 10:53:27.000000000 -0500
+++ glib-2.53.7-new/gio-2.0.pc.in	2021-01-06 10:12:14.233740070 -0500
@@ -13,6 +13,6 @@
 Version: @VERSION@
 Requires: glib-2.0 gobject-2.0
 Requires.private: gmodule-no-export-2.0
-Libs: -L${libdir} -lgio-2.0
+Libs: -L${libdir} -lgio-2.0 -ldnsapi -liphlpapi
 Libs.private: @ZLIB_LIBS@ @NETWORK_LIBS@ @SELINUX_LIBS@ @COCOA_LIBS@ @CARBON_LIBS@ @LIBMOUNT_LIBS@
 Cflags:
Only in glib-2.53.7-new/: gio-2.0.pc.in~
Only in glib-2.53.7-new/: gio-2.0.pc.in.orig
diff -ru glib-2.53.7-orig/glib/glib-init.c glib-2.53.7-new/glib/glib-init.c
--- glib-2.53.7-orig/glib/glib-init.c	2017-07-13 19:03:39.000000000 -0400
+++ glib-2.53.7-new/glib/glib-init.c	2021-01-06 10:10:57.993827204 -0500
@@ -275,14 +275,14 @@
 
 #if defined (G_OS_WIN32)
 
-BOOL WINAPI DllMain (HINSTANCE hinstDLL,
+BOOL WINAPI glib_DllMain (HINSTANCE hinstDLL,
                      DWORD     fdwReason,
                      LPVOID    lpvReserved);
 
 HMODULE glib_dll;
 
 BOOL WINAPI
-DllMain (HINSTANCE hinstDLL,
+glib_DllMain (HINSTANCE hinstDLL,
          DWORD     fdwReason,
          LPVOID    lpvReserved)
 {
Only in glib-2.53.7-new/glib: glib-init.c.orig
Only in glib-2.53.7-new/glib: gmain.c.orig
diff -ru glib-2.53.7-orig/glib/gthread-win32.c glib-2.53.7-new/glib/gthread-win32.c
--- glib-2.53.7-orig/glib/gthread-win32.c	2017-07-13 19:03:39.000000000 -0400
+++ glib-2.53.7-new/glib/gthread-win32.c	2021-01-06 10:10:58.001827194 -0500
@@ -116,18 +116,28 @@
   void     (__stdcall * WakeConditionVariable)       (gpointer cond);
 } GThreadImplVtable;
 
+/* Needed for static builds where DllMain initializer doesn't get called */
+static gboolean g_threads_is_initialized;
+G_GNUC_INTERNAL void g_thread_win32_init (void);
+
 static GThreadImplVtable g_thread_impl_vtable;
 
 /* {{{1 GMutex */
 void
 g_mutex_init (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.InitializeSRWLock (mutex);
 }
 
 void
 g_mutex_clear (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   if (g_thread_impl_vtable.DeleteSRWLock != NULL)
     g_thread_impl_vtable.DeleteSRWLock (mutex);
 }
@@ -135,18 +145,27 @@
 void
 g_mutex_lock (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.AcquireSRWLockExclusive (mutex);
 }
 
 gboolean
 g_mutex_trylock (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   return g_thread_impl_vtable.TryAcquireSRWLockExclusive (mutex);
 }
 
 void
 g_mutex_unlock (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.ReleaseSRWLockExclusive (mutex);
 }
 
@@ -157,6 +176,9 @@
 {
   CRITICAL_SECTION *cs;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   cs = g_slice_new (CRITICAL_SECTION);
   InitializeCriticalSection (cs);
 
@@ -167,6 +189,10 @@
 g_rec_mutex_impl_free (CRITICAL_SECTION *cs)
 {
   DeleteCriticalSection (cs);
+
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_slice_free (CRITICAL_SECTION, cs);
 }
 
@@ -175,6 +201,9 @@
 {
   CRITICAL_SECTION *impl = mutex->p;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   if G_UNLIKELY (mutex->p == NULL)
     {
       impl = g_rec_mutex_impl_new ();
@@ -189,30 +218,45 @@
 void
 g_rec_mutex_init (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   mutex->p = g_rec_mutex_impl_new ();
 }
 
 void
 g_rec_mutex_clear (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_rec_mutex_impl_free (mutex->p);
 }
 
 void
 g_rec_mutex_lock (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   EnterCriticalSection (g_rec_mutex_get_impl (mutex));
 }
 
 void
 g_rec_mutex_unlock (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   LeaveCriticalSection (mutex->p);
 }
 
 gboolean
 g_rec_mutex_trylock (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   return TryEnterCriticalSection (g_rec_mutex_get_impl (mutex));
 }
 
@@ -221,12 +265,18 @@
 void
 g_rw_lock_init (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.InitializeSRWLock (lock);
 }
 
 void
 g_rw_lock_clear (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   if (g_thread_impl_vtable.DeleteSRWLock != NULL)
     g_thread_impl_vtable.DeleteSRWLock (lock);
 }
@@ -234,36 +284,54 @@
 void
 g_rw_lock_writer_lock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.AcquireSRWLockExclusive (lock);
 }
 
 gboolean
 g_rw_lock_writer_trylock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   return g_thread_impl_vtable.TryAcquireSRWLockExclusive (lock);
 }
 
 void
 g_rw_lock_writer_unlock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.ReleaseSRWLockExclusive (lock);
 }
 
 void
 g_rw_lock_reader_lock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.AcquireSRWLockShared (lock);
 }
 
 gboolean
 g_rw_lock_reader_trylock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   return g_thread_impl_vtable.TryAcquireSRWLockShared (lock);
 }
 
 void
 g_rw_lock_reader_unlock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.ReleaseSRWLockShared (lock);
 }
 
@@ -271,12 +339,18 @@
 void
 g_cond_init (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.InitializeConditionVariable (cond);
 }
 
 void
 g_cond_clear (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   if (g_thread_impl_vtable.DeleteConditionVariable)
     g_thread_impl_vtable.DeleteConditionVariable (cond);
 }
@@ -284,12 +358,18 @@
 void
 g_cond_signal (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.WakeConditionVariable (cond);
 }
 
 void
 g_cond_broadcast (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.WakeAllConditionVariable (cond);
 }
 
@@ -297,6 +377,9 @@
 g_cond_wait (GCond  *cond,
              GMutex *entered_mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.SleepConditionVariableSRW (cond, entered_mutex, INFINITE, 0);
 }
 
@@ -307,6 +390,9 @@
 {
   gint64 span;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   span = end_time - g_get_monotonic_time ();
 
   if G_UNLIKELY (span < 0)
@@ -339,6 +425,9 @@
 
   if G_UNLIKELY (impl == 0)
     {
+      if (!g_threads_is_initialized)
+        g_thread_win32_init ();
+
       EnterCriticalSection (&g_private_lock);
       impl = (DWORD) key->p;
       if (impl == 0)
@@ -432,6 +521,9 @@
 {
   GThreadWin32 *wt = (GThreadWin32 *) thread;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   win32_check_for_error (CloseHandle (wt->handle));
   g_slice_free (GThreadWin32, wt);
 }
@@ -439,6 +531,9 @@
 void
 g_system_thread_exit (void)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   _endthreadex (0);
 }
 
@@ -447,6 +542,9 @@
 {
   GThreadWin32 *self = data;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   self->proxy (self);
 
   g_system_thread_exit ();
@@ -464,6 +562,9 @@
   GThreadWin32 *thread;
   guint ignore;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   thread = g_slice_new0 (GThreadWin32);
   thread->proxy = func;
 
@@ -493,6 +594,9 @@
 {
   GThreadWin32 *wt = (GThreadWin32 *) thread;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   win32_check_for_error (WAIT_FAILED != WaitForSingleObject (wt->handle, INFINITE));
 }
 
@@ -1041,6 +1145,8 @@
 void
 g_thread_win32_init (void)
 {
+  g_threads_is_initialized = TRUE;
+
   if (!g_thread_lookup_native_funcs ())
     g_thread_xp_init ();
 
diff -ru glib-2.53.7-orig/glib-2.0.pc.in glib-2.53.7-new/glib-2.0.pc.in
--- glib-2.53.7-orig/glib-2.0.pc.in	2016-10-22 01:17:22.000000000 -0400
+++ glib-2.53.7-new/glib-2.0.pc.in	2021-01-06 10:10:57.993827204 -0500
@@ -3,9 +3,9 @@
 libdir=@libdir@
 includedir=@includedir@
 
-glib_genmarshal=glib-genmarshal
-gobject_query=gobject-query
-glib_mkenums=glib-mkenums
+glib_genmarshal=@bindir@/glib-genmarshal
+gobject_query=@bindir@/gobject-query
+glib_mkenums=@bindir@/glib-mkenums
 
 Name: GLib
 Description: C Utility Library
diff -ru glib-2.53.7-orig/gobject/gtype.c glib-2.53.7-new/gobject/gtype.c
--- glib-2.53.7-orig/gobject/gtype.c	2017-07-13 19:03:39.000000000 -0400
+++ glib-2.53.7-new/gobject/gtype.c	2021-01-06 10:10:57.993827204 -0500
@@ -4451,7 +4451,7 @@
   _g_signal_init ();
 }
 
-#if defined (G_OS_WIN32)
+#if 0
 
 BOOL WINAPI DllMain (HINSTANCE hinstDLL,
                      DWORD     fdwReason,
Only in glib-2.53.7-new/gobject: gtype.c.orig
diff -ru glib-2.53.7-orig/m4macros/glib-gettext.m4 glib-2.53.7-new/m4macros/glib-gettext.m4
--- glib-2.53.7-orig/m4macros/glib-gettext.m4	2017-04-08 01:45:37.000000000 -0400
+++ glib-2.53.7-new/m4macros/glib-gettext.m4	2021-01-06 10:10:58.001827194 -0500
@@ -36,8 +36,8 @@
 dnl try to pull in the installed version of these macros
 dnl when running aclocal in the glib directory.
 dnl
-m4_copy([AC_DEFUN],[glib_DEFUN])
-m4_copy([AC_REQUIRE],[glib_REQUIRE])
+m4_copy_force([AC_DEFUN],[glib_DEFUN])
+m4_copy_force([AC_REQUIRE],[glib_REQUIRE])
 dnl
 dnl At the end, if we're not within glib, we'll define the public
 dnl definitions in terms of our private definitions.
