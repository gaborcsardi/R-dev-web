diff -Nru orig/mpmi/COPYING patched/mpi/COPYING
--- orig/mpmi/COPYING	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/COPYING	1969-12-31 16:00:00.000000000 -0800
@@ -1,675 +0,0 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  If the program does terminal interaction, make it output a short
-notice like this when it starts in an interactive mode:
-
-    <program>  Copyright (C) <year>  <name of author>
-    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, your program's commands
-might be different; for a GUI interface, you would use an "about box".
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU GPL, see
-<http://www.gnu.org/licenses/>.
-
-  The GNU General Public License does not permit incorporating your program
-into proprietary programs.  If your program is a subroutine library, you
-may consider it more useful to permit linking proprietary applications with
-the library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.  But first, please read
-<http://www.gnu.org/philosophy/why-not-lgpl.html>.
- 
diff -Nru orig/mpmi/DESCRIPTION patched/mpi/DESCRIPTION
--- orig/mpmi/DESCRIPTION	2020-04-24 11:42:02.000000000 -0700
+++ patched/mpi/DESCRIPTION	1969-12-31 16:00:00.000000000 -0800
@@ -1,20 +0,0 @@
-Package: mpmi
-Type: Package
-Title: Mixed-Pair Mutual Information Estimators
-Version: 0.43.1
-Date: 2019-04-22
-Author: Chris Pardy
-Maintainer: Chris Pardy <cooliomcdude@gmail.com>
-Description: Uses a kernel smoothing approach to calculate Mutual Information
-    for comparisons between all types of variables including continuous vs
-    continuous, continuous vs discrete and discrete vs discrete. Uses a
-    nonparametric bias correction giving Bias Corrected Mutual Information
-    (BCMI). Implemented efficiently in Fortran 95 with OpenMP and suited to
-    large genomic datasets.  
-License: GPL-3
-URL: http://r-forge.r-project.org/projects/mpmi/
-Depends: R(>= 3.6.2), KernSmooth
-NeedsCompilation: yes
-Packaged: 2019-10-30 10:28:15 UTC; ripley
-Repository: CRAN
-Date/Publication: 2020-04-24 18:42:02 UTC
diff -Nru orig/mpmi/MD5 patched/mpi/MD5
--- orig/mpmi/MD5	2020-04-24 11:42:02.000000000 -0700
+++ patched/mpi/MD5	1969-12-31 16:00:00.000000000 -0800
@@ -1,31 +0,0 @@
-685c571e44fba386372b4c39d8b5bcf7 *COPYING
-912ccee877d835272bee0e21f3dcd37b *DESCRIPTION
-21244b6cca0a29abd21eb5ab7a274d8a *NAMESPACE
-8e922d324a0ca1991e59c9ae40f283c1 *NEWS
-18c7efda3491ed0f93a008c2a399a411 *R/cmi.R
-9fe8c20e455ba05adb8d59ac0315df23 *R/cminjk.R
-0c49e720a897be3cf9f90cccb298e41f *R/dmif.R
-6e7483c371e6c83af1f579fb51c89c6c *R/dpikSafe.R
-8d703aa7046919963756094ad1894ea9 *R/mmi.R
-accf11ec4a3d2a98ac1961fde69f98b8 *R/mminjk.R
-4180554be186c5bfed70deebe670c42b *R/mp.R
-7096a40529a7c357f3e459a988461dd5 *build/vignette.rds
-2ffe31d9ec49fc259012b57a85540bf6 *data/mpmidata.RData
-896a4a6c0b079863e34d9d375d7f2b53 *inst/doc/Vignette.R
-5ff5e6e54db7d5827746a42af59b1e45 *inst/doc/Vignette.Rnw
-c9ca003356b67612cf3ef3d973806922 *inst/doc/Vignette.pdf
-d68b7e2c86671168c1a2d8914cd714da *man/cmi.Rd
-e035de7be3d043da488edc1cde945a31 *man/cts.Rd
-9b79396df95fe59e4481047eab1949db *man/disc.Rd
-d9ad8d2dd96c4e2fc213a00d7440904e *man/dmi.Rd
-b7df309f899c2d00792b4f890fe0fa32 *man/mmi.Rd
-0d35fe5d8bbc931ee0cd1f355e43d018 *man/mp.Rd
-ebcb5247b1d8903b32a8d195182d336b *src/10iface.f95
-5d181ebae5c498dec7dfede09bfd77b1 *src/Makevars
-807773a23e7afc9538006d45918bbc1f *src/cmi.f95
-5a5eb0e38ac9c22e4f4acf328d941788 *src/cminjk.f95
-26d4bfa9010060e294703ccf1bc0ab53 *src/dmi.f95
-5f4ed7bb01d978cc701fe999de5f1f8c *src/mmi.f95
-ae7197c6e5beb5eff81c72a3543087c2 *src/mminjk.f95
-87b514ea8f7acc15eb0c2d2366fbd643 *src/nawrap.c
-5ff5e6e54db7d5827746a42af59b1e45 *vignettes/Vignette.Rnw
diff -Nru orig/mpmi/NAMESPACE patched/mpi/NAMESPACE
--- orig/mpmi/NAMESPACE	2016-11-19 23:35:41.000000000 -0800
+++ patched/mpi/NAMESPACE	1969-12-31 16:00:00.000000000 -0800
@@ -1,17 +0,0 @@
-useDynLib(mpmi)
-export(cmi, 
-cminjk, 
-cminjk.pw, 
-cmi.pw, 
-dmi, 
-dminjk, 
-dminjk.pw, 
-dmi.pw,
-mmi, 
-mminjk, 
-mminjk.pw, 
-mmi.pw, 
-mp)
-
-import(KernSmooth)
-importFrom("graphics", "image")
diff -Nru orig/mpmi/NEWS patched/mpi/NEWS
--- orig/mpmi/NEWS	2019-04-21 22:29:24.000000000 -0700
+++ patched/mpi/NEWS	1969-12-31 16:00:00.000000000 -0800
@@ -1,14 +0,0 @@
-NEWS for mpmi
-
-Changes in version 0.43:
-    *   Fix compilation flags for OpenMP
-
-Changes in version 0.42:
-    *   Fix namesapce issue
-
-Changes in version 0.4:
-    *   Changed all functions to use DUP = TRUE for safety (this fixes a nasty memory aliasing bug when using dmi())
-    *	Implemented some regression tests (available in the repository at http://r-forge.r-project.org/projects/mpmi/ )
-
-Changes in version 0.03: 
-    *   Initial release
diff -Nru orig/mpmi/R/cmi.R patched/mpi/R/cmi.R
--- orig/mpmi/R/cmi.R	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/R/cmi.R	1969-12-31 16:00:00.000000000 -0800
@@ -1,90 +0,0 @@
-#  
-#     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
-# 
-#     This file is part of the mpmi R package.
-# 
-#     This program is free software: you can redistribute it and/or modify
-#     it under the terms of the GNU General Public License as published by
-#     the Free Software Foundation, version 3.
-# 
-#     This program is distributed in the hope that it will be useful,
-#     but WITHOUT ANY WARRANTY; without even the implied warranty of
-#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#     GNU General Public License for more details.
-# 
-#     You should have received a copy of the GNU General Public License
-#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#  
-
-
-cmi <-
-function(cts, level = 3L, na.rm = FALSE, h, ...)
-{
-    cts <- as.matrix(cts)
-    mode(cts) <- "double"
-
-    mi <- matrix(0.0, nrow = ncol(cts), ncol = ncol(cts))
-    bcmi <- matrix(0.0, nrow = ncol(cts), ncol = ncol(cts))
-    zans <- matrix(0.0, nrow = ncol(cts), ncol = ncol(cts))
-
-    # Calculate bandwidths
-    if (missing(h))
-    {
-        if(na.rm)
-        {
-            h2 <- function(x)
-            {
-                return(dpikSafe(x[is.finite(x)], level = level, kernel = "epanech", ...))
-            }
-            h <- apply(cts, 2, h2)
-        } else 
-        {
-            h <- apply(cts, 2, dpikSafe, level = level, kernel = "epanech", ...)
-        }
-    }
- 
-    result <- .Fortran("cmim", 
-                    cts, 
-                    as.integer(nrow(cts)), 
-                    as.integer(ncol(cts)),
-                    mi = mi, 
-                    bcmi = bcmi, 
-                    zvalues = zans,
-                    as.double(h), 
-                    NAOK = TRUE, 
-                    DUP = TRUE)
-
-    return(result[c("mi", "bcmi", "zvalues")])
-}
-
-# Pairwise only
-cmi.pw <- function(v1, v2, h, ...)
-{
-    if (length(v1) != length(v2)) stop("Vectors must be of the same length")
-    ok1 <- !is.na(v1)
-    ok2 <- !is.na(v2)
-    
-    # Remove samples with missing values
-    ok <- ok1 & ok2
-    v1 <- v1[ok]
-    v2 <- v2[ok]
-
-    if (missing(h))
-    {
-        h <- c(dpikSafe(v1, level = 3L, kernel = "epanech", ...), dpikSafe(v2, level = 3L, kernel = "epanech", ...))
-    }
-
-    result <- .Fortran("cmipw",
-            as.double(v1),
-            as.double(v2),
-            as.integer(length(v1)),
-            as.double(h[1]),
-            as.double(h[2]),
-            mi = as.double(0), 
-            bcmi = as.double(0),
-            zvalue = as.double(0),
-            DUP = TRUE)
-
-    return(result[c("mi", "bcmi", "zvalue")])
-}
-
diff -Nru orig/mpmi/R/cminjk.R patched/mpi/R/cminjk.R
--- orig/mpmi/R/cminjk.R	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/R/cminjk.R	1969-12-31 16:00:00.000000000 -0800
@@ -1,90 +0,0 @@
-#  
-#     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
-# 
-#     This file is part of the mpmi R package.
-# 
-#     This program is free software: you can redistribute it and/or modify
-#     it under the terms of the GNU General Public License as published by
-#     the Free Software Foundation, version 3.
-# 
-#     This program is distributed in the hope that it will be useful,
-#     but WITHOUT ANY WARRANTY; without even the implied warranty of
-#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#     GNU General Public License for more details.
-# 
-#     You should have received a copy of the GNU General Public License
-#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#  
-
-
-cminjk <-
-function(cts, level = 3L, na.rm = FALSE, h, ...)
-{
-    cts <- as.matrix(cts)
-    mode(cts) <- "double"
-
-    mi <- matrix(0.0, nrow = ncol(cts), ncol = ncol(cts))
-    # bcmi <- matrix(0.0, nrow = ncol(cts), ncol = ncol(cts))
-    # zans <- matrix(0.0, nrow = ncol(cts), ncol = ncol(cts))
-
-    # Calculate bandwidths
-    if (missing(h))
-    {
-        if(na.rm)
-        {
-            h2 <- function(x)
-            {
-                return(dpikSafe(x[is.finite(x)], level = level, kernel = "epanech", ...))
-            }
-            h <- apply(cts, 2, h2)
-        } else 
-        {
-            h <- apply(cts, 2, dpikSafe, level = level, kernel = "epanech", ...)
-        }
-    }
- 
-    result <- .Fortran("cmimnjk", 
-                    cts, 
-                    as.integer(nrow(cts)), 
-                    as.integer(ncol(cts)),
-                    mi = mi, 
-                    # bcmi = bcmi, 
-                    # zvalues = zans,
-                    as.double(h), 
-                    NAOK = TRUE, 
-                    DUP = TRUE)
-
-    return(result$mi)
-}
-
-# Pairwise only
-cminjk.pw <- function(v1, v2, h, ...)
-{
-    if (length(v1) != length(v2)) stop("Vectors must be of the same length")
-    ok1 <- !is.na(v1)
-    ok2 <- !is.na(v2)
-    
-    # Remove samples with missing values
-    ok <- ok1 & ok2
-    v1 <- v1[ok]
-    v2 <- v2[ok]
-    if (missing(h))
-
-    {
-        h <- c(dpikSafe(v1, level = 3L, kernel = "epanech", ...), dpikSafe(v2, level = 3L, kernel = "epanech", ...))
-    }
-
-    result <- .Fortran("cmipwnjk",
-            as.double(v1),
-            as.double(v2),
-            as.integer(length(v1)),
-            as.double(h[1]),
-            as.double(h[2]),
-            mi = as.double(0), 
-            # bcmi = as.double(0),
-            # zvalue = as.double(0),
-            DUP = TRUE)
-
-    return(result$mi)
-}
-
diff -Nru orig/mpmi/R/dmif.R patched/mpi/R/dmif.R
--- orig/mpmi/R/dmif.R	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/R/dmif.R	1969-12-31 16:00:00.000000000 -0800
@@ -1,102 +0,0 @@
-#  
-#     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
-# 
-#     This file is part of the mpmi R package.
-# 
-#     This program is free software: you can redistribute it and/or modify
-#     it under the terms of the GNU General Public License as published by
-#     the Free Software Foundation, version 3.
-# 
-#     This program is distributed in the hope that it will be useful,
-#     but WITHOUT ANY WARRANTY; without even the implied warranty of
-#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#     GNU General Public License for more details.
-# 
-#     You should have received a copy of the GNU General Public License
-#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#  
-
-
-dmi.pw <- function(disc1, disc2)
-{
-    disc1 <- as.integer(factor(disc1))
-    disc2 <- as.integer(factor(disc2))
-
-    ok <- is.finite(disc1) & is.finite(disc2)
-
-    disc1 <- disc1[ok]
-    disc2 <- disc2[ok]
-
-    mi <- 0.0
-    bcmi <- 0.0
-    zvalue <- 0.0
-
-    result <- .Fortran("dmi",
-                       disc1,
-                       as.integer(length(disc1)),
-                       disc2,
-                       as.integer(length(disc2)),
-                       mi = mi, 
-                       bcmi = bcmi,
-                       zvalue = zvalue,
-                       DUP = TRUE)
-
-    return(result[c("mi", "bcmi", "zvalue")])
-}
-
-dmi <- function(dmat)
-{
-    # Convert to integers
-    dint <- matrix(0L, nrow = nrow(dmat), ncol = ncol(dmat))
-    for (i in 1: ncol(dmat))
-    {
-        dint[,i] <- as.integer(factor(dmat[,i]))
-    }
-
-    mi <- matrix(0.0, nrow = ncol(dint), ncol = ncol(dint))
-    bcmi <- matrix(0.0, nrow = ncol(dint), ncol = ncol(dint))
-    zans <- matrix(0.0, nrow = ncol(dint), ncol = ncol(dint))
-
-    result <- .Fortran("dmim",
-                       dint,
-                       as.integer(nrow(dint)),
-                       as.integer(ncol(dint)),
-                       mi = mi, 
-                       bcmi = bcmi, 
-                       zvalues = zans,
-                       NAOK = TRUE, 
-                       DUP = TRUE)
-
-    return(result[c("mi", "bcmi", "zvalues")])
-}
-
-dminjk.pw <- function(disc1, disc2)
-{
-    disc1 <- as.integer(factor(disc1))
-    disc2 <- as.integer(factor(disc2))
-    ans <- as.double(0)
-    return(.Fortran("dminjk",
-                    disc1,
-                    as.integer(length(disc1)),
-                    disc2,
-                    as.integer(length(disc2)),
-                    result = ans, DUP = TRUE)$result)
-}
-
-dminjk <- function(dmat)
-{
-    # Convert to integers
-    dint <- matrix(0L, nrow = nrow(dmat), ncol = ncol(dmat))
-    for (i in 1: ncol(dmat))
-    {
-        dint[,i] <- as.integer(factor(dmat[,i]))
-    }
-
-    ans <- matrix(0.0, nrow = ncol(dint), ncol = ncol(dint))
-    return(.Fortran("dmimnjk",
-                    dint,
-                    as.integer(nrow(dint)),
-                    as.integer(ncol(dint)),
-                    result = ans, NAOK = TRUE, DUP = TRUE)$result)
-}
-
diff -Nru orig/mpmi/R/dpikSafe.R patched/mpi/R/dpikSafe.R
--- orig/mpmi/R/dpikSafe.R	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/R/dpikSafe.R	1969-12-31 16:00:00.000000000 -0800
@@ -1,40 +0,0 @@
-#  
-#     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
-# 
-#     This file is part of the mpmi R package.
-# 
-#     This program is free software: you can redistribute it and/or modify
-#     it under the terms of the GNU General Public License as published by
-#     the Free Software Foundation, version 3.
-# 
-#     This program is distributed in the hope that it will be useful,
-#     but WITHOUT ANY WARRANTY; without even the implied warranty of
-#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#     GNU General Public License for more details.
-# 
-#     You should have received a copy of the GNU General Public License
-#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#  
-
-
-# Function to handle cases where dpik() is unable to estimate
-# a bandwidth, usually because a data vector has an interquartile range of 0.
-dpikSafe <- function(x, ...)
-{
-	result <- try(dpik(x, ...), silent = TRUE)
-
-	if (class(result) == "try-error")
-	{
-		msg <- geterrmessage()
-		if (grepl("scale estimate is zero for input data", msg))
-		{
-			warning("Using standard deviation as scale estimate, probably because IQR == 0")
-			result <- dpik(x, scalest = "stdev", ...)	
-		} else 
-		{
-			stop(msg)
-		}		
-		
-	}
-	return(result)
-}
diff -Nru orig/mpmi/R/mmi.R patched/mpi/R/mmi.R
--- orig/mpmi/R/mmi.R	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/R/mmi.R	1969-12-31 16:00:00.000000000 -0800
@@ -1,97 +0,0 @@
-#  
-#     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
-# 
-#     This file is part of the mpmi R package.
-# 
-#     This program is free software: you can redistribute it and/or modify
-#     it under the terms of the GNU General Public License as published by
-#     the Free Software Foundation, version 3.
-# 
-#     This program is distributed in the hope that it will be useful,
-#     but WITHOUT ANY WARRANTY; without even the implied warranty of
-#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#     GNU General Public License for more details.
-# 
-#     You should have received a copy of the GNU General Public License
-#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#  
-
-
-mmi <-
-function(cts, disc, level = 3L, na.rm = FALSE, h, ...)
-{
-    cts <- as.matrix(cts)
-    mode(cts) <- "double"
-
-    mi <- matrix(0.0, nrow = ncol(cts), ncol = ncol(disc))
-    bcmi <- matrix(0.0, nrow = ncol(cts), ncol = ncol(disc))
-    zans <- matrix(0.0, nrow = ncol(cts), ncol = ncol(disc))
-
-    # Convert to integers (probably slow)
-    dint <- matrix(0L, nrow = nrow(disc), ncol = ncol(disc))
-    for (i in 1: ncol(disc))
-    {
-        dint[,i] <- as.integer(factor(disc[,i]))
-    }
-
-    # Calculate bandwidths
-    if (missing(h))
-    {
-        if(na.rm)
-        {
-            h2 <- function(x)
-            {
-                return(dpikSafe(x[is.finite(x)], level = level, kernel = "epanech", ...))
-            }
-            h <- apply(cts, 2, h2)
-        } else 
-        {
-            h <- apply(cts, 2, dpikSafe, level = level, kernel = "epanech", ...)
-        }
-    }
- 
-    result <- .Fortran("mmim", 
-                    cts, 
-                    as.integer(nrow(cts)), 
-                    as.integer(ncol(cts)),
-                    dint,
-                    as.integer(nrow(dint)), 
-                    as.integer(ncol(dint)),
-                    mi = mi, 
-                    bcmi = bcmi, 
-                    zvalues = zans,
-                    as.double(h), 
-                    NAOK = TRUE, 
-                    DUP = TRUE)
-
-    return(result[c("mi", "bcmi", "zvalues")])
-}
-
-mmi.pw <- function(cts, disc, h, ...)
-{
-    if (length(cts) != length(disc)) stop("Input vectors must be the same length")
-
-    # Remove missing values pairwise
-    ok <- !is.na(disc) & !is.na(cts)
-    disc <- disc[ok]
-    cts <- cts[ok]
-
-    if (missing(h))
-    {
-        h <- dpikSafe(cts, level = 3L, kernel = "epanech", ...)
-    }
-
-    lf <- length(cts)
-
-    result <- .Fortran("mmipw", cts = as.double(cts), 
-                        lc = as.integer(lf), 
-                        disc = as.integer(factor(disc)),
-                        h = as.double(h),
-                        mi = as.double(0), 
-                        bcmi = as.double(0),
-                        zvalue = as.double(0),
-                        DUP = TRUE)
-
-    return(result[c("mi", "bcmi", "zvalue")])
-}
-
diff -Nru orig/mpmi/R/mminjk.R patched/mpi/R/mminjk.R
--- orig/mpmi/R/mminjk.R	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/R/mminjk.R	1969-12-31 16:00:00.000000000 -0800
@@ -1,99 +0,0 @@
-#  
-#     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
-# 
-#     This file is part of the mpmi R package.
-# 
-#     This program is free software: you can redistribute it and/or modify
-#     it under the terms of the GNU General Public License as published by
-#     the Free Software Foundation, version 3.
-# 
-#     This program is distributed in the hope that it will be useful,
-#     but WITHOUT ANY WARRANTY; without even the implied warranty of
-#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#     GNU General Public License for more details.
-# 
-#     You should have received a copy of the GNU General Public License
-#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#  
-
-
-mminjk <-
-function(cts, disc, level = 3L, na.rm = FALSE, h, ...)
-{
-    cts <- as.matrix(cts)
-    mode(cts) <- "double"
-
-    mi <- matrix(0.0, nrow = ncol(cts), ncol = ncol(disc))
-    # bcmi <- matrix(0.0, nrow = ncol(cts), ncol = ncol(disc))
-    # zans <- matrix(0.0, nrow = ncol(cts), ncol = ncol(disc))
-
-    # Convert to integers (probably slow)
-    dint <- matrix(0L, nrow = nrow(disc), ncol = ncol(disc))
-    for (i in 1: ncol(disc))
-    {
-        dint[,i] <- as.integer(factor(disc[,i]))
-    }
-
-    # Calculate bandwidths
-    if (missing(h))
-    {
-        if(na.rm)
-        {
-            h2 <- function(x)
-            {
-                return(dpikSafe(x[is.finite(x)], level = level, kernel = "epanech", ...))
-            }
-            h <- apply(cts, 2, h2)
-        } else 
-        {
-            h <- apply(cts, 2, dpikSafe, level = level, kernel = "epanech", ...)
-        }
-    }
- 
-    result <- .Fortran("mmimnjk", 
-                    cts, 
-                    as.integer(nrow(cts)), 
-                    as.integer(ncol(cts)),
-                    dint,
-                    as.integer(nrow(dint)), 
-                    as.integer(ncol(dint)),
-                    mi = mi, 
-                    # bcmi = bcmi, 
-                    # zvalues = zans,
-                    as.double(h), 
-                    NAOK = TRUE, 
-                    DUP = TRUE)
-
-    return(result$mi)
-}
-
-mminjk.pw <- function(cts, disc, h, ...)
-{
-    if (length(cts) != length(disc)) stop("Input vectors must be the same length")
-
-    # Remove missing values pairwise
-    ok <- !is.na(disc) & !is.na(cts)
-    disc <- disc[ok]
-    cts <- cts[ok]
-
-    if (missing(h))
-    {
-        h <- dpikSafe(cts, level = 3L, kernel = "epanech", ...)
-    }
-
-    lf <- length(cts)
-
-    mi <- 0.0
-
-    result <- .Fortran("mmipwnjk", cts = as.double(cts), 
-                        lc = as.integer(lf), 
-                        disc = as.integer(factor(disc)),
-                        h = as.double(h),
-                        mi = as.double(mi), 
-                        # bcmi = as.double(0),
-                        # zvalue = as.double(0),
-                        DUP = TRUE)
-
-    return(result$mi)
-}
-
diff -Nru orig/mpmi/R/mp.R patched/mpi/R/mp.R
--- orig/mpmi/R/mp.R	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/R/mp.R	1969-12-31 16:00:00.000000000 -0800
@@ -1,24 +0,0 @@
-#  
-#     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
-# 
-#     This file is part of the mpmi R package.
-# 
-#     This program is free software: you can redistribute it and/or modify
-#     it under the terms of the GNU General Public License as published by
-#     the Free Software Foundation, version 3.
-# 
-#     This program is distributed in the hope that it will be useful,
-#     but WITHOUT ANY WARRANTY; without even the implied warranty of
-#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#     GNU General Public License for more details.
-# 
-#     You should have received a copy of the GNU General Public License
-#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#  
-
-
-mp <- function(mat, ...)
-{
-    image(max(mat, na.rm = TRUE) - t(mat[dim(mat)[1]:1, ]), ...)
-}
-
Binary files orig/mpmi/build/vignette.rds and patched/mpi/build/vignette.rds differ
Binary files orig/mpmi/data/mpmidata.RData and patched/mpi/data/mpmidata.RData differ
diff -Nru orig/mpmi/inst/doc/Vignette.R patched/mpi/inst/doc/Vignette.R
--- orig/mpmi/inst/doc/Vignette.R	2019-04-21 23:12:27.000000000 -0700
+++ patched/mpi/inst/doc/Vignette.R	1969-12-31 16:00:00.000000000 -0800
@@ -1,195 +0,0 @@
-### R code from vignette source 'Vignette.Rnw'
-
-###################################################
-### code chunk number 1: Vignette.Rnw:18-19
-###################################################
-library(mpmi)
-
-
-###################################################
-### code chunk number 2: Vignette.Rnw:34-40
-###################################################
-# library(MASS)
-# mu <- 1:100
-# S <- toeplitz((100:1)/100)
-# set.seed(123456789)
-# dat <- mvrnorm(50, mu, S)
-# cts <- scale(dat)
-
-
-###################################################
-### code chunk number 3: Vignette.Rnw:44-46
-###################################################
-data(mpmidata)
-ctsresult <- cmi(cts)
-
-
-###################################################
-### code chunk number 4: Vignette.Rnw:51-52
-###################################################
-str(ctsresult)
-
-
-###################################################
-### code chunk number 5: Vignette.Rnw:55-56
-###################################################
-round(ctsresult$mi[1:5,1:5], 2)
-
-
-###################################################
-### code chunk number 6: Vignette.Rnw:59-60
-###################################################
-round(ctsresult$bcmi[1:5,1:5], 2)
-
-
-###################################################
-### code chunk number 7: Vignette.Rnw:66-67
-###################################################
-cmi.pw(cts[,1], cts[,1])
-
-
-###################################################
-### code chunk number 8: Vignette.Rnw:81-82
-###################################################
-mp(ctsresult$bcmi)
-
-
-###################################################
-### code chunk number 9: Vignette.Rnw:91-95
-###################################################
-# set.seed(987654321)
-# disc <- rep(c("A", "H", "B"), ceiling(50 * 75 / 3))
-# disc <- matrix(disc, nrow = 50, ncol = 75)
-# disc <- apply(disc, 2, sample)
-
-
-###################################################
-### code chunk number 10: Vignette.Rnw:100-115
-###################################################
-cts2 <- cts
-for (variable in 1:75)
-{
-    for (subject in 1:50)
-    {
-        if (disc[subject, variable] == "A") 
-        {
-            cts2[subject, variable] <- cts[subject, variable] - 2
-        }
-        if (disc[subject, variable] == "B") 
-        {
-            cts2[subject, variable] <- cts[subject, variable] - 2
-        }
-    }
-}
-
-
-###################################################
-### code chunk number 11: Vignette.Rnw:118-119
-###################################################
-mixedresult <- mmi(cts2, disc)
-
-
-###################################################
-### code chunk number 12: Vignette.Rnw:127-128
-###################################################
-str(mixedresult, width = 60, strict.width = "cut")
-
-
-###################################################
-### code chunk number 13: Vignette.Rnw:131-132
-###################################################
-round(mixedresult$mi[1:5,1:5], 2)
-
-
-###################################################
-### code chunk number 14: Vignette.Rnw:135-136
-###################################################
-round(mixedresult$bcmi[1:5,1:5], 2)
-
-
-###################################################
-### code chunk number 15: Vignette.Rnw:140-141
-###################################################
-mmi.pw(cts2[,1], disc[,1])
-
-
-###################################################
-### code chunk number 16: Vignette.Rnw:147-148
-###################################################
-mp(mixedresult$bcmi)
-
-
-###################################################
-### code chunk number 17: Vignette.Rnw:179-181
-###################################################
-# library(parallel) # Commented for portability
-library(compiler)
-
-
-###################################################
-### code chunk number 18: Vignette.Rnw:188-189
-###################################################
-hs <- apply(cts2, 2, dpik, level = 3L, kernel = "epanech")
-
-
-###################################################
-### code chunk number 19: Vignette.Rnw:196-206
-###################################################
-fi <- function(i)
-{
-    bcmis <- rep(NaN, 100)
-    for (j in 1:100)
-    {
-        bcmis[j] <- mmi.pw(cts2[,j], disc[,i], h = hs[j])$bcmi
-    }
-    return(bcmis)
-}
-fi <- cmpfun(fi)
-
-
-###################################################
-### code chunk number 20: Vignette.Rnw:216-217
-###################################################
-# parmmi <- mcmapply(fi, 1:75)
-
-
-###################################################
-### code chunk number 21: Vignette.Rnw:221-222
-###################################################
-# sum(abs(mixedresult$bcmi - parmmi))
-
-
-###################################################
-### code chunk number 22: Vignette.Rnw:228-229
-###################################################
-hs2 <- apply(cts, 2, dpik, level = 3L, kernel = "epanech")
-
-
-###################################################
-### code chunk number 23: Vignette.Rnw:235-245
-###################################################
-fi <- function(i)
-{
-    bcmis <- rep(NaN, 100)
-    for (j in i:100)
-    {
-        bcmis[j] <- cmi.pw(cts[,i], cts[,j], h = hs2[c(i,j)])$bcmi
-    }
-    return(bcmis)
-}
-fi <- cmpfun(fi)
-
-
-###################################################
-### code chunk number 24: Vignette.Rnw:252-253
-###################################################
-# parcmi <- mcmapply(fi, 1:100)
-
-
-###################################################
-### code chunk number 25: Vignette.Rnw:265-267
-###################################################
-lt <- function(x) x[lower.tri(x, diag = TRUE)]
-# sum(abs(lt(ctsresult$bcmi) - lt(parcmi)))
-
-
diff -Nru orig/mpmi/inst/doc/Vignette.Rnw patched/mpi/inst/doc/Vignette.Rnw
--- orig/mpmi/inst/doc/Vignette.Rnw	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/inst/doc/Vignette.Rnw	1969-12-31 16:00:00.000000000 -0800
@@ -1,291 +0,0 @@
-\documentclass[a4paper]{article}
-\title{Introduction to \texttt{mpmi}}
-\author{Chris Pardy}
-
-\begin{document}
-%\VignetteIndexEntry{Introduction to mpmi}
-%\VignetteDepends{mpmi}
-\maketitle
-
-\section{Using the \texttt{mpmi} package}
-
-The following vignette will provide a brief introduction to the \texttt{mpmi}
-package, showing the use of the two main functions (\texttt{cmi()} and
-\texttt{mmi()}) as well as explicit parallelisation of their pairwise versions(
-\texttt{cmi.pw()} and \texttt{mmi.pw()}).
-
-First we load the library
-<<results=hide>>=
-library(mpmi)
-@
-
-\subsection{Continuous vs continuous comparisons}
-
-We demonstrate the calculation of MI and BCMI for all pairs of a group of
-continuous variables using a simulated dataset included in the \texttt{mpmi}
-package. The dataset, \texttt{mpmidata} contains a matrix of continuous data
-\texttt{cts} and a matrix of categorical data \texttt{disc}. The continuous data
-consists of $50$ subjects with $100$ variables following a multivariate normal
-distribution (note that this is done for simplicity as our approach is designed
-to work for a much wider class of distributions).  The continuous data were
-simulated to have an association that decays linearly as the distance between each
-pair of variables' indices increases. For reference this was created as follows
-(note that this requires the \texttt{MASS} library to be loaded):
-<<>>=
-# library(MASS)
-# mu <- 1:100
-# S <- toeplitz((100:1)/100)
-# set.seed(123456789)
-# dat <- mvrnorm(50, mu, S)
-# cts <- scale(dat)
-@
-
-The data are loaded and the \texttt{cmi()} function is then applied:
-<<>>=
-data(mpmidata)
-ctsresult <- cmi(cts)
-@
-Below we show the structure of the results object. It is a list containing 3
-matrices. For a set of continuous variables these are square symmetric matrices
-of a similar form to a correlation matrix.
-<<>>=
-str(ctsresult)
-@
-The raw MI values:
-<<>>=
-round(ctsresult$mi[1:5,1:5], 2)
-@
-Jackknife bias corrected MI values:
-<<>>=
-round(ctsresult$bcmi[1:5,1:5], 2)
-@
-
-We can check the results against the pairwise function. In this case we
-calculate the MI between the first variable and itself, which estimates
-its entropy.
-<<>>=
-cmi.pw(cts[,1], cts[,1])
-@
-This agrees with the results above (i.e., the \texttt{[1,1]} element of each
-results matrix).
-
-We can use the \texttt{mp()} function to plot an MI (or correlation) matrix. This
-plots the matrix with points corresponding to the same order that they are
-displayed in a numerical matrix (i.e, the usual mathematical way). 
-It is scaled so that red is the largest value
-and white is the smallest. When applied to the results above we can see the larger 
-values along the diagonal of the BCMI matrix, decaying as the difference between
-$i$ and $j$ increases.
-
-\begin{center}
-<<fig=TRUE,echo=TRUE>>=
-mp(ctsresult$bcmi)
-@
-\end{center}
-
-\subsection{Discrete vs continuous comparisons}
-
-To demonstrate MI for mixed comparisons we generate $75$ random SNP
-variables and create a new set of continuous data where some of the values have
-been shifted according to the categories. 
-<<>>=
-# set.seed(987654321)
-# disc <- rep(c("A", "H", "B"), ceiling(50 * 75 / 3))
-# disc <- matrix(disc, nrow = 50, ncol = 75)
-# disc <- apply(disc, 2, sample)
-@
-This shuffles a fairly even set of $A$, $H$, and $B$ for each variable. We then
-introduce a fairly strong U-shaped shift to continuous variable $i$ based on the
-value of discrete variable $k$, but only for cases where $i = k$.
-<<>>=
-cts2 <- cts
-for (variable in 1:75)
-{
-    for (subject in 1:50)
-    {
-        if (disc[subject, variable] == "A") 
-        {
-            cts2[subject, variable] <- cts[subject, variable] - 2
-        }
-        if (disc[subject, variable] == "B") 
-        {
-            cts2[subject, variable] <- cts[subject, variable] - 2
-        }
-    }
-}
-@
-We run the \texttt{mmi()} function on the discrete and continuous data:
-<<>>=
-mixedresult <- mmi(cts2, disc)
-@
-The results object for mixed comparisons have the same form as the results
-object for continuous comparisons. The only difference is that now instead of
-square symmetric matrices (for continuous data) the results are $n_c \times n_d$
-matrices where $n_c$ is the number of continuous variables and $n_d$ is the
-number of discrete variables. The row index refers to continuous variables and
-the column index refers to discrete variables.
-<<>>=
-str(mixedresult, width = 60, strict.width = "cut")
-@
-As before we have the raw MI values:
-<<>>=
-round(mixedresult$mi[1:5,1:5], 2)
-@
-And jackknife bias corrected MI values:
-<<>>=
-round(mixedresult$bcmi[1:5,1:5], 2)
-@
-
-Once again we can check by using the pairwise function:
-<<>>=
-mmi.pw(cts2[,1], disc[,1])
-@
-
-We can use \texttt{mp()} to plot the BCMI values and see the strong associations
-we've induced for cases where $i = j$ (note that the BCMI matrix is not square):
-\begin{center}
-<<fig=TRUE,echo=TRUE>>=
-mp(mixedresult$bcmi)
-@
-\end{center}
-
-\subsection{Explicit parallelisation}
-
-The pairwise functions are provided to allow the user to explicitly
-control parallelisation. Here we demonstrate how to parallelise in R using the
-\texttt{parallel} package (based on the older \texttt{multicore})
-package. As this package makes use of the POSIX \texttt{fork()} system function
-it can only be run on POSIX systems (i.e., Linux and MacOS; note that the
-implicit OpenMP parallelisation works on all three platforms, Linux, MacOS and
-Windows). For portability we will not actually run the code in this section, 
-although it should work fine on Linux and Mac.
-
-To apply this approach we need to create a function that will be run in
-parallel. Each application of this function will be sent to a processor core, so
-we must decide on `packaging' groups of MI calculations such that this
-is done in an efficient way. Details are given below.
-
-The pairwise functions \texttt{mmi.pw()}, \texttt{cmi.pw()} and \texttt{dmi.pw()}
-are provided to facilitate explicit parallelisation. Each of these functions
-calculates MI and BCMI values for comparisons between two variables with
-appropriate types.
-
-\subsubsection{Mixed comparisons}
-
-We first show how to parallelise the mixed comparisons as this is more
-straightforward than the continuous comparisons. Performance may be further
-improved by using the R bytecode compiler. First we must load the
-\texttt{parallel} and \texttt{compiler} libraries:
-<<>>=
-# library(parallel) # Commented for portability
-library(compiler)
-@
-
-The \texttt{mmi.pw()} function will calculate appropriate smoothing bandwidths
-as required. This will result in a lot of unnecessary computational
-repetition, so it is much faster to pre-compute the bandwidths before running the
-comparisons in parallel:
-<<>>=
-hs <- apply(cts2, 2, dpik, level = 3L, kernel = "epanech")
-@
-
-Now we must choose how to parallelise. The simplest approach is to write a
-function that calculates all comparisons between continuous variables and a
-single discrete variable (or vice versa). This is the same approach implemented
-by OpenMP in \texttt{mmi()}. For each SNP $i$ we apply the following function:
-<<>>=
-fi <- function(i)
-{
-    bcmis <- rep(NaN, 100)
-    for (j in 1:100)
-    {
-        bcmis[j] <- mmi.pw(cts2[,j], disc[,i], h = hs[j])$bcmi
-    }
-    return(bcmis)
-}
-fi <- cmpfun(fi)
-@
-This returns a vector containing the BCMI values for SNP $i$. Modifying 
-\texttt{fi()} to also keep the raw MI scores is straightforward. 
-
-
-We now use the \texttt{mcmapply()} function from the \texttt{parallel} package
-(which is now a part of base R). 
-This will calculate the vectors returned by the \texttt{fi()} and bind them as
-columns in a matrix.
-<<>>=
-# parmmi <- mcmapply(fi, 1:75)
-@
-We can check that the results are equal to those calculated using implicit
-parallelisation:
-<<>>=
-# sum(abs(mixedresult$bcmi - parmmi))
-@
-
-\subsubsection{Continuous comparisons}
-
-Once again we pre-compute the smoothing parameters:
-<<>>=
-hs2 <- apply(cts, 2, dpik, level = 3L, kernel = "epanech")
-@
-
-For the continuous comparisons we only need to calculate each comparison once to
-fill the lower (or upper) triangle of the results matrix. This requires a
-slight modification to the range of the loop in \texttt{fi()}:
-<<>>=
-fi <- function(i)
-{
-    bcmis <- rep(NaN, 100)
-    for (j in i:100)
-    {
-        bcmis[j] <- cmi.pw(cts[,i], cts[,j], h = hs2[c(i,j)])$bcmi
-    }
-    return(bcmis)
-}
-fi <- cmpfun(fi)
-@
-
-We smooth each of the two continuous variables by a different amount, so the
-\texttt{cmi.pw()} function requires two additional parameters which are input as
-a vector. These will be automatically calculated if not explicitly given.
-We run this in parallel in the same way as above:
-<<>>=
-# parcmi <- mcmapply(fi, 1:100)
-@
-Now we check the results. The \texttt{parcmi} matrix contains an upper triangle
-full of missing values which would usually need to be symmetrised 
-(the \texttt{cmi()} wrapper function takes care of this). In general, an MI matrix for
-continuous variables is symmetric (much like a correlation matrix) and has
-entropy estimates along the diagonal. So to check these results we simply need
-to check that the lower triangle of \texttt{parcmi} is equal to the lower
-triangle of \texttt{ctsresult\$bcmi}.  A simple approach for
-this check is to define a convenience function \texttt{lt()} to extract the lower
-triangle of a matrix, and observe that the sum of the absolute differences is
-computationally zero:
-<<>>=
-lt <- function(x) x[lower.tri(x, diag = TRUE)]
-# sum(abs(lt(ctsresult$bcmi) - lt(parcmi)))
-@
-
-\subsection{Parallelisation across multiple machines}
-
-The parallel version can be run across multiple machines in a cluster in a
-similar manner, by using the \texttt{snowfall} R package. This requires
-helper functions to be written that are identical to the \texttt{fi()} above.
-
-\subsection{A note about $z$-values}
-
-The functions in this package also return $z$-scores from the jackknife test for
-the hypothesis of no association (i.e., zero MI). We have found p-values and confidence
-intervals based on these $z$-scores to be highly variable and often quite wrong.
-Do not use these for statistical inference. The jackknife bias correction
-however does work quite well to reduce error in estimation of MI values (which
-we report as BCMI). 
-
-Since we essentially get the $z$-scores for free after calculating the bias
-correction we have decided to report them. They are useful for giving some idea
-of the strength of an observed association and can be considered as a heuristic
-transformation of the BCMI values that may aid interpretation. A permutation
-test is a much better choice for inference.
-
-\end{document}
Binary files orig/mpmi/inst/doc/Vignette.pdf and patched/mpi/inst/doc/Vignette.pdf differ
diff -Nru orig/mpmi/man/cmi.Rd patched/mpi/man/cmi.Rd
--- orig/mpmi/man/cmi.Rd	2014-09-21 18:58:08.000000000 -0700
+++ patched/mpi/man/cmi.Rd	1969-12-31 16:00:00.000000000 -0800
@@ -1,142 +0,0 @@
-\name{cmi}
-\alias{cmi}
-\alias{cminjk}
-\alias{cmi.pw}
-\alias{cminjk.pw}
-%- Also NEED an '\alias' for EACH other topic documented here.
-\title{ Calculate BCMI between a set of continuous variables
-%%  ~~function to do ... ~~
-}
-\description{This function calculates MI and BCMI between a set of continuous variables
-    held as columns in a matrix. It also performs jackknife bias correction and
-    provides a z-score for the hypothesis of no association. Also included are
-    the *.pw functions that calculate MI between two vectors only. The *njk
-    functions do not perform the jackknife and are therefore faster. 
-    %%  ~~ A concise (1-5 lines) description of what the function does. ~~
-}
-\usage{
-cmi(cts, level = 3L, na.rm = FALSE, h, ...)
-cminjk(cts, level = 3L, na.rm = FALSE, h, ...)
-cmi.pw(v1, v2, h, ...)
-cminjk.pw(v1, v2, h, ...)
-}
-%- maybe also 'usage' for other objects documented here.
-\arguments{
-  \item{cts}{ The data matrix. Each row is an observation and each column is a
-      variable of interest. Should be numerical data.
-%%     ~~Describe \code{cts} here~~
-}
-  \item{level}{ The number of levels used for plug-in bandwidth estimation (see
-      the documentation for the KernSmooth package.)
-%%     ~~Describe \code{level} here~~
-}
-  \item{na.rm}{ Remove missing values if TRUE. This is required for the
-      bandwidth calculation.
-%%     ~~Describe \code{na.rm} here~~
-}
-  \item{h}{ A (double) vector of smoothing bandwidths, one for each variable. If
-      missing this will be calculated using the dpik() function from the
-      KernSmooth package.
-%%     ~~Describe \code{h} here~~
-}
-  \item{\dots}{ Additional options passed to dpik() if necessary.
-%%     ~~Describe \code{\dots} here~~
-} 
-    \item{v1}{ A vector for the pairwise version}
-    \item{v2}{ A vector for the pairwise version}
-}
-\details{ The results of cmi() are in many ways similar to a correlation matrix,
-    with each row and column index corresponding to a given variable.
-    cminjk() and cminjk.pw() just returns the MI values without performing the
-    jackknife. cmi.pw() and cminjk.pw() each only require two bandwidths, one
-    for each variable. The number of processor cores used can be changed by
-    setting the environment variable "OMP_NUM_THREADS" \emph{before} starting R.
-%%  ~~ If necessary, more details than the description above ~~
-}
-\value{ Returns a list of 3 matrices each of size ncol(cts) by
-    ncol(cts)
-    \item{mi}{ The raw MI estimates.}
-    \item{bcmi}{Jackknife bias corrected MI estimates (BCMI). These are each MI value
-    minus the corresponding jackknife estimate of bias.}
-    \item{zvalues}{Z-scores for each hypothesis that the corresponding 
-    BCMI value is zero. These have poor statistical properties but can be useful
-    as a rough measure of the strength of association.}
-%%  ~Describe the value returned
-%%  If it is a LIST, use
-%%  \item{comp1 }{Description of 'comp1'}
-%%  \item{comp2 }{Description of 'comp2'}
-%% ...
-}
-%% \references{
-%% %% ~put references to the literature/web site here ~
-%% }
-%% \author{
-%% %%  ~~who you are~~
-%% }
-%% \note{
-%% %%  ~~further notes~~
-%% }
-%% 
-%% %% ~Make other sections like Warning with \section{Warning }{....} ~
-%% 
-%% \seealso{
-%% %% ~~objects to See Also as \code{\link{help}}, ~~~
-%% }
-\examples{
-##################################################
-# The USArrests dataset
-
-# Matrix version
-c1 <- cmi(USArrests)
-lapply(c1, round, 2)
-
-# Pairwise version
-cmi.pw(USArrests[,1], USArrests[,2])
-
-# Without jackknife
-c2 <- cminjk(USArrests)
-round(c2, 2)
-cminjk.pw(USArrests[,1], USArrests[,2])
-
-##################################################
-# A look at Anscombe's famous dataset.
-par(mfrow = c(2,2))
-plot(anscombe$x1, anscombe$y1)
-plot(anscombe$x2, anscombe$y2)
-plot(anscombe$x3, anscombe$y3)
-plot(anscombe$x4, anscombe$y4)
-
-cor(anscombe$x1, anscombe$y1)
-cor(anscombe$x2, anscombe$y2)
-cor(anscombe$x3, anscombe$y3)
-cor(anscombe$x4, anscombe$y4)
-
-cmi.pw(anscombe$x1, anscombe$y1)
-cmi.pw(anscombe$x2, anscombe$y2)
-cmi.pw(anscombe$x3, anscombe$y3)
-# dpik() has some trouble with zero scale estimates on this one:
-cmi.pw(anscombe$x4, anscombe$y4, scalest = "stdev")
-##################################################
-
-##################################################
-# The highly collinear Longley dataset
-
-pairs(longley, main = "longley data")
-l1 <- cmi(longley)
-lapply(l1, round, 2)
-
-# Here we demonstrate the scale-invariance of MI.
-# Note: Scaling can help stabilise estimates when there are
-# difficulties with the bandwidth estimation, but is unnecessary
-# here.
-long2 <- scale(longley)
-l2 <- cmi(long2)
-lapply(l2, round, 2)
-
-##################################################
-# See the vignette for large-scale examples.
-}
-% Add one or more standard keywords, see file 'KEYWORDS' in the
-% R documentation directory.
-% \keyword{ ~kwd1 }
-% \keyword{ ~kwd2 }% __ONLY ONE__ keyword per line
diff -Nru orig/mpmi/man/cts.Rd patched/mpi/man/cts.Rd
--- orig/mpmi/man/cts.Rd	2014-09-21 18:58:08.000000000 -0700
+++ patched/mpi/man/cts.Rd	1969-12-31 16:00:00.000000000 -0800
@@ -1,13 +0,0 @@
-\name{cts}
-\alias{cts}
-\docType{data}
-\alias{cts}
-\title{A group of simulated continuous variables}
-\description{
-    50 observations on each of 100 variables. The data are simulated such that
-variables with similar indices are associated with the degree of association 
-decaying as variables are further apart (i.e., a correlation or information
-matrix with have larger values near the diagonal). Details are given in the vignette.
-}
-\usage{data(mpmidata); cts}
-\format{A matrix with 50 rows and 100 columns}
diff -Nru orig/mpmi/man/disc.Rd patched/mpi/man/disc.Rd
--- orig/mpmi/man/disc.Rd	2014-09-21 18:58:08.000000000 -0700
+++ patched/mpi/man/disc.Rd	1969-12-31 16:00:00.000000000 -0800
@@ -1,13 +0,0 @@
-\name{disc}
-\alias{disc}
-\docType{data}
-\title{A group of simulated categorical (discrete) variables}
-\description{
-    50 observations on each of 75 categorical variables. These variables are 
-designed to be similar to categorical single nucleotide polymorphism (SNP) data
-which have 3 categories (A, H and B where H represents a heterozygous mutation). 
-There are no associations between any of the variables. The variables are stored 
-as characters. See the vignette for details
-}
-\usage{data(mpmidata); disc}
-\format{A matrix of characters with 50 rows and 75 columns}
diff -Nru orig/mpmi/man/dmi.Rd patched/mpi/man/dmi.Rd
--- orig/mpmi/man/dmi.Rd	2014-09-21 18:58:08.000000000 -0700
+++ patched/mpi/man/dmi.Rd	1969-12-31 16:00:00.000000000 -0800
@@ -1,87 +0,0 @@
-\name{dmi}
-\alias{dmi}
-\alias{dminjk}
-\alias{dmi.pw}
-\alias{dminjk.pw}
-%- Also NEED an '\alias' for EACH other topic documented here.
-\title{ Calculate BCMI for categorical (discrete) data
-%%  ~~function to do ... ~~
-}
-\description{ This function calculates MI and BCMI between a set of discrete variables
-    held as columns in a matrix. It also performs jackknife bias correction and
-    provides a z-score for the hypothesis of no association. Also included are
-    the *.pw functions that calculate MI between two vectors only. The *njk
-    functions do not perform the jackknife and are therefore faster. 
-%%  ~~ A concise (1-5 lines) description of what the function does. ~~
-}
-\usage{
-dmi(dmat)
-dminjk(dmat)
-dmi.pw(disc1, disc2)
-dminjk.pw(disc1, disc2)
-}
-%- maybe also 'usage' for other objects documented here.
-\arguments{
-  \item{dmat}{ The data matrix. Each row is an observation and each column is a
-      variable of interest. Should contain categorical data, all types of data
-       will be coerced via factors to integers.
-}
-    \item{disc1}{ A vector for the pairwise version}
-    \item{disc2}{ A vector for the pairwise version}
-}
-\details{ The results of dmi() are in many ways similar to a correlation matrix,
-    with each row and column index corresponding to a given variable.
-    dminjk() and dminjk.pw() just returns the MI values without performing the
-    jackknife. The number of processor cores used can be changed by
-    setting the environment variable "OMP_NUM_THREADS" \emph{before} starting R.
-}
-\value{ Returns a list of 3 matrices each of size \code{ncol(dmat)} by
-    \code{ncol(dmat)}
-    \item{mi}{ The raw MI estimates.}
-    \item{bcmi}{ Jackknife bias corrected MI estimates (BCMI). These are each MI value
-    minus the corresponding jackknife estimate of bias.}
-    \item{zvalues}{ Z-scores for each hypothesis that the corresponding 
-    bcmi value is zero. These have poor statistical properties but can be useful
-    as a rough measure of the strength of association.}
-}
-%% \references{
-%% %% ~put references to the literature/web site here ~
-%% }
-%% \author{
-%% %%  ~~who you are~~
-%% }
-%% \note{
-%% %%  ~~further notes~~
-%% }
-%% 
-%% %% ~Make other sections like Warning with \section{Warning }{....} ~
-%% 
-%% \seealso{
-%% %% ~~objects to See Also as \code{\link{help}}, ~~~
-%% }
-\examples{
-data(cars)
-
-# Discretise the data first
-d <- cut(cars$dist, breaks = 10)
-s <- cut(cars$speed, breaks = 10)
-
-# Discrete MI values
-dmi.pw(s, d)
-
-# For comparison, analysed as continuous data:
-cmi.pw(cars$dist, cars$speed)
-
-# Exploring a group of categorical variables
-dat <- mtcars[, c("cyl","vs","am","gear","carb")]
-discresults <- dmi(dat)
-discresults
-
-# Plot the relative magnitude of the BCMI values
-diag(discresults$bcmi) <- NA
-mp(discresults$bcmi)
-}
-% Add one or more standard keywords, see file 'KEYWORDS' in the
-% R documentation directory.
-% \keyword{ ~kwd1 }
-% \keyword{ ~kwd2 }% __ONLY ONE__ keyword per line
diff -Nru orig/mpmi/man/mmi.Rd patched/mpi/man/mmi.Rd
--- orig/mpmi/man/mmi.Rd	2014-09-21 18:58:08.000000000 -0700
+++ patched/mpi/man/mmi.Rd	1969-12-31 16:00:00.000000000 -0800
@@ -1,136 +0,0 @@
-\name{mmi}
-\alias{mmi}
-\alias{mminjk}
-\alias{mmi.pw}
-\alias{mminjk.pw}
-%- Also NEED an '\alias' for EACH other topic documented here.
-\title{ Calculate mixed-pair BCMI between a set of continuous variables and a set
-    of discrete variables.
-%%  ~~function to do ... ~~
-}
-\description{This function calculates MI and BCMI between a set of continuous variables
-    and a set of discrete variables (variables in columns). It also performs
-    jackknife bias correction and provides a z-score for the hypothesis of no
-    association. Also included are the *.pw functions that calculate MI between
-    two vectors only. The *njk functions do not perform the jackknife and are
-    therefore faster. 
-    %%  ~~ A concise (1-5 lines) description of what the function does. ~~
-}
-\usage{
-mmi(cts, disc, level = 3L, na.rm = FALSE, h, ...)
-mminjk(cts, disc, level = 3L, na.rm = FALSE, h, ...)
-mmi.pw(cts, disc, h, ...) 
-mminjk.pw(cts, disc, h, ...)
-}
-%- maybe also 'usage' for other objects documented here.
-\arguments{
-  \item{cts}{ The data matrix. Each row is an observation and each column is a
-      variable of interest. Should be numerical data. (For the pairwise functions this
-	should be a vector.)
-%%     ~~Describe \code{cts} here~~
-}
-    \item{disc}{ Matrix of discrete data, each row is an observation and each
-        column is a variable. Will be coerced to integers. (For the pairwise functions this
-	should be a vector.)}
-%%
-  \item{level}{ The number of levels used for plug-in bandwidth estimation (see
-      the documentation for the KernSmooth package.)
-%%     ~~Describe \code{level} here~~
-}
-  \item{na.rm}{ Remove missing values if TRUE. This is required for the
-      bandwidth calculation.
-%%     ~~Describe \code{na.rm} here~~
-}
-  \item{h}{ A (double) vector of smoothing bandwidths, one for each variable. If
-      missing this will be calculated using the dpik() function from the
-      KernSmooth package.
-%%     ~~Describe \code{h} here~~
-}
-  \item{\dots}{ Additional options passed to dpik() if necessary.
-%%     ~~Describe \code{\dots} here~~
-} 
-}
-\details{mminjk() and mminjk.pw() return just the MI values without performing the
-    jackknife. mmi.pw() and mminjk.pw() only require one bandwidth for the
-    continuous variable. The number of processor cores used can be changed by
-    setting the environment variable "OMP_NUM_THREADS" \emph{before} starting R.
-%%  ~~ If necessary, more details than the description above ~~
-}
-\value{ Returns a list of 3 matrices each of size ncol(cts) by
-    ncol(disc). Each row index represents a continuous variable and each column
-    index a discrete variable. 
-    \item{mi}{The raw MI estimates.}
-    \item{bcmi}{Jackknife bias corrected MI estimates (BCMI). These are each MI value
-    minus the corresponding jackknife estimate of bias.}
-    \item{zvalues}{z-scores for each hypothesis that the corresponding 
-    bcmi value is zero. These have poor statistical properties but can be useful
-    as a rough measure of the strength of association.}
-%%  ~Describe the value returned
-%%  If it is a LIST, use
-%%  \item{comp1 }{Description of 'comp1'}
-%%  \item{comp2 }{Description of 'comp2'}
-%% ...
-}
-%% \references{
-%% %% ~put references to the literature/web site here ~
-%% }
-%% \author{
-%% %%  ~~who you are~~
-%% }
-%% \note{
-%% %%  ~~further notes~~
-%% }
-%% 
-%% %% ~Make other sections like Warning with \section{Warning }{....} ~
-%% 
-%% \seealso{
-%% %% ~~objects to See Also as \code{\link{help}}, ~~~
-%% }
-\examples{
-
-##################################################
-# A dataset with discrete and continuous variables
-
-cts <- state.x77
-disc <- data.frame(state.division,state.region)
-summary(cts)
-table(disc)
-m1 <- mmi(cts, disc)
-lapply(m1, round, 2)
-# Division gives more information about the continuous variables than region.
-
-# Here is one where both division and region show a strong association:
-boxplot(cts[,6] ~ disc[,1])
-boxplot(cts[,6] ~ disc[,2])
-
-# In this case the states need to be divided into regions before a clear
-# association can be seen:
-boxplot(cts[,1] ~ disc[,1])
-boxplot(cts[,1] ~ disc[,2])
-
-# Look at associations within the continuous variables:
-pairs(cts, col = state.region)
-c1 <- cmi(cts)
-lapply(c1, round, 2)
-
-##################################################
-# A pairwise comparison
-
-# Note that the ANOVA homoskedasticity assumption is not satisfied here.
-boxplot(InsectSprays[,1] ~ InsectSprays[,2])
-mmi.pw(InsectSprays[,1], InsectSprays[,2])
-
-##################################################
-# Another pairwise comparison
-
-boxplot(morley[,3] ~ morley[,1])
-m2 <- mmi.pw(morley[,3], morley[,1])
-m2
-
-##################################################
-# See the vignette for large-scale examples.
-}
-% Add one or more standard keywords, see file 'KEYWORDS' in the
-% R documentation directory.
-% \keyword{ ~kwd1 }
-% \keyword{ ~kwd2 }% __ONLY ONE__ keyword per line
diff -Nru orig/mpmi/man/mp.Rd patched/mpi/man/mp.Rd
--- orig/mpmi/man/mp.Rd	2014-09-21 18:58:08.000000000 -0700
+++ patched/mpi/man/mp.Rd	1969-12-31 16:00:00.000000000 -0800
@@ -1,27 +0,0 @@
-\name{mp}
-\alias{mp}
-\title{Matrix Plot}
-\description{
-    Plot a matrix of values in the same order that it is stored 
-(the usual mathematical way).
-}
-\usage{
-mp(mat, ...)
-}
-\arguments{
-  \item{mat}{A numeric matrix to be plotted}
-  \item{...}{Additional arguments to pass to \code{image()}}
-}
-\details{
-The \code{mp()} function is a simple wrapper to
-\code{image()} with a few minor changes. The plot is
-flipped so that points correspond to their position in the
-matrix. Also, the colours are scaled so that red is the
-maximum value in the matrix and white is the minimum value.
-}
-\examples{
-# From the vignette:
-data(mpmidata)
-ctsresult <- cmi(cts)
-mp(ctsresult$bcmi)
-} 
diff -Nru orig/mpmi/src/10iface.f95 patched/mpi/src/10iface.f95
--- orig/mpmi/src/10iface.f95	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/src/10iface.f95	1969-12-31 16:00:00.000000000 -0800
@@ -1,28 +0,0 @@
-! 
-!     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
-! 
-!     This file is part of the mpmi R package.
-! 
-!     This program is free software: you can redistribute it and/or modify
-!     it under the terms of the GNU General Public License as published by
-!     the Free Software Foundation, version 3.
-! 
-!     This program is distributed in the hope that it will be useful,
-!     but WITHOUT ANY WARRANTY; without even the implied warranty of
-!     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-!     GNU General Public License for more details.
-! 
-!     You should have received a copy of the GNU General Public License
-!     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-!
-
-
-! This module is just to get the variable kind
-! for double precision floats. 
-module iface
-    implicit none
-
-    ! Double precision in R is real(kind=rdble)
-    ! Used in all other functions
-    integer, parameter :: rdble = kind(0.d0)
-end module
diff -Nru orig/mpmi/src/Makevars patched/mpi/src/Makevars
--- orig/mpmi/src/Makevars	2019-10-30 02:56:48.000000000 -0700
+++ patched/mpi/src/Makevars	1969-12-31 16:00:00.000000000 -0800
@@ -1,17 +0,0 @@
-USE_FC_TO_LINK=
-PKG_FCFLAGS=$(SHLIB_OPENMP_FFLAGS)
-PKG_LIBS=$(SHLIB_OPENMP_FFLAGS)
-
-all: $(SHLIB)
-
-cmi.o: 10iface.o
-
-cminjk.o: 10iface.o  
-
-dmi.o: 10iface.o  
-
-mmi.o: 10iface.o  
-
-mminjk.o: 10iface.o  
-
-
diff -Nru orig/mpmi/src/cmi.f95 patched/mpi/src/cmi.f95
--- orig/mpmi/src/cmi.f95	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/src/cmi.f95	1969-12-31 16:00:00.000000000 -0800
@@ -1,255 +0,0 @@
-! 
-!     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
-! 
-!     This file is part of the mpmi R package.
-! 
-!     This program is free software: you can redistribute it and/or modify
-!     it under the terms of the GNU General Public License as published by
-!     the Free Software Foundation, version 3.
-! 
-!     This program is distributed in the hope that it will be useful,
-!     but WITHOUT ANY WARRANTY; without even the implied warranty of
-!     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-!     GNU General Public License for more details.
-! 
-!     You should have received a copy of the GNU General Public License
-!     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-!
-
-
-! Epanechnikov kernel
-! Pairwise only
-! Jackknife
-subroutine cmipw(v1, v2, lv, h1, h2, ans, mps, zvalue)
-    use iface
-    implicit none
-
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    ! Input variables:
-    
-    ! Length of vectors 
-    integer, intent(in) :: lv
-    ! Data vectors
-    real(kind=rdble), dimension(lv), intent(in) :: v1, v2
-    ! Smoothing bandwidths in each dimension
-    ! (corresponding to v1 and v2 respectively)
-    real(kind=rdble), intent(in) :: h1, h2
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    ! Output variables:
-    ! ans = raw MI
-    ! mps = jackknife bias corrected MI
-    ! zvalue = z value for hypothesis that mps == 0
-    real(kind=rdble), intent(out) :: ans, mps, zvalue
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    ! Local variables:
-    ! Loop indices
-    integer :: i, j, k
-
-    ! Temporary variables for calculating kernel matrix
-    real(kind=rdble) :: t1, t2
-
-    ! Sums of kernel distances for each point (of lv points)
-    !
-    ! s1 & s2 hold sums of kernel distances from each point
-    ! to all other points
-    !
-    ! s12 holds the sums of product kernels for each point
-    real(kind=rdble), dimension(lv) :: s1, s2, s12
-    
-    ! Jackknife replication MI values
-    real(kind=rdble), dimension(lv) :: ansjk
-
-    ! Jackknife pseudo-values
-    real(kind=rdble), dimension(lv) :: ps
-
-    ! Temporary variables for jackknife
-    real(kind=rdble) :: ts1, ts2, ts12
-
-    ! SD of pseudo-values
-    real(kind=rdble) :: sdps
-
-    ! Kernel matrices for vectors 1 & 2
-    real(kind=rdble), dimension(lv, lv) :: kmat1, kmat2 
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-    ans = 0.0
-
-    ! Pre-calculate kernel distances
-    ! Inefficient matrix of kernel distances (should probably pack into vector)
-    kmat1 = 0.0 
-    kmat2 = 0.0 
-    t1 = 0.0
-    t2 = 0.0
-
-    ! Separate loops hopefully help cache locality
-    ! Vector 1:
-    do i = 1, lv
-        do j = i + 1, lv
-            ! Epanechnikov kernel
-            t1 = (v1(j) - v1(i)) / h1
-            if (abs(t1) .ge. 1.0) then
-                t1 = 0.0
-            else
-                t1 = 1.0 - (t1 * t1) 
-            end if
-            kmat1(i, j) = t1
-
-            ! Symmetrise
-            kmat1(j, i) = kmat1(i, j)
-        end do
-        kmat1(i, i) = kmat1(i, i) + 1.0
-    end do
-    ! Vector 2:
-    do i = 1, lv
-        do j = i + 1, lv
-            ! Epanechnikov kernel
-            t2 = (v2(j) - v2(i)) / h2
-            if (abs(t2) .ge. 1.0) then
-                t2 = 0.0
-            else
-                t2 = 1.0 - (t2 * t2) 
-            end if
-            kmat2(i, j) = t2
-
-            ! Symmetrise
-            kmat2(j, i) = kmat2(i, j)
-        end do
-        kmat2(i, i) = kmat2(i, i) + 1.0
-    end do
-
-    s1 = 0.0
-    s2 = 0.0
-    s12 = 0.0
-
-    ! N.B., this uses the simple 'product kernel'
-    ! approach for 2D kernel density estimation
-    do i = 1, lv
-        do j = i + 1, lv
-
-            s1(i) = s1(i) + kmat1(i,j)
-            s2(i) = s2(i) + kmat2(i,j)
-
-            ! Use product kernel for joint distribution
-            s12(i) = s12(i) + kmat1(i,j) * kmat2(i,j)
-
-            ! Using kernel symmetry
-            s1(j) = s1(j) + kmat1(i,j) 
-            s2(j) = s2(j) + kmat2(i,j) 
-            s12(j) = s12(j) + kmat1(i,j) * kmat2(i,j)
-        end do
-
-        ! For when i == j
-        s1(i) = s1(i) + 1.0
-        s2(i) = s2(i) + 1.0
-        s12(i) = s12(i) + 1.0
-        
-        ! Accumulate raw MI value
-        ans = ans + log(s12(i) / (s1(i) * s2(i)))
-    end do
-    ans = ans / lv + log(dble(lv))
-
-    ! Get jackknife estimates
-    ansjk = 0.0
-    do k = 1, lv
-        do i = 1, lv
-            ! Exclude kth observation
-            if (i .ne. k) then
-                ! Subtract kernel distances corresponding 
-                ! to kth (excluded) observation
-                ts1 = s1(i) - kmat1(k, i)
-                ts2 = s2(i) - kmat2(k, i)
-                ts12 = s12(i) - kmat1(k, i) * kmat2(k, i)
-
-                ! Accumulate jackknife MI values
-                ansjk(k) = ansjk(k) + log(ts12 / (ts1 * ts2))
-            end if
-        end do
-    end do
-    ansjk = ansjk / (dble(lv) - 1.0) + log(dble(lv) - 1.0)
-
-    ! Tukey's jackknife pseudo values
-    ps = dble(lv) * ans - (dble(lv) - 1.0) * ansjk
-
-    ! Bias corrected MI
-    mps = sum(ps) / dble(lv)
-    ! Get z-value for hypothesis that mps == 0
-    sdps = sqrt(sum((ps - mps) * (ps - mps)) / (dble(lv) - 1.0))
-    zvalue = sqrt(dble(lv)) * mps / sdps
-end subroutine
-
-subroutine cmim(cdat, nrc, ncc, mis, bcmis, zmat, h)
-    use iface
-    implicit none
-
-    ! Input variables
-    integer, intent(in) :: nrc, ncc
-    real(kind=rdble), dimension(nrc, ncc), intent(in) :: cdat
-    real(kind=rdble), dimension(ncc), intent(in) :: h
-    ! integer, dimension(nrs, ncs), intent(in) :: sdat
-
-    ! Output matrices
-    real(kind=rdble), dimension(ncc, ncc), intent(out) :: mis
-    real(kind=rdble), dimension(ncc, ncc), intent(out) :: bcmis
-    ! Matrix of z-values
-    real(kind=rdble), dimension(ncc, ncc), intent(out) :: zmat
-
-    ! Arrays to hold non-missing observations only
-    ! Reuse 'static' arrays for speed
-    real(kind=rdble), dimension(nrc) :: cvec, svec
-
-    ! Local variables
-    integer :: i, j, nok, k
-    logical, dimension(nrc) :: ok
-
-    ! R function to check real missing values
-    integer :: rfinite
-
-    !$omp parallel do default(none) shared(ncc, nrc, cdat, &
-    !$omp h, mis, bcmis, zmat)  &
-    !$omp private(ok, nok, cvec, svec, i, j) &
-    !$omp schedule(dynamic)
-    do i = 1, ncc
-        do j = i, ncc
-            ! Remove missing observations pairwise
-            do k = 1, nrc
-                if (rfinite(cdat(k,i)) == 1 .and. rfinite(cdat(k,j)) == 1) then
-                    ok(k) = .true.
-                else
-                    ok(k) = .false.
-                end if
-            end do
-
-            nok = count(ok)
-
-            ! Only perform calculation if there are non-missing values
-            ! in both input vectors (set to 3 for no real reason)
-            if (nok > 2) then
-                ! Pack non-missing values
-                cvec = pack(cdat(:,i), mask = ok)
-                svec = pack(cdat(:,j), mask = ok)
-
-                ! Call pairwise continuous MI subroutine.
-                call cmipw(cvec(1:nok), svec(1:nok), nok, h(i), h(j), mis(i,j), bcmis(i,j), zmat(i,j))
-            else
-                ! Set all results to zero
-                mis(i, j) = 0.0
-                bcmis(i, j) = 0.0
-                zmat(i, j) = 0.0
-            end if
-
-            ! Symmetrise result matrix
-            if (i .ne. j) then
-                mis(j, i) = mis(i, j)
-                bcmis(j, i) = bcmis(i, j)
-                zmat(j, i) = zmat(i, j)
-            end if
-        end do
-    end do
-    !$omp end parallel do
-end subroutine
-
-
diff -Nru orig/mpmi/src/cminjk.f95 patched/mpi/src/cminjk.f95
--- orig/mpmi/src/cminjk.f95	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/src/cminjk.f95	1969-12-31 16:00:00.000000000 -0800
@@ -1,206 +0,0 @@
-! 
-!     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
-! 
-!     This file is part of the mpmi R package.
-! 
-!     This program is free software: you can redistribute it and/or modify
-!     it under the terms of the GNU General Public License as published by
-!     the Free Software Foundation, version 3.
-! 
-!     This program is distributed in the hope that it will be useful,
-!     but WITHOUT ANY WARRANTY; without even the implied warranty of
-!     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-!     GNU General Public License for more details.
-! 
-!     You should have received a copy of the GNU General Public License
-!     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-!
-
-
-! Epanechnikov kernel
-! Pairwise only
-! NO Jackknife
-subroutine cmipwnjk(v1, v2, lv, h1, h2, ans)
-    use iface
-    implicit none
-
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    ! Input variables:
-    
-    ! Length of vectors 
-    integer, intent(in) :: lv
-    ! Data vectors
-    real(kind=rdble), dimension(lv), intent(in) :: v1, v2
-    ! Smoothing bandwidths in each dimension
-    ! (corresponding to v1 and v2 respectively)
-    real(kind=rdble), intent(in) :: h1, h2
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    ! Output variables:
-    ! ans = raw MI
-    real(kind=rdble), intent(out) :: ans 
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    ! Local variables:
-    ! Loop indices
-    integer :: i, j, k
-
-    ! Temporary variables for calculating kernel matrix
-    real(kind=rdble) :: t1, t2
-
-    ! Sums of kernel distances for each point (of lv points)
-    !
-    ! s1 & s2 hold sums of kernel distances from each point
-    ! to all other points
-    !
-    ! s12 holds the sums of product kernels for each point
-    real(kind=rdble), dimension(lv) :: s1, s2, s12
-
-    ! Kernel matrices for vectors 1 & 2
-    real(kind=rdble), dimension(lv, lv) :: kmat1, kmat2 
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-    ans = 0.0
-
-    ! Pre-calculate kernel distances
-    ! Inefficient matrix of kernel distances (should probably pack into vector)
-    kmat1 = 0.0 
-    kmat2 = 0.0 
-    t1 = 0.0
-    t2 = 0.0
-
-    ! Separate loops hopefully help cache locality
-    ! Vector 1:
-    do i = 1, lv
-        do j = i + 1, lv
-            ! Epanechnikov kernel
-            t1 = (v1(j) - v1(i)) / h1
-            if (abs(t1) .ge. 1.0) then
-                t1 = 0.0
-            else
-                t1 = 1.0 - (t1 * t1) 
-            end if
-            kmat1(i, j) = t1
-
-            ! Symmetrise
-            kmat1(j, i) = kmat1(i, j)
-        end do
-        kmat1(i, i) = kmat1(i, i) + 1.0
-    end do
-    ! Vector 2:
-    do i = 1, lv
-        do j = i + 1, lv
-            ! Epanechnikov kernel
-            t2 = (v2(j) - v2(i)) / h2
-            if (abs(t2) .ge. 1.0) then
-                t2 = 0.0
-            else
-                t2 = 1.0 - (t2 * t2) 
-            end if
-            kmat2(i, j) = t2
-
-            ! Symmetrise
-            kmat2(j, i) = kmat2(i, j)
-        end do
-        kmat2(i, i) = kmat2(i, i) + 1.0
-    end do
-
-    s1 = 0.0
-    s2 = 0.0
-    s12 = 0.0
-
-    ! N.B., this uses the simple 'product kernel'
-    ! approach for 2D kernel density estimation
-    do i = 1, lv
-        do j = i + 1, lv
-
-            s1(i) = s1(i) + kmat1(i,j)
-            s2(i) = s2(i) + kmat2(i,j)
-
-            ! Use product kernel for joint distribution
-            s12(i) = s12(i) + kmat1(i,j) * kmat2(i,j)
-
-            ! Using kernel symmetry
-            s1(j) = s1(j) + kmat1(i,j) 
-            s2(j) = s2(j) + kmat2(i,j) 
-            s12(j) = s12(j) + kmat1(i,j) * kmat2(i,j)
-        end do
-
-        ! For when i == j
-        s1(i) = s1(i) + 1.0
-        s2(i) = s2(i) + 1.0
-        s12(i) = s12(i) + 1.0
-        
-        ! Accumulate raw MI value
-        ans = ans + log(s12(i) / (s1(i) * s2(i)))
-    end do
-    ans = ans / lv + log(dble(lv))
-    
-end subroutine
-
-subroutine cmimnjk(cdat, nrc, ncc, mis, h)
-    use iface
-    implicit none
-
-    ! Input variables
-    integer, intent(in) :: nrc, ncc
-    real(kind=rdble), dimension(nrc, ncc), intent(in) :: cdat
-    real(kind=rdble), dimension(ncc), intent(in) :: h
-
-    ! Output matrices
-    real(kind=rdble), dimension(ncc, ncc), intent(out) :: mis
-
-    ! Arrays to hold non-missing observations only
-    ! Reuse 'static' arrays for speed
-    real(kind=rdble), dimension(nrc) :: cvec, svec
-
-    ! Local variables
-    integer :: i, j, nok, k
-    logical, dimension(nrc) :: ok
-
-    ! R function to check real missing values
-    integer :: rfinite
-
-    !$omp parallel do default(none) shared(ncc, nrc, cdat, &
-    !$omp h, mis)  &
-    !$omp private(ok, nok, cvec, svec, i, j) &
-    !$omp schedule(dynamic)
-    do i = 1, ncc
-        do j = i, ncc
-            ! Remove missing observations pairwise
-            do k = 1, nrc
-                if (rfinite(cdat(k,i)) == 1 .and. rfinite(cdat(k,j)) == 1) then
-                    ok(k) = .true.
-                else
-                    ok(k) = .false.
-                end if
-            end do
-
-            nok = count(ok)
-
-            ! Only perform calculation if there are non-missing values
-            ! in both input vectors (set to 3 for no real reason)
-            if (nok > 2) then
-                ! Pack non-missing values
-                cvec = pack(cdat(:,i), mask = ok)
-                svec = pack(cdat(:,j), mask = ok)
-
-                ! Call pairwise continuous MI subroutine.
-                call cmipwnjk(cvec(1:nok), svec(1:nok), nok, h(i), h(j), mis(i,j))
-            else
-                ! Set all results to zero
-                mis(i, j) = 0.0
-            end if
-
-            ! Symmetrise result matrix
-            if (i .ne. j) then
-                mis(j, i) = mis(i, j)
-            end if
-        end do
-    end do
-    !$omp end parallel do
-end subroutine
-
-
diff -Nru orig/mpmi/src/dmi.f95 patched/mpi/src/dmi.f95
--- orig/mpmi/src/dmi.f95	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/src/dmi.f95	1969-12-31 16:00:00.000000000 -0800
@@ -1,294 +0,0 @@
-! 
-!     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
-! 
-!     This file is part of the mpmi R package.
-! 
-!     This program is free software: you can redistribute it and/or modify
-!     it under the terms of the GNU General Public License as published by
-!     the Free Software Foundation, version 3.
-! 
-!     This program is distributed in the hope that it will be useful,
-!     but WITHOUT ANY WARRANTY; without even the implied warranty of
-!     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-!     GNU General Public License for more details.
-! 
-!     You should have received a copy of the GNU General Public License
-!     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-!
-
-
-subroutine dmim(sdat, nrs, ncs, mis, bcmis, zmat)
-    use iface
-    implicit none
-
-    ! Input variables
-    integer, intent(in) :: nrs, ncs
-    integer, dimension(nrs, ncs), intent(in) :: sdat
-
-    ! Output matrices
-    real(kind=rdble), dimension(ncs, ncs), intent(out) :: mis
-    real(kind=rdble), dimension(ncs, ncs), intent(out) :: bcmis
-    ! Matrix of z-values
-    real(kind=rdble), dimension(ncs, ncs), intent(out) :: zmat
-
-    ! Local variables
-    integer :: i, j, nok
-    logical, dimension(nrs) :: ok
-    ! Arrays to hold non-missing observations only
-    integer, dimension(nrs) :: cvec, svec
-
-    ! C function to get R integer NA value
-    integer :: rnaint
-    ! Local variable to hold R NA value
-    integer :: naint
-
-    ! Assign R NA value
-    naint = rnaint()
-
-    !$omp parallel do default(none) shared(ncs, sdat, naint, mis, bcmis, zmat) &
-    !$omp private(i, j, ok, nok, cvec, svec) &
-    !$omp schedule(dynamic)
-    do i = 1, ncs
-        do j = i, ncs
-            ! Delete observations pairwise if either is missing
-            ok = sdat(:,i) /= naint .and. sdat(:,j) /= naint
-
-            nok = count(ok)
-
-            cvec = pack(sdat(:,i), mask = ok)
-            svec = pack(sdat(:,j), mask = ok)
-
-            call dmi(cvec(1:nok), nok, svec(1:nok), nok, mis(i,j), bcmis(i,j), zmat(i,j))
-
-            ! Symmetrise result matrix
-            if (i .ne. j) then
-                mis(j, i) = mis(i, j)
-                bcmis(j, i) = bcmis(i, j)
-                zmat(j, i) = zmat(i, j)
-            end if
-        end do
-    end do
-    !$omp end parallel do
-end subroutine
-
-subroutine dmi(v1, l1, v2, l2, ans, mps, zvalue) 
-    use iface
-    implicit none
-
-    ! Input variables
-    integer, intent(in) :: l1, l2
-    integer, dimension(l1), intent(in) :: v1
-    integer, dimension(l2), intent(in) :: v2
-
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    ! Output variables:
-    ! ans = raw MI
-    ! mps = jackknife bias corrected MI
-    ! zvalue = z value for hypothesis that mps == 0
-    real(kind=rdble), intent(out) :: ans, mps, zvalue
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-    ! Local variables
-    integer i, j, lev1, lev2, k, l
-    real(kind=rdble) :: tot
-
-    ! Local dynamic arrays
-    integer, dimension(:,:), allocatable :: tab
-    real(kind=rdble), dimension(:,:), allocatable :: ptab
-    real(kind=rdble), dimension(:), allocatable :: rv, cv
-    
-    ! Jackknife replication MI values
-    real(kind=rdble), dimension(l1) :: ansjk
-
-    ! Jackknife pseudo-values
-    real(kind=rdble), dimension(l1) :: ps
-
-    ! SD of pseudo-values
-    real(kind=rdble) :: sdps
-
-    lev1 = maxval(v1)
-    lev2 = maxval(v2)
-
-    ! Initialise dynamic arrays
-    allocate(tab(lev1, lev2))
-    tab = 0
-    allocate(ptab(lev1, lev2))
-    allocate(rv(lev1))
-    allocate(cv(lev2))
-
-    ! Cross tab for joint distribution
-    do i = 1, l1
-        tab(v1(i), v2(i)) = tab(v1(i), v2(i)) + 1
-    end do
-
-    ! Marginal counts (sum over joint)
-    cv = sum(tab, dim = 1)
-    rv = sum(tab, dim = 2)
-    tot = sum(tab)
-
-    ! Probability tables
-    ptab = tab / tot
-    rv = rv / tot
-    cv = cv / tot
-
-    ans = 0.0
-
-    ! Calculate MI
-    do i = 1, lev1
-        do j = 1, lev2
-            if (ptab(i, j) > 0) then
-                ans = ans + ptab(i,j) * log(ptab(i,j) / (rv(i) * cv(j))) 
-            end if
-        end do
-    end do
-
-    ! Get jackknife estimates
-    ! Not yet modified for discrete data
-    ! TODO
-    ansjk = 0.0
-    do k = 1, l1
-        ! Remove observation from the tables
-        tab(v1(k), v2(k)) = tab(v1(k), v2(k)) - 1
-
-        ! Marginal counts (sum over joint)
-        ! Some inefficiency here
-        cv = sum(tab, dim = 1)
-        rv = sum(tab, dim = 2)
-        tot = sum(tab)
-
-        ! Probability tables
-        ptab = tab / tot
-        rv = rv / tot
-        cv = cv / tot
-
-        do i = 1, lev1
-            do j = 1, lev2
-                if (ptab(i, j) > 0) then
-                    ansjk(k) = ansjk(k) + ptab(i,j) * log(ptab(i,j) / (rv(i) * cv(j))) 
-                end if
-            end do
-        end do
-
-        ! Put observation back in table
-        tab(v1(k), v2(k)) = tab(v1(k), v2(k)) + 1
-    end do
-
-    ! Get bias corrected MI value and z-value from the jackknife
-    ! using Tukey's pseudo-value approach.
-    ! (There are probably more efficient ways to do this.)
-    ps = dble(l1) * ans - (dble(l1) - 1.0) * ansjk
-
-    mps = sum(ps) / dble(l1)
-    sdps = sqrt(sum((ps - mps) * (ps - mps)) / (dble(l1) - 1.0))
-    zvalue = sqrt(dble(l1)) * mps / sdps
-
-    deallocate(tab, ptab, rv, cv)
-end subroutine
-
-subroutine dminjk(v1, l1, v2, l2, ans) 
-    use iface
-    implicit none
-
-    ! Input variables
-    integer, intent(in) :: l1, l2
-    integer, dimension(l1), intent(in) :: v1
-    integer, dimension(l2), intent(in) :: v2
-
-    ! Output variable
-    real(kind=rdble), intent(out) :: ans
-
-    ! Local variables
-    integer i, j, lev1, lev2, k, l
-    real(kind=rdble) :: tot
-
-    ! Local dynamic arrays
-    integer, dimension(:,:), allocatable :: tab
-    real(kind=rdble), dimension(:,:), allocatable :: ptab
-    real(kind=rdble), dimension(:), allocatable :: rv, cv
-
-    lev1 = maxval(v1)
-    lev2 = maxval(v2)
-
-    ! Initialise dynamic arrays
-    allocate(tab(lev1, lev2))
-    tab = 0
-    allocate(ptab(lev1, lev2))
-    allocate(rv(lev1))
-    allocate(cv(lev2))
-
-    ! Cross tab for joint distribution
-    do i = 1, l1
-        tab(v1(i), v2(i)) = tab(v1(i), v2(i)) + 1
-    end do
-
-    ! Marginal counts (sum over joint)
-    cv = sum(tab, dim = 1)
-    rv = sum(tab, dim = 2)
-    tot = sum(tab)
-
-    ! Probability tables
-    ptab = tab / tot
-    rv = rv / tot
-    cv = cv / tot
-
-    ans = 0.0
-
-    ! Calculate MI
-    do i = 1, lev1
-        do j = 1, lev2
-            if (ptab(i, j) > 0) then
-                ans = ans + ptab(i,j) * log(ptab(i,j) / (rv(i) * cv(j))) 
-            end if
-        end do
-    end do
-
-    deallocate(tab, ptab, rv, cv)
-end subroutine
-
-subroutine dmimnjk(sdat, nrs, ncs, ansm)
-    use iface
-    implicit none
-
-    ! Input variables
-    integer, intent(in) :: nrs, ncs
-    integer, dimension(nrs, ncs), intent(in) :: sdat
-
-    ! Output matrix
-    real(kind=rdble), dimension(ncs, ncs), intent(out) :: ansm
-
-    ! Local variables
-    integer :: i, j, nok
-    logical, dimension(nrs) :: ok
-    ! Arrays to hold non-missing observations only
-    integer, dimension(nrs) :: cvec, svec
-
-    ! C function to get R integer NA value
-    integer :: rnaint
-    ! Local variable to hold R NA value
-    integer :: naint
-
-    ! Assign R NA value
-    naint = rnaint()
-
-    !$omp parallel do default(none) shared(ncs, sdat, naint, ansm) &
-    !$omp private(i, j, ok, nok, cvec, svec) &
-    !$omp schedule(dynamic)
-    do i = 1, ncs
-        do j = i, ncs
-                ! Delete observations pairwise if either is missing
-                ok = sdat(:,i) /= naint .and. sdat(:,j) /= naint
-
-                nok = count(ok)
-
-                cvec = pack(sdat(:,i), mask = ok)
-                svec = pack(sdat(:,j), mask = ok)
-
-                call dminjk(cvec(1:nok), nok, svec(1:nok), nok, ansm(i,j))
-
-                ! Symmetrise
-                ansm(j,i) = ansm(i,j)
-        end do
-    end do
-    !$omp end parallel do
-end subroutine
-
diff -Nru orig/mpmi/src/mmi.f95 patched/mpi/src/mmi.f95
--- orig/mpmi/src/mmi.f95	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/src/mmi.f95	1969-12-31 16:00:00.000000000 -0800
@@ -1,261 +0,0 @@
-! 
-!     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
-! 
-!     This file is part of the mpmi R package.
-! 
-!     This program is free software: you can redistribute it and/or modify
-!     it under the terms of the GNU General Public License as published by
-!     the Free Software Foundation, version 3.
-! 
-!     This program is distributed in the hope that it will be useful,
-!     but WITHOUT ANY WARRANTY; without even the implied warranty of
-!     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-!     GNU General Public License for more details.
-! 
-!     You should have received a copy of the GNU General Public License
-!     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-!
-
-
-! Subroutine to calculate mixed-pair MI value with
-! jackknife bias correction and z-value.
-subroutine mmipw(cts, lc, disc, h, ans, mps, zvalue)
-    use iface
-    implicit none
-
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    ! Input variables:
-    ! Length of input vectors
-    integer, intent(in) :: lc
-
-    ! Vector for discrete variable (group membership)
-    integer, dimension(lc), intent(in) :: disc
-
-    ! Bandwidth for kernel density estimation
-    real(kind=rdble), intent(in) :: h
-
-    ! Continuous input vector
-    real(kind=rdble), dimension(lc), intent(in) :: cts
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    ! Output variables:
-    ! ans = raw MI value
-    ! mps = bias corrected mi value
-    ! zvalue = approximate z value for hypothesis that 
-    ! mps == 0
-    real(kind=rdble), intent(out) :: ans, mps, zvalue
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-   
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    ! Local variables:
-    ! Sums of kernel distances (see below)
-    real(kind=rdble), dimension(lc) :: t2, t3
-
-    ! Temporary variable for calculating kernel distances
-    real(kind=rdble) t1 
-
-    ! Loop indices
-    integer :: i, j, k 
-    ! Number of groups in discrete variable
-    integer :: levd
-
-    ! Kernel distance matrix
-    real(kind=rdble), dimension(lc, lc) :: kmat
-
-    ! Jackknifed MI scores
-    real(kind=rdble), dimension(lc) :: ansjk
-
-    ! Jackknife pseudo values
-    real(kind=rdble), dimension(lc) :: ps
-
-    ! Standard deviation of pseudo values
-    real(kind=rdble) :: sdps
-
-    ! Sums of kernel distances within jackknife
-    ! (I.e., with kth observation removed)
-    real(kind=rdble) :: t22, t32
-
-    ! Dynamic arrays:
-    ! Table of discrete variable
-    integer, dimension(:), allocatable :: tab
-
-    ! Above table scaled to probabilities / relative frequencies
-    real(kind=rdble), dimension(:), allocatable :: ptab
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-    ans = 0.0
-
-    ! Number of levels of factor (coded with integers)
-    levd = maxval(disc)
-
-    ! Initialise table
-    allocate(tab(levd))
-    tab = 0
-
-    ! Tabulate discrete variable
-    do i = 1, lc
-        tab(disc(i)) = tab(disc(i)) + 1
-    end do
-
-    ! Probability table
-    allocate(ptab(levd))
-    do i = 1, levd
-        ptab(i) = dble(tab(i)) / dble(lc)
-    end do
-
-    ! Matrix of kernel distances (inefficient - should probably pack into vector)
-    kmat = 0.0 
-    t1 = 0.0
-    do i = 1, lc
-        do j = i + 1, lc
-            ! Epanechnikov kernel
-            t1 = (cts(j) - cts(i)) / h
-            if (abs(t1) .ge. 1.0) then
-                t1 = 0.0
-            else
-                t1 = 1.0 - (t1 * t1) 
-            end if
-            kmat(i, j) = t1
-
-            ! Symmetrise
-            kmat(j, i) = kmat(i, j)
-        end do
-        kmat(i, i) = kmat(i, i) + 1.0
-    end do
-
-    ! Sum of kernel distances from cts(i) to all points
-    t2 = 0.0
-    ! Sum of kernel distances from cts(i) to all points in same subgroup
-    t3 = 0.0
-
-    ! Evaluate non-jackknifed MI and fill t2 and t3
-    do i = 1, lc
-        do j = i + 1, lc
-            t2(i) = t2(i) + kmat(i, j)
-
-            ! Using kernel symmetry
-            t2(j) = t2(j) + kmat(i, j)
-
-            if (disc(j) == disc(i)) then
-                t3(i) = t3(i) + kmat(i, j)
-                ! Using kernel symmetry
-                t3(j) = t3(j) + kmat(i, j)
-            end if
-        end do
-
-        ! For when i == j
-        t2(i) = t2(i) + 1.0
-        t3(i) = t3(i) + 1.0
-
-        ! Accumulate MI
-        ans = ans + ptab(disc(i)) * log(lc * t3(i) / (tab(disc(i)) * t2(i))) / tab(disc(i))
-    end do
-
-    ansjk = 0.0
-    do k = 1, lc
-        ! Remove kth observation from table of counts
-        ! (Because tab(disc(i)) may equal tab(disc(k)) below)
-        tab(disc(k)) = tab(disc(k)) - 1
-
-        do i = 1, lc
-            ! Exclude kth observation
-            if (i .ne. k) then
-                ! Subtracting kernel distances to kth observation (as per
-                ! jackknife)
-                t22 = t2(i) - kmat(k, i)
-
-                if (disc(i) == disc(k)) then
-                    t32 = t3(i) - kmat(k, i)
-                else
-                    t32 = t3(i)
-                end if
-       
-                ! Accumulate kth jackknife MI value
-                ansjk(k) = ansjk(k) + ((tab(disc(i)))/(lc-1.0)) * log((lc-1.0) * t32 / ((tab(disc(i))) * t22)) / (tab(disc(i)))
-            end if
-        end do
-
-        ! Put kth observation back in table of counts
-        tab(disc(k)) = tab(disc(k)) + 1
-    end do
-
-    ! Get bias corrected MI value and z-value from the jackknife
-    ! using Tukey's pseudo-value approach.
-    ! (There are probably more efficient ways to do this.)
-    ps = dble(lc) * ans - (dble(lc) - 1.0) * ansjk
-
-    mps = sum(ps) / dble(lc)
-    sdps = sqrt(sum((ps - mps) * (ps - mps)) / (dble(lc) - 1.0))
-    zvalue = sqrt(dble(lc)) * mps / sdps
-
-    deallocate(tab)
-    deallocate(ptab)
-end subroutine
-
-subroutine mmim(cdat, nrc, ncc, sdat, nrs, ncs, mis, bcmis, zmat, h)
-    use iface
-    implicit none
-
-    ! Input variables
-    integer, intent(in) :: nrc, ncc, nrs, ncs !, switch
-    ! integer, intent(in), optional :: m
-    real(kind=rdble), dimension(nrc, ncc), intent(in) :: cdat
-    real(kind=rdble), dimension(ncc), intent(in), optional :: h
-    integer, dimension(nrs, ncs), intent(in) :: sdat
-
-    ! Output matrix (now holds bias corrected estimates)
-    real(kind=rdble), dimension(ncc, ncs), intent(out) :: mis
-    real(kind=rdble), dimension(ncc, ncs), intent(out) :: bcmis
-    ! Matrix of z-values
-    real(kind=rdble), dimension(ncc, ncs), intent(out) :: zmat
-
-    ! Arrays to hold non-missing observations only
-    ! Reuse 'static' arrays for speed
-    real(kind=rdble), dimension(nrc) :: cvec
-    integer, dimension(nrs) :: svec
-
-    ! Local variables
-    integer :: i, j, k, nok
-    logical, dimension(nrc) :: ok
-
-    ! Function to get R's code for missing integers
-    integer :: rnaint
-    ! Holds R's coding for missing integers (INT_MIN)
-    integer :: naint
-
-    ! R function to check real missing values
-    integer :: rfinite
-
-    naint = rnaint() ! Asks R for its missing integer coding
-
-    !$omp parallel do default(none) shared(ncc, ncs, cdat, sdat, &
-    !$omp nrc, naint, h, mis, bcmis, zmat)  &
-    !$omp private(ok, nok, cvec, svec, i, j) &
-    !$omp schedule(dynamic)
-    do i = 1, ncc
-        do j = 1, ncs
-            if (i <= ncc .and. j <= ncs) then
-                ! Remove missing values pairwise
-                do k = 1, nrc
-                    if (rfinite(cdat(k,i)) == 1 .and. sdat(k,j) /= naint) then
-                        ok(k) = .true.
-                    else
-                        ok(k) = .false.
-                    end if
-                end do
-
-                nok = count(ok)
-
-                ! Pack non-missing values
-                cvec = pack(cdat(:,i), mask = ok)
-                svec = pack(sdat(:,j), mask = ok)
-
-                ! Call pairwise mixed MI subroutine
-                call mmipw(cvec(1:nok), nok, svec(1:nok), h(i), mis(i,j), bcmis(i,j), zmat(i,j))
-            end if
-        end do
-    end do
-    !$omp end parallel do
-end subroutine
-
diff -Nru orig/mpmi/src/mminjk.f95 patched/mpi/src/mminjk.f95
--- orig/mpmi/src/mminjk.f95	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/src/mminjk.f95	1969-12-31 16:00:00.000000000 -0800
@@ -1,202 +0,0 @@
-! 
-!     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
-! 
-!     This file is part of the mpmi R package.
-! 
-!     This program is free software: you can redistribute it and/or modify
-!     it under the terms of the GNU General Public License as published by
-!     the Free Software Foundation, version 3.
-! 
-!     This program is distributed in the hope that it will be useful,
-!     but WITHOUT ANY WARRANTY; without even the implied warranty of
-!     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-!     GNU General Public License for more details.
-! 
-!     You should have received a copy of the GNU General Public License
-!     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-!
-
-
-subroutine mmipwnjk(cts, lc, disc, h, ans)
-    use iface
-    implicit none
-
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    ! Input variables:
-    ! Length of input vectors
-    integer, intent(in) :: lc
-
-    ! Vector for discrete variable (group membership)
-    integer, dimension(lc), intent(in) :: disc
-
-    ! Bandwidth for kernel density estimation
-    real(kind=rdble), intent(in) :: h
-
-    ! Continuous input vector
-    real(kind=rdble), dimension(lc), intent(in) :: cts
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    ! Output variables:
-    ! ans = raw MI value
-    real(kind=rdble), intent(out) :: ans 
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-   
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    ! Local variables:
-    ! Sums of kernel distances (see below)
-    real(kind=rdble), dimension(lc) :: t2, t3
-
-    ! Temporary variable for calculating kernel distances
-    real(kind=rdble) t1 
-
-    ! Loop indices
-    integer :: i, j, k 
-    ! Number of groups in discrete variable
-    integer :: levd
-
-    ! Kernel distance matrix
-    real(kind=rdble), dimension(lc, lc) :: kmat
-
-    ! Dynamic arrays:
-    ! Table of discrete variable
-    integer, dimension(:), allocatable :: tab
-
-    ! Above table scaled to probabilities / relative frequencies
-    real(kind=rdble), dimension(:), allocatable :: ptab
-    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-    ans = 0.0
-
-    ! Number of levels of factor (coded with integers)
-    levd = maxval(disc)
-
-    ! Initialise table
-    allocate(tab(levd))
-    tab = 0
-
-    ! Tabulate discrete variable
-    do i = 1, lc
-        tab(disc(i)) = tab(disc(i)) + 1
-    end do
-
-    ! Probability table
-    allocate(ptab(levd))
-    do i = 1, levd
-        ptab(i) = dble(tab(i)) / dble(lc)
-    end do
-
-    ! Matrix of kernel distances (inefficient - should probably pack into vector)
-    kmat = 0.0 
-    t1 = 0.0
-    do i = 1, lc
-        do j = i + 1, lc
-            ! Epanechnikov kernel
-            t1 = (cts(j) - cts(i)) / h
-            if (abs(t1) .ge. 1.0) then
-                t1 = 0.0
-            else
-                t1 = 1.0 - (t1 * t1) 
-            end if
-            kmat(i, j) = t1
-
-            ! Symmetrise
-            kmat(j, i) = kmat(i, j)
-        end do
-        kmat(i, i) = kmat(i, i) + 1.0
-    end do
-
-    ! Sum of kernel distances from cts(i) to all points
-    t2 = 0.0
-    ! Sum of kernel distances from cts(i) to all points in same subgroup
-    t3 = 0.0
-
-    ! Evaluate non-jackknifed MI and fill t2 and t3
-    do i = 1, lc
-        do j = i + 1, lc
-            t2(i) = t2(i) + kmat(i, j)
-
-            ! Using kernel symmetry
-            t2(j) = t2(j) + kmat(i, j)
-
-            if (disc(j) == disc(i)) then
-                t3(i) = t3(i) + kmat(i, j)
-                ! Using kernel symmetry
-                t3(j) = t3(j) + kmat(i, j)
-            end if
-        end do
-
-        ! For when i == j
-        t2(i) = t2(i) + 1.0
-        t3(i) = t3(i) + 1.0
-
-        ! Accumulate MI
-        ans = ans + ptab(disc(i)) * log(lc * t3(i) / (tab(disc(i)) * t2(i))) / tab(disc(i))
-    end do
-
-    deallocate(tab)
-    deallocate(ptab)
-end subroutine
-
-subroutine mmimnjk(cdat, nrc, ncc, sdat, nrs, ncs, mis, h)
-    use iface
-    implicit none
-
-    ! Input variables
-    integer, intent(in) :: nrc, ncc, nrs, ncs 
-    real(kind=rdble), dimension(nrc, ncc), intent(in) :: cdat
-    real(kind=rdble), dimension(ncc), intent(in), optional :: h
-    integer, dimension(nrs, ncs), intent(in) :: sdat
-
-    ! Output matrix (now holds bias corrected estimates)
-    real(kind=rdble), dimension(ncc, ncs), intent(out) :: mis
-
-    ! Arrays to hold non-missing observations only
-    ! Reuse 'static' arrays for speed
-    real(kind=rdble), dimension(nrc) :: cvec
-    integer, dimension(nrs) :: svec
-
-    ! Local variables
-    integer :: i, j, k, nok
-    logical, dimension(nrc) :: ok
-
-    ! Function to get R's code for missing integers
-    integer :: rnaint
-    ! Holds R's coding for missing integers (INT_MIN)
-    integer :: naint
-
-    ! R function to check real missing values
-    integer :: rfinite
-
-    naint = rnaint() ! Asks R for its missing integer coding
-
-    !$omp parallel do default(none) shared(ncc, ncs, cdat, sdat, &
-    !$omp nrc, naint, h, mis)  &
-    !$omp private(ok, nok, cvec, svec, i, j) &
-    !$omp schedule(dynamic)
-    do i = 1, ncc
-        do j = 1, ncs
-            if (i <= ncc .and. j <= ncs) then
-                ! Remove missing values pairwise
-                do k = 1, nrc
-                    if (rfinite(cdat(k,i)) == 1 .and. sdat(k,j) /= naint) then
-                        ok(k) = .true.
-                    else
-                        ok(k) = .false.
-                    end if
-                end do
-
-                nok = count(ok)
-
-                ! Pack non-missing values
-                cvec = pack(cdat(:,i), mask = ok)
-                svec = pack(sdat(:,j), mask = ok)
-
-                ! Call pairwise mixed MI subroutine
-                call mmipwnjk(cvec(1:nok), nok, svec(1:nok), h(i), mis(i,j))
-            end if
-        end do
-    end do
-    !$omp end parallel do
-end subroutine
-
diff -Nru orig/mpmi/src/nawrap.c patched/mpi/src/nawrap.c
--- orig/mpmi/src/nawrap.c	2019-04-21 23:12:27.000000000 -0700
+++ patched/mpi/src/nawrap.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,27 +0,0 @@
- /*
-     Copyright 2013 Chris Pardy <cpardy@unsw.edu.au>
- 
-     This file is part of the mpmi R package.
- 
-     This program is free software: you can redistribute it and/or modify
-     it under the terms of the GNU General Public License as published by
-     the Free Software Foundation, version 3.
- 
-     This program is distributed in the hope that it will be useful,
-     but WITHOUT ANY WARRANTY; without even the implied warranty of
-     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-     GNU General Public License for more details.
- 
-     You should have received a copy of the GNU General Public License
-     along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-
-#include <R.h>
-
-/* Value of missing integers (INT_MIN) */
-int F77_SUB(rnaint)(void) { return(R_NaInt); }
-
-/* Function to check for missing real values */
-int F77_SUB(rfinite)(double *x) { return(R_FINITE(*x)); }
-
diff -Nru orig/mpmi/vignettes/Vignette.Rnw patched/mpi/vignettes/Vignette.Rnw
--- orig/mpmi/vignettes/Vignette.Rnw	2014-09-21 18:58:03.000000000 -0700
+++ patched/mpi/vignettes/Vignette.Rnw	1969-12-31 16:00:00.000000000 -0800
@@ -1,291 +0,0 @@
-\documentclass[a4paper]{article}
-\title{Introduction to \texttt{mpmi}}
-\author{Chris Pardy}
-
-\begin{document}
-%\VignetteIndexEntry{Introduction to mpmi}
-%\VignetteDepends{mpmi}
-\maketitle
-
-\section{Using the \texttt{mpmi} package}
-
-The following vignette will provide a brief introduction to the \texttt{mpmi}
-package, showing the use of the two main functions (\texttt{cmi()} and
-\texttt{mmi()}) as well as explicit parallelisation of their pairwise versions(
-\texttt{cmi.pw()} and \texttt{mmi.pw()}).
-
-First we load the library
-<<results=hide>>=
-library(mpmi)
-@
-
-\subsection{Continuous vs continuous comparisons}
-
-We demonstrate the calculation of MI and BCMI for all pairs of a group of
-continuous variables using a simulated dataset included in the \texttt{mpmi}
-package. The dataset, \texttt{mpmidata} contains a matrix of continuous data
-\texttt{cts} and a matrix of categorical data \texttt{disc}. The continuous data
-consists of $50$ subjects with $100$ variables following a multivariate normal
-distribution (note that this is done for simplicity as our approach is designed
-to work for a much wider class of distributions).  The continuous data were
-simulated to have an association that decays linearly as the distance between each
-pair of variables' indices increases. For reference this was created as follows
-(note that this requires the \texttt{MASS} library to be loaded):
-<<>>=
-# library(MASS)
-# mu <- 1:100
-# S <- toeplitz((100:1)/100)
-# set.seed(123456789)
-# dat <- mvrnorm(50, mu, S)
-# cts <- scale(dat)
-@
-
-The data are loaded and the \texttt{cmi()} function is then applied:
-<<>>=
-data(mpmidata)
-ctsresult <- cmi(cts)
-@
-Below we show the structure of the results object. It is a list containing 3
-matrices. For a set of continuous variables these are square symmetric matrices
-of a similar form to a correlation matrix.
-<<>>=
-str(ctsresult)
-@
-The raw MI values:
-<<>>=
-round(ctsresult$mi[1:5,1:5], 2)
-@
-Jackknife bias corrected MI values:
-<<>>=
-round(ctsresult$bcmi[1:5,1:5], 2)
-@
-
-We can check the results against the pairwise function. In this case we
-calculate the MI between the first variable and itself, which estimates
-its entropy.
-<<>>=
-cmi.pw(cts[,1], cts[,1])
-@
-This agrees with the results above (i.e., the \texttt{[1,1]} element of each
-results matrix).
-
-We can use the \texttt{mp()} function to plot an MI (or correlation) matrix. This
-plots the matrix with points corresponding to the same order that they are
-displayed in a numerical matrix (i.e, the usual mathematical way). 
-It is scaled so that red is the largest value
-and white is the smallest. When applied to the results above we can see the larger 
-values along the diagonal of the BCMI matrix, decaying as the difference between
-$i$ and $j$ increases.
-
-\begin{center}
-<<fig=TRUE,echo=TRUE>>=
-mp(ctsresult$bcmi)
-@
-\end{center}
-
-\subsection{Discrete vs continuous comparisons}
-
-To demonstrate MI for mixed comparisons we generate $75$ random SNP
-variables and create a new set of continuous data where some of the values have
-been shifted according to the categories. 
-<<>>=
-# set.seed(987654321)
-# disc <- rep(c("A", "H", "B"), ceiling(50 * 75 / 3))
-# disc <- matrix(disc, nrow = 50, ncol = 75)
-# disc <- apply(disc, 2, sample)
-@
-This shuffles a fairly even set of $A$, $H$, and $B$ for each variable. We then
-introduce a fairly strong U-shaped shift to continuous variable $i$ based on the
-value of discrete variable $k$, but only for cases where $i = k$.
-<<>>=
-cts2 <- cts
-for (variable in 1:75)
-{
-    for (subject in 1:50)
-    {
-        if (disc[subject, variable] == "A") 
-        {
-            cts2[subject, variable] <- cts[subject, variable] - 2
-        }
-        if (disc[subject, variable] == "B") 
-        {
-            cts2[subject, variable] <- cts[subject, variable] - 2
-        }
-    }
-}
-@
-We run the \texttt{mmi()} function on the discrete and continuous data:
-<<>>=
-mixedresult <- mmi(cts2, disc)
-@
-The results object for mixed comparisons have the same form as the results
-object for continuous comparisons. The only difference is that now instead of
-square symmetric matrices (for continuous data) the results are $n_c \times n_d$
-matrices where $n_c$ is the number of continuous variables and $n_d$ is the
-number of discrete variables. The row index refers to continuous variables and
-the column index refers to discrete variables.
-<<>>=
-str(mixedresult, width = 60, strict.width = "cut")
-@
-As before we have the raw MI values:
-<<>>=
-round(mixedresult$mi[1:5,1:5], 2)
-@
-And jackknife bias corrected MI values:
-<<>>=
-round(mixedresult$bcmi[1:5,1:5], 2)
-@
-
-Once again we can check by using the pairwise function:
-<<>>=
-mmi.pw(cts2[,1], disc[,1])
-@
-
-We can use \texttt{mp()} to plot the BCMI values and see the strong associations
-we've induced for cases where $i = j$ (note that the BCMI matrix is not square):
-\begin{center}
-<<fig=TRUE,echo=TRUE>>=
-mp(mixedresult$bcmi)
-@
-\end{center}
-
-\subsection{Explicit parallelisation}
-
-The pairwise functions are provided to allow the user to explicitly
-control parallelisation. Here we demonstrate how to parallelise in R using the
-\texttt{parallel} package (based on the older \texttt{multicore})
-package. As this package makes use of the POSIX \texttt{fork()} system function
-it can only be run on POSIX systems (i.e., Linux and MacOS; note that the
-implicit OpenMP parallelisation works on all three platforms, Linux, MacOS and
-Windows). For portability we will not actually run the code in this section, 
-although it should work fine on Linux and Mac.
-
-To apply this approach we need to create a function that will be run in
-parallel. Each application of this function will be sent to a processor core, so
-we must decide on `packaging' groups of MI calculations such that this
-is done in an efficient way. Details are given below.
-
-The pairwise functions \texttt{mmi.pw()}, \texttt{cmi.pw()} and \texttt{dmi.pw()}
-are provided to facilitate explicit parallelisation. Each of these functions
-calculates MI and BCMI values for comparisons between two variables with
-appropriate types.
-
-\subsubsection{Mixed comparisons}
-
-We first show how to parallelise the mixed comparisons as this is more
-straightforward than the continuous comparisons. Performance may be further
-improved by using the R bytecode compiler. First we must load the
-\texttt{parallel} and \texttt{compiler} libraries:
-<<>>=
-# library(parallel) # Commented for portability
-library(compiler)
-@
-
-The \texttt{mmi.pw()} function will calculate appropriate smoothing bandwidths
-as required. This will result in a lot of unnecessary computational
-repetition, so it is much faster to pre-compute the bandwidths before running the
-comparisons in parallel:
-<<>>=
-hs <- apply(cts2, 2, dpik, level = 3L, kernel = "epanech")
-@
-
-Now we must choose how to parallelise. The simplest approach is to write a
-function that calculates all comparisons between continuous variables and a
-single discrete variable (or vice versa). This is the same approach implemented
-by OpenMP in \texttt{mmi()}. For each SNP $i$ we apply the following function:
-<<>>=
-fi <- function(i)
-{
-    bcmis <- rep(NaN, 100)
-    for (j in 1:100)
-    {
-        bcmis[j] <- mmi.pw(cts2[,j], disc[,i], h = hs[j])$bcmi
-    }
-    return(bcmis)
-}
-fi <- cmpfun(fi)
-@
-This returns a vector containing the BCMI values for SNP $i$. Modifying 
-\texttt{fi()} to also keep the raw MI scores is straightforward. 
-
-
-We now use the \texttt{mcmapply()} function from the \texttt{parallel} package
-(which is now a part of base R). 
-This will calculate the vectors returned by the \texttt{fi()} and bind them as
-columns in a matrix.
-<<>>=
-# parmmi <- mcmapply(fi, 1:75)
-@
-We can check that the results are equal to those calculated using implicit
-parallelisation:
-<<>>=
-# sum(abs(mixedresult$bcmi - parmmi))
-@
-
-\subsubsection{Continuous comparisons}
-
-Once again we pre-compute the smoothing parameters:
-<<>>=
-hs2 <- apply(cts, 2, dpik, level = 3L, kernel = "epanech")
-@
-
-For the continuous comparisons we only need to calculate each comparison once to
-fill the lower (or upper) triangle of the results matrix. This requires a
-slight modification to the range of the loop in \texttt{fi()}:
-<<>>=
-fi <- function(i)
-{
-    bcmis <- rep(NaN, 100)
-    for (j in i:100)
-    {
-        bcmis[j] <- cmi.pw(cts[,i], cts[,j], h = hs2[c(i,j)])$bcmi
-    }
-    return(bcmis)
-}
-fi <- cmpfun(fi)
-@
-
-We smooth each of the two continuous variables by a different amount, so the
-\texttt{cmi.pw()} function requires two additional parameters which are input as
-a vector. These will be automatically calculated if not explicitly given.
-We run this in parallel in the same way as above:
-<<>>=
-# parcmi <- mcmapply(fi, 1:100)
-@
-Now we check the results. The \texttt{parcmi} matrix contains an upper triangle
-full of missing values which would usually need to be symmetrised 
-(the \texttt{cmi()} wrapper function takes care of this). In general, an MI matrix for
-continuous variables is symmetric (much like a correlation matrix) and has
-entropy estimates along the diagonal. So to check these results we simply need
-to check that the lower triangle of \texttt{parcmi} is equal to the lower
-triangle of \texttt{ctsresult\$bcmi}.  A simple approach for
-this check is to define a convenience function \texttt{lt()} to extract the lower
-triangle of a matrix, and observe that the sum of the absolute differences is
-computationally zero:
-<<>>=
-lt <- function(x) x[lower.tri(x, diag = TRUE)]
-# sum(abs(lt(ctsresult$bcmi) - lt(parcmi)))
-@
-
-\subsection{Parallelisation across multiple machines}
-
-The parallel version can be run across multiple machines in a cluster in a
-similar manner, by using the \texttt{snowfall} R package. This requires
-helper functions to be written that are identical to the \texttt{fi()} above.
-
-\subsection{A note about $z$-values}
-
-The functions in this package also return $z$-scores from the jackknife test for
-the hypothesis of no association (i.e., zero MI). We have found p-values and confidence
-intervals based on these $z$-scores to be highly variable and often quite wrong.
-Do not use these for statistical inference. The jackknife bias correction
-however does work quite well to reduce error in estimation of MI values (which
-we report as BCMI). 
-
-Since we essentially get the $z$-scores for free after calculating the bias
-correction we have decided to report them. They are useful for giving some idea
-of the strength of an observed association and can be considered as a heuristic
-transformation of the BCMI values that may aid interpretation. A permutation
-test is a much better choice for inference.
-
-\end{document}
