<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <link REL=stylesheet HREF=Rtech.css>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>Proposed Changes to Colors in R Graphics</title>
</head>
<body bgcolor="#FFFFFF">

<h1>Proposed Changes to Colors in R Graphics</h1> 

<p><i>
Paul Murrell<br>
Department of Statistics<br>
The University of Auckland<br></i>
<tt><a
href="mail:paul@stat.auckland.ac.nz">paul@stat.auckland.ac.nz</a></tt></p>

<h3>Moving to sRGB as the graphics engine colorspace</h3>

<p>
The motivation for this RFC is that currently the R graphics 
engine stores colors as RGB tristimulus values, but without
any mention about which RGB colorspace that is.  In particular,
there is no assumption about the chromaticities of the
RGB primaries and there is no assumption about the whitepoint.
There is some notion of gamma, but it is, at best, a little
confused.  Currently, an R color object is completely ambiguous.

<p>
If we select sRGB as the colorspace for the graphics engine,
it comes with specific chromaticities for the RGB primaries,
a specific white point, and a specific gamma correction.
This would mean that R color objects would have a clear
meaning.  Because sRGB is an industry standard, R color objects
would also have a useful meaning because they would be set up
to "just work" on most modern computer screens (within the bounds
of what is necessary for statistical graphics;  we're not
aiming for desktop publishing or photographic manipulation
standards).

<p>
Having sRGB as the graphics engine colorspace would also
make it easier to write code for working with colors, 
such as the 'colorspace' package,
because the target, R color objects, would be well-defined.

<h4>Implications for the graphics engine</h4>

<p>
No changes need to be made to most of the C code (except maybe some 
comments need adding :).  sRGB colors can be stored using the 
existing 24-bit structure;  only the meaning of these values
is altered (basically, from meaningless to meaningful).

<p>
The alpha channel is orthogonal to the colorspace, so is not
affected.  (Though if anyone ever wanted to play with something
like alpha-compositing, I believe the non-linear sRGB values would have
to be linearized (reverse the gamma correction) before doing the
compositing.)  

<p>
There is code in colors.c that supports the hcl() function,
but this is already designed for sRGB (it uses the sRGB 
primaries, white point, and gamma).  

<h5>User-level functions</h5>

<p>
The rgb() function requires no change, BUT it would need to 
be acknowledged that the R, G, B values would be interpreted
as sRGB values.  

<p>
The hsv() function needs a bit of work.  
An HSV colorspace is a "relative" colorspace - it is a conversion
of a particular RGB colorspace.  If R's colors are sRGB, then the
HSV colors produced by hsv() are relative to sRGB.  This means that
the current 'gamma' argument to hsv() is NOT needed and should be
deprecated.  (Ditto for rgb2hsv() and rainbow().)

<p>
You can see the hsv() gamma problem with the following code, which
uses the colorspace package to get the model answer:

<pre>
    library(colorspace)
    
    # VERY different colors (because hsv() is not gamma-correcting)
    # [hex(..., gamma=2.4) because of bug in colorspace (see below)]
    plot(1:2, cex=40, pch=16, xlim=c(0, 3), ylim=c(0, 3),
         col=c(hsv(0, .5, .5), 
               hex(HSV(0, .5, .5), gamma=2.4)))
    
    # MUCH better given correct gamma 
    # (colors still not identical because hex() uses the
    #  exact sRGB gamma correction formula)
    plot(1:2, cex=40, pch=16, xlim=c(0, 3), ylim=c(0, 3),
         col=c(hsv(0, .5, .5, gamma=1/2.2), 
               hex(HSV(0, .5, .5), gamma=2.4)))

    # hcl() gets exactly the same answer as colorspace's HSV()
    # > as(HSV(0, .5, .5), "polarLUV")
    #            L        C        H
    # [1,] 61.92659 33.32213 12.18075
    plot(1:2, cex=40, pch=16, xlim=c(0, 3), ylim=c(0, 3),
         col=c(hcl(12.18075, 33.32213, 61.92659), 
               hex(HSV(0, .5, .5), gamma=2.4)))

</pre>

<p>
There is a function covertColor() to convert between colorspaces.
This is basically independent of R's colours so can remain unchanged.

<h4>Implications for graphics devices</h4>

<p>
There are two issues for devices:  
<ol>
<li>
<p>
Off-screen (file) devices may want to record that colors are being
specified in the sRGB colorspace;  this will help in
viewing and printing the output.  

<p>
postscript() already has a 'colormodel' argument that allows RGB, 
greyscale, or CMYK (trivial conversion from RGB).  These color models can
be applied by using PostScript operators setrgbcolor, setcmykcolor,
and setgray.  After a quick look at the PostScript Language 
Reference Manual (PLRM; third edition), sRGB is doable via 
the setcolor operator, but
will need additional setup to specify the sRGB colorspace 
(see p. 225 of PLRM).

<p>
From a look at the PDF docs, you can certainly specify a colorspace
(as expected), but to get sRGB might need a bit of setup code
(see pp. 256-257 of the PDF Reference (sixth edition)).

<p>
Need to look at bitmap(), png() (at least on Windows).

<li>
<p>
Screen devices may have to adjust how they handle gamma correction.

<p>
sRGB assumes a very specific gamma correction, which means that
the device will not have to do anything about gamma correction
if the device conforms to the sRGB specification and, for devices 
that do not conform, the sRGB spec provides precise information 
that should be enough for the device code to adjust R color 
objects to the specifications of the device.

<p>
Some relevant information may be available from various 
standards, e.g., 
<a href="http://www.w3.org/TR/REC-CSS2/colors.html#gamma-correction">CSS</a>.

<p>
The Quartz device uses CGContextSetRGB[Fill|Stroke]Color() for setting color
(devQuartz.c),
<a href="http://developer.apple.com/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_color/chapter_5_section_5.html#//apple_ref/doc/uid/TP30001066-CH205-BBCGJBGG">
which means</a> that it works in a "generic RGB colorspace", 
<a href="http://developer.apple.com/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_color/chapter_5_section_4.html#//apple_ref/doc/uid/TP30001066-CH205-TPXREF128">which means</a>
that "the system" tries to automatically convert the RGB color spec to the 
color space of the output device.  If R's color space became sRGB, then it
might be better to explicitly set the Quartz color space to sRGB (then 
Quartz can do a better job of converting to the color space of different
output devices).  It looks like something like ...

<pre>
CGColorSpaceCreateWithName(kCGColorSpaceSRGB);
</pre>

<p>
... <a href="http://developer.apple.com/documentation/GraphicsImaging/Reference/CGColorSpace/Reference/reference.html#//apple_ref/doc/c_ref/kCGColorSpaceSRGB">might work</a>.

<p>
The x11() and windows() device both have a 'gamma' parameter (internally,
X11 splits this into separate RedGamma, BlueGamma, and GreenGamma, but all
three key off the one 'gamma' anyway).  This gamma is applied as a simple
power exponent to RGB colour components.  

<p>
The default value for 'gamma' in both case is 1
(no gamma-correction) AND 
these gammas have always been fudge factors because there has never been
any notion of RGB primaries (or a whitepoint).

<p>
The simple thing to do is simply to leave them as fudge factors
(defaulting to 1).  The RGB values sent to the device are sRGB
and that should be about right for most monitors.  If things don't 
look right on your monitor, you can play with 'gamma' as a crude
extra gamma-correction fudge.  If you want to play around with 
fancier colour transformations, use something like convertColor()
or the 'colorspace' package.  If exact colour reproduction is your
bag, maybe R isn't for you.

</ol>


<p>
Third-party drivers would need to be looked at.  I suspect that
currently they do nothing about gamma, which would, without any
code changes, become probably the correct thing to do (at least as
a default).


<h4>Implications for add-on packages</h4>

<ul>
<li>
<p>
The 'colorspace' package.  This list includes some basic
todo's for the package:

<ul>
<li>
<p>
All CIE-based colorspaces and conversions between them 
are unaffected.  The problems arise
at the conversion from CIE-based to an RGB colorspace AND
when converting 'colorspace' colors to R color objects (which 
would be sRGB).

<p>
The conversion from CIE-based to RGB always ends up with CIE XYZ to RGB.
This conversion allows for different white points to be specified, but 
assumes that the RGB primaries conform to sRGB.  Gamma correction is
performed as a separate step, with gamma able to be specified.

<p>
There should be a separate sRGB class created that only records
the R, G, B channels.  The chromaticities of the primaries, the
white point, and the gamma are all implicit.

<p>
Converting from 
XYZ with D65 as the white point and a gamma of 2.4, the result is 
an sRGB color.  

<p>
The RGB class is currently underspecified.  There should be a
record of the white point for an object (and it should be possible
to specify this when creating an RGB object, just as it is when
converting from XYZ to RGB).  Otherwise the RGB object is
meaningless.

<p>
HSV (and HSL) objects should also record this information
(even though it will not be used when converting to RGB).

<p>
Gamma correction of an RGB object with a white point of D65,
using a gamma of 2.4,
should result in an sRGB object.

<p>
There should be a separate cRGB (corrected RGB) class and
gamma correction of an RGB object with a non-D65 white point,
and/or using a gamma other than 2.4,
should result in a cRGB object.

<p>
The hex() function 
(to convert a colorspace color object to an R color object)
will have nothing to do to convert an sRGB object
(other than convert 0-to-1 values to hexadecimal).
Convertion of an RGB object with a D65 white point will be 
straightforward, but for other RGB objects and for cRGB objects,
conversion (if possible) will require conversion back to XYZ and
then forward again to sRGB.

<li>
<p>
The hex() function currently uses a default gamma value of 2.2.
This is just a straight bug; the default should be 2.4.  
2.2 is used when approximating sRGB 
overall gamma with a single power curve.  But the underlying
calculation uses the "exact" sRGB gamma correction, which has
a small straight line segment followed by a power curve.
That curve has an exponent of 1/2.4.

<p>
It could be argued that hex() should drop the gamma argument 
altogether, but it could be useful to convert RGB or cRGB 
values to hex representation too.  Possibly the best approach
is to introduce an Rcolor() function that has no gamma 
argument and only converts to an sRGB hex representation.

<li>
<p>
The hex() function should have an alpha argument to allow 
semitransparency.

</ul>

<p>
The diagram below illustrates what the relationships between the
different colorspaces would look like following these changes.

<img src="colorspace.png">

<li>
<p>
The 'dichromat' package.

<p>
Based on a look at the code, plus the Vienot et al. (1999) article
it is based on, moving to sRGB just puts this package on a firmer
foundation.  

<p>
The package interpolates (via loess smooth) deuteranope and protanope
colors based on a fixed set of normal-to-color-blind mappings (as
provided in the Vienot at al article).  The important point seems to be
that the mappings in the article made asumptions about display screen
primaries, white point
and gamma that correspond pretty closely to sRGB (see paragraph 3
on page 244 of the article).  This suggests that it is very appropriate to
send sRGB triplets into 'dichromat' from R and to interpret triplets
fed back to R by 'dichromat' as sRGB  triplets, which is what will now
be the case.

<p>
One detail to worry about is whether values being passed back-and-forth
are gamma-corrected.  The values in the crucial table of mappings
in the Vienot et al article are uncorrected (see "step 1" on page 245 
of the article, which performs the (crude) gamma correction;  and 
"step 7" on page 248, which performs the inverse).  This means
that the interpolations in 'dichromat' are occurring on uncorrected
values, so values returned by 'dichromat' are uncorrected <em>and</em>
that the 'dichromat' code is interpreting incoming values as
uncorrected.

</ul>

<h4>Code structure</h4>

<p>
An overall issue is where to put the code that does conversions
between colorspaces.  Currently at least some transformations exist in 
each of the following places:
<ul>
<li>
C code supporting hcl() in 'grDevices' (colors.c)
(just does the polarLUV to sRGB conversion).
<li>
C code in 'colorspace' package (does a range of colorspace
conversions).
<li>
R code in convertColor() et al in 'grDevices' (does a slightly 
different range of colorspace conversions).
</ul>

<p>
Graphics devices may need to do these conversions
so it make most sense to have it in C code within 
(the graphics engine of) the base system.  The main disadvantage
of this is that it is not easy for anyone outside R core to
extend the code to new colorspaces.

<h4>Other colorspaces</h4>

<p>
It might be possible to use something fancier than sRGB for the 
internal storage of colors (e.g., CIE XYZ), but this has not been
seriously considered because it
would be overkill and would force the introduction of a lot
more conversions in the core graphics code (with a corresponding
cost both in terms
of code and performance).

<p>
One issue is the fact that sRGB has a restricted gamut (i.e., it 
cannot produce all possible colors) and other colorspaces can do 
better (e.g., Adobe RGB ?), but I still think sRGB is the way to 
go because it is recognised by so many different platforms/formats.

</body>
</html>
