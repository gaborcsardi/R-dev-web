<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <link REL=stylesheet HREF=http://developer.r-project.org/Rtech.css>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>Memory profiling</title>
  <STYLE TYPE="text/css">
    BODY { padding-left: 8%; padding-right: 8% }
  </STYLE>
</head>
<body bgcolor="#FFFFFF">

<h1 align="center">Memory profiling in R</h1> 

Two experimental additions to help in profiling memory use in R programs. 

<ul>
<li> <code>Rprof</code> has an option
<code>memory.profiling</code>. When <code>TRUE</code> the profiler
also writes out information the small and large vector heap sizes,
memory in nodes, and number of calls to <code>Rf_duplicate</code> in
the interval.  <code>memRprof</code> summarizes this information
<li> If R is compiled with <code>R_MEMORY_PROFILING</code> defined, the function <code>tracemem</code> marks an object so that <code>Rf_duplicate</code> will print a stack trace when the object is duplicated. This is intended for tracking accidental copying of large objects. <code>untracemem</code> will untrace an object (though not all copies of it) and <code>tracingState</code> controls whether tracing information is printed.<p>

 <code>tracemem</code> cannot be used on functions, since it uses the same trace bit that <code>trace</code> uses, and will not work on objects such as environments that are passed by reference and not duplicated. The output for this could be made prettier and sent to a file: the main thing to decide is how to handle files when multiple objects may be being traced.
</ul>

Valgrind can also help with memory profiling at the C level, using <code>--tool=massif</code>

<hr>
Thomas Lumley. 2006-5-8
<p>

