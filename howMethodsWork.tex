\documentclass[11pt]{article}

\newif\ifpdf
\ifx\pdfoutput\undefined
\pdffalse % we are not running PDFLaTeX
\else
\pdfoutput=1 % we are running PDFLaTeX
\pdftrue
\fi

\ifpdf
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi

\textwidth = 6.5 in
\textheight = 9 in
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
\headheight = 0.0 in
\headsep = 0.0 in
\parskip = 0.2in
\parindent = 0.0in

\title{How S4 Methods and Classes Work}
\author{John Chambers}

\begin{document}
\ifpdf
\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
\else
\DeclareGraphicsExtensions{.eps, .jpg}
\fi

\maketitle

\section{Methods and Claseses; Functions and Objects}
\label{sec:meth-clas-funct}

Methods and classes in the \S{} language are essentially programming concepts to enable good organization of objects and of functions, respectively.
Programming in \R{} starts out usually as writing functions, at least once we get past the strict cut-and-paste stage.
The functions are the actions of the language; calls to them express what the user wants to happen.
The arguments to the functions and the values returned by function calls are the objects.
These objects represent everything we deal with.
Actions create new objects (such as summaries and models) or present the information in the objects (by plots, printed summaries, or interfaces to other software).
\R{} is a functional, object-based system where users program to extend the capacity of the system in terms of new functionality and new kinds of objects.

Once programming in \R{} reaches a moderately ambitious level, the total complexity of the added functionality can start to obscure what the software is doing.
And the information in the objects may represent some important structure, to support new ideas and the information needed for computations.

The purpose of the method- and class-related software, usually referred to as S4 methods and classes, is to structure such programming into individual pieces.
The pieces have two important properties:  Their range of application is limited, so that they can make a clear statement about a strictly limited part of the program design; and they come with self-description, in the sense of metadata that allows the software itself to examine the methods and classes.

This document discusses the information describing methods and classes in \R{} and how that information is used during an \R{} session.
Although the title talks about methods, and for programmers it's the construction of methods (and classes) that occupies most attention, the way to understand how things work is to see \emph{functions} and classes as the prime organizing principles.
Methods are the connectors that join the two together.

\section{Functions, Classes, and Object-oriented Programming}
\label{sec:funct-class-object}

Since the function-class paradigm was introduced into \S{} in the early 1990s, terms like \dQuote{object-oriented programming} have turned up frequently in discussions.
The term has many connotations and may help to orient readers, but it can as easily confuse them, so we need to clarify early on a distinction.

Languages to which the object-oriented programming (OOP) term is typically applied are mostly what might better be called class-based programming, well-known examples being \Cpp{} or \Java{}.
In these languages the essential programming unit is the class definition.
Objects are generated as instances of a class and computations on the objects consist of \emph{invoking methods on}  that object.
Depending on how strict the language is, all or most of the computations must be expressed in this form.
Method invocation is an operator, operating on an instance of a class.
Software organization is essentially simple and  hierarchical, in the sense that all methods are defined as part of a particular class.

The key concept to keep in mind is that function-class programming has that two-way,  hyphenated organization by functions and by classes, particularly for thinking about methods.
A method no longer \dQuote{belongs} to a class.
In the first analysis, methods belong to the generic function for which they are defined.
To understand how the computations work, the first organizing principle needed is to think of the generic function as \emph{including} all the currently active methods for that function.
This does in fact happen during an \R{} session:  A generic function will collect or \emph{cache} all the methods for that function belonging to all the \R{} packages that have been loaded in the session.
When the function is called, the \R{} evaluator then \emph{selects} a method from those available, by examining how well different methods match the actual arguments in the call.

But precisely in this selection process we have to face the greater complexity of the function-class paradigm, compared to the simpler class paradigm.
Methods are stored within the generic function according to matched pairing of one or more classes each with one of the formal arguments of the function.
It's the closeness of the corresponding actual arguments to the paired class that determines how well the method matches the call.
And that closeness in turn is determined by the definition of the class.
As far as program design goes, the definition of suitable classes often motivates the design of methods.

From the users' view, though, the generic function has (or at least should have) a natural definition in terms of what it is intended to do:  \SFunction{plot} displays graphics to represent an object or the relation between two objects; arithmetic operators such as \SOperator{+} carry out the corresponding intuitive numerical computations or extensions of those.
Methods should map those intuitive notions naturally and reliably into the concepts represented by the class definitions.
Doing that well is the important part of dealing with methods and classes.
The present discussion explains how a particular set of class and method definitions will be used in computations.

We want to end up with a description of how methods are selected, but getting there will go more smoothly if we take two detours to say how first classes  and then  methods are organized.
We also need to bring in a third organizing principle explicitly, the \R{} \emph{package}.
The next three sections take each of these in turn.

\section{Class Definitions and Inheritance}
\label{sec:class-defin-inher}

\section{Methods and Generic Functions}
\label{sec:meth-gener-funct}

\section{Packages}
\label{sec:packages}



\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
