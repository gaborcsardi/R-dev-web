<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The R Blog</title>
    <link>/Blog/public/</link>
    <description>Recent content on The R Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 09 Nov 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/Blog/public/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>When you think `class(.) == *`, think again!</title>
      <link>/Blog/public/2019/11/09/when-you-think-class.---think-again/</link>
      <pubDate>Sat, 09 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/11/09/when-you-think-class.---think-again/</guid>
      <description>short lines !! -- Historical relict: R matrix is not an array In a recent discussion on the R-devel mailing list, in a thread started on July 8, head.matrix can return 1000s of columns – limit to n or add new argument? Michael Chirico and then Gabe Becker where proposing to generalize the head() and tail() utility functions, and Gabe noted that current (pre R-4.x.y) head() would not treat array specially.</description>
    </item>
    
    <item>
      <title>R Can Use Your Help: Reviewing Bug Reports</title>
      <link>/Blog/public/2019/10/09/r-can-use-your-help-reviewing-bug-reports/</link>
      <pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/10/09/r-can-use-your-help-reviewing-bug-reports/</guid>
      <description>If you use R you may have wondered if there are ways you can contribute to making R better. This is the first in several posts on how you might help. This post is about helping to review and resolve bugs reported on the R bug tracker.
Urgent bug reports, in particular ones with simple reproducible examples, are generally resolved and closed quickly. But those that are not can sometimes languish for a long time.</description>
    </item>
    
    <item>
      <title>GFortran Issues with LAPACK II</title>
      <link>/Blog/public/2019/09/25/gfortran-issues-with-lapack-ii/</link>
      <pubDate>Wed, 25 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/09/25/gfortran-issues-with-lapack-ii/</guid>
      <description>This is an update on my previous post from May.
A number of things changed since: GFortran started adopting a fix that by default prevents optimizations which break code calling BLAS/LAPACK functions from C without hidden length arguments. R has been updated to internally add these hidden length arguments (and also in other cases where LTO type mismatch was detected). R has exported macros for use in packages so that they can follow suit when calling BLAS/LAPACK and CRAN has been working with maintainers of the affected packages.</description>
    </item>
    
    <item>
      <title>S3 Method Lookup</title>
      <link>/Blog/public/2019/08/19/s3-method-lookup/</link>
      <pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/08/19/s3-method-lookup/</guid>
      <description>At the core of the S3 object system as introduced in the White Book lies the idea that (S3) methods are ordinary functions that follow the GEN.CLS naming convention (with GEN.default as a final fallback). In the initial R implementation of this object system, these methods were searched for in the environment (and all enclosing environments) from which the generic was called.
With the advent of namespaces (see Tierney (2003), “Name space management for R”, R News, 3(1):2-6) a mechanism for registering S3 methods via S3method() directives in the NAMESPACE file of a package was added.</description>
    </item>
    
    <item>
      <title>GFortran Issues with LAPACK</title>
      <link>/Blog/public/2019/05/15/gfortran-issues-with-lapack/</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/05/15/gfortran-issues-with-lapack/</guid>
      <description>Recent version of the GNU Fortran compiler (7, 8, 9) include optimizations that break interoperability between C and Fortran code with BLAS/LAPACK. The compiled code of BLAS/LAPACK corrupts stack, often resulting in crashes. This impacts R, R packages directly calling into BLAS/LAPACK, and all other applications of BLAS/LAPACK. The work-around is to compile BLAS/LAPACK with -fno-optimize-sibling-calls. This option is now used in R-Devel and R-Patched, so that the reference BLAS and LAPACK included in R are compiled with that option.</description>
    </item>
    
    <item>
      <title>Common PROTECT Errors</title>
      <link>/Blog/public/2019/04/18/common-protect-errors/</link>
      <pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/04/18/common-protect-errors/</guid>
      <description>This post presents the most common PROTECT bugs present in packages, based on manual inspection of ~100 remaining CRAN packages with reports from rchk.
Background Any C/C++ code interacting with R, both inside R itself and in packages, needs to inform the garbage collector about which objects on the R heap are reachable from local variables. Pointers to such objects are kept on the pointer protection stack or the precious list or multi-set, but the most common is the pointer protection stack with PROTECT/UNPROTECT macros.</description>
    </item>
    
    <item>
      <title>HCL-Based Color Palettes in grDevices</title>
      <link>/Blog/public/2019/04/01/hcl-based-color-palettes-in-grdevices/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/04/01/hcl-based-color-palettes-in-grdevices/</guid>
      <description>Starting with R 3.6.0 a new hcl.colors() function is available in grDevices, providing a wide range of HCL-based color palettes with much better perceptual properties than existing RGB/HSV-based palettes like rainbow(). An accompanying new hcl.pals() function lists available palette names for hcl.colors(). It is a basic and lean implementation of the pre-specified palettes in the colorspace package, closely approximating palettes from many other packages like ColorBrewer, CARTO, viridis, scico, etc.</description>
    </item>
    
    <item>
      <title>Use of C&#43;&#43; in Packages</title>
      <link>/Blog/public/2019/03/28/use-of-c---in-packages/</link>
      <pubDate>Thu, 28 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/03/28/use-of-c---in-packages/</guid>
      <description>About 20% packages from CRAN and BIOC repositories include some native code and more than a half of those include some code in C++. This number is rather high given that the R API and runtime have been designed for C (or Fortran) and cannot be used reliably from C++, without extensive effort and restrictions. To avoid nasty bugs in such code, one needs to know R internals well, and when following the restrictions, one cannot use much from C++ anyway.</description>
    </item>
    
    <item>
      <title>Managing Search Path Conflicts</title>
      <link>/Blog/public/2019/03/19/managing-search-path-conflicts/</link>
      <pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/03/19/managing-search-path-conflicts/</guid>
      <description>Starting with R 3.6.0 the library() and require() functions allow more control over handling search path conflicts when packages are attached. The policy is controlled by the new conflicts.policy option. This post provides some background and details on this new feature.
Background When loading a package and attaching it to the search path, conflicts can occur between objects defined in the new package and ones already provided by other packages on the search path.</description>
    </item>
    
    <item>
      <title>Staged Install</title>
      <link>/Blog/public/2019/02/14/staged-install/</link>
      <pubDate>Thu, 14 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/02/14/staged-install/</guid>
      <description>This text is about a new feature in R, staged installation of packages. It may be of interest to package authors and maintainers, and particularly to those who maintain packages that are affected.
The problem I often have to run checks for all CRAN and BIOC packages to test the impact of my changes to R. This is to find about my own bugs, but often I also wake up existing bugs in packages or R or find out that some packages rely on undocumented API or behavior.</description>
    </item>
    
    <item>
      <title>Parser Speedups</title>
      <link>/Blog/public/2019/01/07/parser-speedups/</link>
      <pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/01/07/parser-speedups/</guid>
      <description>It wasn’t my primary goal to improve parser performance nor to measure it. I’ve been working on optimizations to reduce the runtime overhead of including source reference into packages (this is not done by default due to space and execution time overheads). I’ve added an option to exclude parse data from source references and enabled it by default for packages, as parse data account for most of the runtime overhead of source references while they are rarely needed.</description>
    </item>
    
    <item>
      <title>Unprotecting by Value</title>
      <link>/Blog/public/2018/12/10/unprotecting-by-value/</link>
      <pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2018/12/10/unprotecting-by-value/</guid>
      <description>In short, UNPROTECT_PTR is dangerous and should not be used. This text describes why and describes how to replace it, including mset-based functions that have been introduced as a substitute for situations when unprotection by value is really needed. This could be of interest to anyone who writes native code to interface with the R heap, and definitely to all who use UNPROTECT_PTR in their code.
Background R provides several functions to protect pointers to R objects held by local C variables (typed SEXP) from the garbage collector.</description>
    </item>
    
    <item>
      <title>Conditions of Length Greater Than One</title>
      <link>/Blog/public/2018/10/12/conditions-of-length-greater-than-one/</link>
      <pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2018/10/12/conditions-of-length-greater-than-one/</guid>
      <description>Historically R language allows conditions in if and while statements to be vectors (of length greater than one). The first element is used but the remaining elements are ignored, since November 2002 also with a warning (added by Brian Ripley). Following an intuition that such situations would typically arise from a programming error, an option has been added in March 2017 to optionally allow signalling a runtime error, instead (the patch was by Martin Maechler, pinged by a suggestion of Henrik Bengtsson on the R-devel mailing list).</description>
    </item>
    
    <item>
      <title>Maximum Number of DLLs</title>
      <link>/Blog/public/2018/03/23/maximum-number-of-dlls/</link>
      <pubDate>Fri, 23 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2018/03/23/maximum-number-of-dlls/</guid>
      <description>Some packages contain native code, which is linked to R dynamically in the form of dynamically loaded libraries (DLLs). Recently, R users started loading increasing numbers of packages; “workflow documents” are one source of this pattern. This has eventually lead to hitting the DLL limit in R, which materializes as runtime error “maximal number of DLLs reached”.
Limit on the number of open files The DLL limit in R is good for one important reason.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/Blog/public/about/</link>
      <pubDate>Wed, 17 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/about/</guid>
      <description>On this blogging site R developers share their experience, ideas and plans related to R core implementation. Technical details presented here might be useful for package developers and interesting for technically-minded R enthusiasts.
The blog posts represent individual opinions of their authors. Unless stated so explicitly, they should not be taken as positions of R Core nor R Foundation.
In the interest of technical quality of the posts, the authors may modify existing posts after publication.</description>
    </item>
    
  </channel>
</rss>