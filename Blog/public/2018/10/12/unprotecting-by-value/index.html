<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.40.1" />


<title>Unprotecting by Value - The R Blog</title>
<meta property="og:title" content="Unprotecting by Value - The R Blog">



  







<link rel="stylesheet" href="/Blog/public/css/fonts.css" media="all">
<link rel="stylesheet" href="/Blog/public/css/main.css" media="all">

<link rel="icon" type="image/png"
      href="/Blog/public/images/favicon-32x32.png"
      sizes="32x32" />

<link rel="icon" type="image/png"
      href="/Blog/public/images/favicon-16x16.png"
      sizes="16x16" />



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/Blog/public/index.html" class="nav-logo">
    <img src="/Blog/public/images/Rlogo.png"
         width="100"
         height="78"
         alt="R">
  </a>

  <ul class="nav-links">
    
    <li><a href="/Blog/public/about/index.html">About</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">


    
      
        <h1 class="article-title">Tomas Kalibera: Unprotecting by Value</h1>
      
      
      
        <span class="article-metadata">Categories:
        Internals, User-visible Behavior
        </span>
        <br>
      
      
        <span class="article-metadata">Tags:
        parsing, PROTECT bugs
        </span>
        <br>
            
      
      <span class="article-date">First published: 2018/10/12</span>
    

    <div class="article-content">
      <p>In short, <code>UNPROTECT_PTR</code> is dangerous and should not be used. This text describes why and what to do, instead. It could be of interest to anyone who writes native code to interface with the R heap, and definitely anyone who uses <code>UNPROTECT_PTR</code> in their code.</p>
<div id="background" class="section level1">
<h1>Background</h1>
<p>R provides several functions to protect objects held (only) by local C variables from the garbage collector. As documented in <a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Garbage-Collection">Writing R Extensions</a>, there are two spaces reserved for pointers to protected objects: the pointer protection stack and the precious list.</p>
<p>The <em>pointer</em> protection stack is accessed using <code>PROTECT</code>/<code>UNPROTECT</code>, pointers are unprotected by position and always from the top of the stack. One can also use <code>PROTECT_WITH_INDEX</code>/<code>REPROTECT</code> to replace a pointer defined by its position in the stack, which allows to simplify and speed-up code that repeatedly updates local variables holding pointers, even though one could still use a sequence of <code>PROTECT</code>/<code>UNPROTECT</code> operations, instead. The pointer protection stack needs to be managed in-line with the C call stack: after returning from a function, the stack depth should be the same as when the function was called (pointer protection balance). A long jump (R error) recovers the previous stack depth, unprotecting the values that have been left on the stack by code executed after the jump was set but before it has been done.</p>
<p>Although such situations are very rare, sometimes achieving pointer protection balance is difficult, sometimes say package code wishes to keep some allocated space without returning a pointer to it (hence without making the caller protect it, something like a semi-global buffer). This is addressed by the <em>precious list</em>, which is accesed using <code>R_PreserveObject</code>/<code>R_ReleaseObject</code>. It is implement as a linked list (and yes, <code>R_PreserveObject</code> allocates!) and objects are unprotected by value. There is no automated unprotection on error, the user is always responsible for unprotecting these objects. To achieve that in case of R errors (long jumps), it may be necessary to allocate a dummy object, set up its finalizer, and let the finalizer release needed objects from the precious list. Also, unprotect by value is slow.</p>
<p>This API was still not enough for a very special class of applications, for generated parsers such as the R parser generated by <code>bison</code>. The parser code uses a stack of semantic values, which are pointers to objects on the R heap. Values are pushed on the stack by the tokenizer during shift operations, are both pushed and removed during actions of reduce operations, and are removed on some parse errors. R errors (long jumps) can also occur during parsing. This key problem is that the code of the parser is generated and bison cannot be customized enough to ensure insertion of <code>PROTECT</code>/<code>UNPROTECT</code> operations: it would be natural to allocate the semantic values’ stack on the R heap, protect it, and also protect semantic values when held in local variables but not yet on the semantic values’ stack. But, this is not possible.</p>
<p>To work around this problem, <code>UNPROTECT_PTR</code> had been introduced earlier to allow fast unprotect-by-value operation for semantic values. When new semantic values are created, they are immediatelly put on the protection stack by <code>PROTECT</code> by the tokenizer and reduce rules. The values are unprotected by <code>UNPROTECT_PTR</code> inside the reduce rules, and the pointer protection stack depth is restored after certain parse errors that did not cause a long jump.</p>
</div>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/Blog/public/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          
        </ul>
      </footer>

    </div>
    

    

    
  </body>
</html>

