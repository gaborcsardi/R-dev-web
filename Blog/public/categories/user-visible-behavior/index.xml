<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>User Visible Behavior on The R Blog</title>
    <link>/Blog/public/categories/user-visible-behavior/</link>
    <description>Recent content in User Visible Behavior on The R Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 09 Nov 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/Blog/public/categories/user-visible-behavior/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>When you think `class(.) == *`, think again!</title>
      <link>/Blog/public/2019/11/09/when-you-think-class.---think-again/</link>
      <pubDate>Sat, 09 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/11/09/when-you-think-class.---think-again/</guid>
      <description>short lines !! -- Historical relict: R matrix is not an array In a recent discussion on the R-devel mailing list, in a thread started on July 8, head.matrix can return 1000s of columns – limit to n or add new argument? Michael Chirico and then Gabe Becker where proposing to generalize the head() and tail() utility functions, and Gabe noted that current (pre R-4.x.y) head() would not treat array specially.</description>
    </item>
    
    <item>
      <title>S3 Method Lookup</title>
      <link>/Blog/public/2019/08/19/s3-method-lookup/</link>
      <pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/08/19/s3-method-lookup/</guid>
      <description>At the core of the S3 object system as introduced in the White Book lies the idea that (S3) methods are ordinary functions that follow the GEN.CLS naming convention (with GEN.default as a final fallback). In the initial R implementation of this object system, these methods were searched for in the environment (and all enclosing environments) from which the generic was called.
With the advent of namespaces (see Tierney (2003), “Name space management for R”, R News, 3(1):2-6) a mechanism for registering S3 methods via S3method() directives in the NAMESPACE file of a package was added.</description>
    </item>
    
    <item>
      <title>Common PROTECT Errors</title>
      <link>/Blog/public/2019/04/18/common-protect-errors/</link>
      <pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/04/18/common-protect-errors/</guid>
      <description>This post presents the most common PROTECT bugs present in packages, based on manual inspection of ~100 remaining CRAN packages with reports from rchk.
Background Any C/C++ code interacting with R, both inside R itself and in packages, needs to inform the garbage collector about which objects on the R heap are reachable from local variables. Pointers to such objects are kept on the pointer protection stack or the precious list or multi-set, but the most common is the pointer protection stack with PROTECT/UNPROTECT macros.</description>
    </item>
    
    <item>
      <title>HCL-Based Color Palettes in grDevices</title>
      <link>/Blog/public/2019/04/01/hcl-based-color-palettes-in-grdevices/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/04/01/hcl-based-color-palettes-in-grdevices/</guid>
      <description>Starting with R 3.6.0 a new hcl.colors() function is available in grDevices, providing a wide range of HCL-based color palettes with much better perceptual properties than existing RGB/HSV-based palettes like rainbow(). An accompanying new hcl.pals() function lists available palette names for hcl.colors(). It is a basic and lean implementation of the pre-specified palettes in the colorspace package, closely approximating palettes from many other packages like ColorBrewer, CARTO, viridis, scico, etc.</description>
    </item>
    
    <item>
      <title>Managing Search Path Conflicts</title>
      <link>/Blog/public/2019/03/19/managing-search-path-conflicts/</link>
      <pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2019/03/19/managing-search-path-conflicts/</guid>
      <description>Starting with R 3.6.0 the library() and require() functions allow more control over handling search path conflicts when packages are attached. The policy is controlled by the new conflicts.policy option. This post provides some background and details on this new feature.
Background When loading a package and attaching it to the search path, conflicts can occur between objects defined in the new package and ones already provided by other packages on the search path.</description>
    </item>
    
    <item>
      <title>Unprotecting by Value</title>
      <link>/Blog/public/2018/12/10/unprotecting-by-value/</link>
      <pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2018/12/10/unprotecting-by-value/</guid>
      <description>In short, UNPROTECT_PTR is dangerous and should not be used. This text describes why and describes how to replace it, including mset-based functions that have been introduced as a substitute for situations when unprotection by value is really needed. This could be of interest to anyone who writes native code to interface with the R heap, and definitely to all who use UNPROTECT_PTR in their code.
Background R provides several functions to protect pointers to R objects held by local C variables (typed SEXP) from the garbage collector.</description>
    </item>
    
    <item>
      <title>Conditions of Length Greater Than One</title>
      <link>/Blog/public/2018/10/12/conditions-of-length-greater-than-one/</link>
      <pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2018/10/12/conditions-of-length-greater-than-one/</guid>
      <description>Historically R language allows conditions in if and while statements to be vectors (of length greater than one). The first element is used but the remaining elements are ignored, since November 2002 also with a warning (added by Brian Ripley). Following an intuition that such situations would typically arise from a programming error, an option has been added in March 2017 to optionally allow signalling a runtime error, instead (the patch was by Martin Maechler, pinged by a suggestion of Henrik Bengtsson on the R-devel mailing list).</description>
    </item>
    
    <item>
      <title>Maximum Number of DLLs</title>
      <link>/Blog/public/2018/03/23/maximum-number-of-dlls/</link>
      <pubDate>Fri, 23 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/Blog/public/2018/03/23/maximum-number-of-dlls/</guid>
      <description>Some packages contain native code, which is linked to R dynamically in the form of dynamically loaded libraries (DLLs). Recently, R users started loading increasing numbers of packages; “workflow documents” are one source of this pattern. This has eventually lead to hitting the DLL limit in R, which materializes as runtime error “maximal number of DLLs reached”.
Limit on the number of open files The DLL limit in R is good for one important reason.</description>
    </item>
    
  </channel>
</rss>